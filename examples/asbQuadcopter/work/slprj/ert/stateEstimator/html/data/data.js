var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"stateEstimator","ref":true,"files":[{"name":"stateEstimator.c","type":"source","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\stateEstimator","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: stateEstimator.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"stateEstimator.h\"\r\n#include \"stateEstimator_private.h\"\r\n#include \"rt_powf_snf.h\"\r\n\r\nP_stateEstimator_T stateEstimator_P_g = {\r\n  /* Mask Parameter: outlierBelowFloor_const\r\n   * Referenced by: '<S17>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: outlierJump_const\r\n   * Referenced by: '<S72>/Constant'\r\n   */\r\n  0.3,\r\n\r\n  /* Mask Parameter: currentStateVeryOffsonarflt_const\r\n   * Referenced by: '<S71>/Constant'\r\n   */\r\n  0.4,\r\n\r\n  /* Mask Parameter: currentEstimateVeryOffFromPressure_const\r\n   * Referenced by: '<S70>/Constant'\r\n   */\r\n  0.8,\r\n\r\n  /* Mask Parameter: DiscreteDerivative_ICPrevScaledInput\r\n   * Referenced by: '<S84>/UD'\r\n   */\r\n  0.0F,\r\n\r\n  /* Mask Parameter: Checkifvalidvisualpositionestimateavailable_const\r\n   * Referenced by: '<S210>/Constant'\r\n   */\r\n  -99.0F,\r\n\r\n  /* Mask Parameter: CompareToConstant_const\r\n   * Referenced by: '<S6>/Constant'\r\n   */\r\n  9.79038F,\r\n\r\n  /* Mask Parameter: CompareToConstant1_const\r\n   * Referenced by: '<S7>/Constant'\r\n   */\r\n  9.82962F,\r\n\r\n  /* Mask Parameter: maxp_const\r\n   * Referenced by: '<S87>/Constant'\r\n   */\r\n  0.6F,\r\n\r\n  /* Mask Parameter: maxq_const\r\n   * Referenced by: '<S89>/Constant'\r\n   */\r\n  0.6F,\r\n\r\n  /* Mask Parameter: maxw1_const\r\n   * Referenced by: '<S91>/Constant'\r\n   */\r\n  7.0F,\r\n\r\n  /* Mask Parameter: maxw2_const\r\n   * Referenced by: '<S92>/Constant'\r\n   */\r\n  7.0F,\r\n\r\n  /* Mask Parameter: maxdw1_const\r\n   * Referenced by: '<S85>/Constant'\r\n   */\r\n  80.0F,\r\n\r\n  /* Mask Parameter: maxdw2_const\r\n   * Referenced by: '<S86>/Constant'\r\n   */\r\n  80.0F,\r\n\r\n  /* Mask Parameter: maxp2_const\r\n   * Referenced by: '<S88>/Constant'\r\n   */\r\n  0.5F,\r\n\r\n  /* Mask Parameter: maxq2_const\r\n   * Referenced by: '<S90>/Constant'\r\n   */\r\n  0.5F,\r\n\r\n  /* Mask Parameter: maxw3_const\r\n   * Referenced by: '<S93>/Constant'\r\n   */\r\n  5.0F,\r\n\r\n  /* Mask Parameter: maxw4_const\r\n   * Referenced by: '<S94>/Constant'\r\n   */\r\n  5.0F,\r\n\r\n  /* Mask Parameter: minHeightforOF_const\r\n   * Referenced by: '<S95>/Constant'\r\n   */\r\n  -0.4F,\r\n\r\n  /* Mask Parameter: DeactivateAccelerationIfOFisnotusedduetolowaltitude_const\r\n   * Referenced by: '<S79>/Constant'\r\n   */\r\n  -0.4F,\r\n\r\n  /* Mask Parameter: donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto200_con\r\n   * Referenced by: '<S81>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Mask Parameter: donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto2001_co\r\n   * Referenced by: '<S82>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Mask Parameter: maxp3_const\r\n   * Referenced by: '<S206>/Constant'\r\n   */\r\n  0.18F,\r\n\r\n  /* Mask Parameter: maxq3_const\r\n   * Referenced by: '<S207>/Constant'\r\n   */\r\n  0.18F,\r\n\r\n  /* Mask Parameter: checkifPosavailable_const\r\n   * Referenced by: '<S205>/Constant'\r\n   */\r\n  -99.0F,\r\n\r\n  /* Mask Parameter: planarjumpsVISPOS_const\r\n   * Referenced by: '<S208>/Constant'\r\n   */\r\n  1.0F,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S66>/L*(y[k]-yhat[k|k-1])'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S68>/deltax'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pInitialization.M\r\n   * Referenced by: '<S152>/KalmanGainM'\r\n   */\r\n  { 0.0057568600814403865, 0.0, 0.0, 0.0057568600814411047 },\r\n\r\n  /* Expression: pInitialization.M\r\n   * Referenced by: '<S96>/KalmanGainM'\r\n   */\r\n  { 0.12546560898608969, 0.0, 0.0, 0.12546560898608969 },\r\n\r\n  /* Expression: pInitialization.A\r\n   * Referenced by: '<S14>/A'\r\n   */\r\n  { 1.0, 0.0, 0.005, 1.0 },\r\n\r\n  /* Expression: pInitialization.L\r\n   * Referenced by: '<S96>/KalmanGainL'\r\n   */\r\n  { 0.12546560898608977, 0.0, 0.0, 0.12546560898608977 },\r\n\r\n  /* Expression: pInitialization.L\r\n   * Referenced by: '<S152>/KalmanGainL'\r\n   */\r\n  { 0.0057568600814403873, 0.0, 0.0, 0.0057568600814411012 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S3>/Delay2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pInitialization.X0\r\n   * Referenced by: '<S14>/X0'\r\n   */\r\n  { -0.046, 0.0 },\r\n\r\n  /* Expression: -inf\r\n   * Referenced by: '<S15>/SaturationSonar'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: Estimator.alt.filterSonarNum\r\n   * Referenced by: '<S15>/soonarFilter_IIR'\r\n   */\r\n  { 3.756838019751262E-6, 1.1270514059253787E-5, 1.1270514059253787E-5,\r\n    3.756838019751262E-6 },\r\n\r\n  /* Expression: Estimator.alt.filterSonarDen\r\n   * Referenced by: '<S15>/soonarFilter_IIR'\r\n   */\r\n  { 1.0, -2.9371707284498907, 2.8762997234793319, -0.939098940325283 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S15>/soonarFilter_IIR'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pInitialization.M\r\n   * Referenced by: '<S18>/KalmanGainM'\r\n   */\r\n  { 0.026241420641871824, 0.069776736071494413 },\r\n\r\n  /* Expression: pInitialization.C\r\n   * Referenced by: '<S14>/C'\r\n   */\r\n  { 1.0, 0.0 },\r\n\r\n  /* Expression: [0 0 -g]\r\n   * Referenced by: '<S76>/gravity'\r\n   */\r\n  { 0.0, 0.0, -9.81 },\r\n\r\n  /* Expression: [0 0 g]\r\n   * Referenced by: '<S3>/Constant'\r\n   */\r\n  { 0.0, 0.0, 9.81 },\r\n\r\n  /* Expression: Estimator.pos.accelerationInputGain\r\n   * Referenced by: '<S76>/gainaccinput'\r\n   */\r\n  0.2,\r\n\r\n  /* Expression: pInitialization.D\r\n   * Referenced by: '<S14>/D'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pInitialization.L\r\n   * Referenced by: '<S18>/KalmanGainL'\r\n   */\r\n  { 0.026590304322229273, 0.069776736071495565 },\r\n\r\n  /* Expression: pInitialization.B\r\n   * Referenced by: '<S14>/B'\r\n   */\r\n  { 0.0, 0.005 },\r\n\r\n  /* Expression: pInitialization.Z\r\n   * Referenced by: '<S18>/CovarianceZ'\r\n   */\r\n  { 0.0026241420641871824, 0.0069776736071494412, 0.0069776736071494412,\r\n    0.03760769293505626 },\r\n\r\n  /* Expression: pInitialization.P0\r\n   * Referenced by: '<S14>/P0'\r\n   */\r\n  { 0.0026948589925820591, 0.0071657120718247331, 0.0071657120718247331,\r\n    0.038107692935056295 },\r\n\r\n  /* Expression: pInitialization.Z\r\n   * Referenced by: '<S96>/CovarianceZ'\r\n   */\r\n  { 0.62732804493044858, 0.0, 0.0, 0.62732804493044858 },\r\n\r\n  /* Expression: pInitialization.Z\r\n   * Referenced by: '<S152>/CovarianceZ'\r\n   */\r\n  { 0.0017270580244321161, 0.0, 0.0, 0.0017270580244323314 },\r\n\r\n  /* Expression: pInitialization.G\r\n   * Referenced by: '<S14>/G'\r\n   */\r\n  { 0.0, 1.0 },\r\n\r\n  /* Expression: pInitialization.H\r\n   * Referenced by: '<S14>/H'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pInitialization.N\r\n   * Referenced by: '<S14>/N'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pInitialization.Q\r\n   * Referenced by: '<S14>/Q'\r\n   */\r\n  0.0005,\r\n\r\n  /* Expression: pInitialization.R\r\n   * Referenced by: '<S14>/R'\r\n   */\r\n  0.1,\r\n\r\n  /* Computed Parameter: Gain1_Gain\r\n   * Referenced by: '<S8>/Gain1'\r\n   */\r\n  0.001F,\r\n\r\n  /* Computed Parameter: Gain_Gain\r\n   * Referenced by: '<S8>/Gain'\r\n   */\r\n  0.999F,\r\n\r\n  /* Computed Parameter: Gain2_Gain\r\n   * Referenced by: '<S8>/Gain2'\r\n   */\r\n  0.101936802F,\r\n\r\n  /* Computed Parameter: Gain3_Gain\r\n   * Referenced by: '<S8>/Gain3'\r\n   */\r\n  0.001F,\r\n\r\n  /* Computed Parameter: Gain4_Gain\r\n   * Referenced by: '<S8>/Gain4'\r\n   */\r\n  0.999F,\r\n\r\n  /* Computed Parameter: Gain_Gain_i\r\n   * Referenced by: '<S9>/Gain'\r\n   */\r\n  0.8F,\r\n\r\n  /* Computed Parameter: Gain1_Gain_k\r\n   * Referenced by: '<S9>/Gain1'\r\n   */\r\n  0.2F,\r\n\r\n  /* Expression: single(0)\r\n   * Referenced by: '<S12>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Expression: single(Estimator.complementaryFilterInit)\r\n   * Referenced by: '<S2>/Memory'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: Gain_Gain_c\r\n   * Referenced by: '<S12>/Gain'\r\n   */\r\n  -1.0F,\r\n\r\n  /* Computed Parameter: Bias_Bias\r\n   * Referenced by: '<S5>/Bias'\r\n   */\r\n  { 0.0F, 0.0F, 9.81F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: inverseIMU_gain_Gain\r\n   * Referenced by: '<S5>/inverseIMU_gain'\r\n   */\r\n  { 0.994075298F, 0.996184587F, 1.00549F, 1.00139189F, 0.993601203F, 1.00003F },\r\n\r\n  /* Computed Parameter: IIR_IMUgyro_r_NumCoef\r\n   * Referenced by: '<S5>/IIR_IMUgyro_r'\r\n   */\r\n  { 0.282124132F, 1.27253926F, 2.42084408F, 2.42084408F, 1.27253926F,\r\n    0.282124132F },\r\n\r\n  /* Computed Parameter: IIR_IMUgyro_r_DenCoef\r\n   * Referenced by: '<S5>/IIR_IMUgyro_r'\r\n   */\r\n  { 1.0F, 2.22871494F, 2.52446198F, 1.57725322F, 0.54102242F, 0.0795623958F },\r\n\r\n  /* Computed Parameter: IIR_IMUgyro_r_InitialStates\r\n   * Referenced by: '<S5>/IIR_IMUgyro_r'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: gyro_sensitivity_Gain\r\n   * Referenced by: '<S2>/gyro_sensitivity'\r\n   */\r\n  0.005F,\r\n\r\n  /* Computed Parameter: FIR_IMUaccel_InitialStates\r\n   * Referenced by: '<S5>/FIR_IMUaccel'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: FIR_IMUaccel_Coefficients\r\n   * Referenced by: '<S5>/FIR_IMUaccel'\r\n   */\r\n  { 0.0264077242F, 0.140531361F, 0.33306092F, 0.33306092F, 0.140531361F,\r\n    0.0264077242F },\r\n\r\n  /* Computed Parameter: Constant_Value_n\r\n   * Referenced by: '<S2>/Constant'\r\n   */\r\n  2.0F,\r\n\r\n  /* Computed Parameter: Merge_InitialOutput\r\n   * Referenced by: '<S2>/Merge'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: C_Value_p\r\n   * Referenced by: '<S149>/C'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 1.0F },\r\n\r\n  /* Computed Parameter: C_Value_f\r\n   * Referenced by: '<S78>/C'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 1.0F },\r\n\r\n  /* Computed Parameter: A_Value_c\r\n   * Referenced by: '<S78>/A'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 1.0F },\r\n\r\n  /* Computed Parameter: B_Value_p\r\n   * Referenced by: '<S78>/B'\r\n   */\r\n  { 0.005F, 0.0F, 0.0F, 0.005F },\r\n\r\n  /* Computed Parameter: D_Value_f\r\n   * Referenced by: '<S78>/D'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: A_Value_b\r\n   * Referenced by: '<S149>/A'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 1.0F },\r\n\r\n  /* Computed Parameter: B_Value_pu\r\n   * Referenced by: '<S149>/B'\r\n   */\r\n  { 0.005F, 0.0F, 0.0F, 0.005F },\r\n\r\n  /* Computed Parameter: D_Value_b\r\n   * Referenced by: '<S149>/D'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: X0_Value_e\r\n   * Referenced by: '<S78>/X0'\r\n   */\r\n  { 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: IIRgyroz_NumCoef\r\n   * Referenced by: '<S77>/IIRgyroz'\r\n   */\r\n  { 0.282124132F, 1.27253926F, 2.42084408F, 2.42084408F, 1.27253926F,\r\n    0.282124132F },\r\n\r\n  /* Computed Parameter: IIRgyroz_DenCoef\r\n   * Referenced by: '<S77>/IIRgyroz'\r\n   */\r\n  { 1.0F, 2.22871494F, 2.52446198F, 1.57725322F, 0.54102242F, 0.0795623958F },\r\n\r\n  /* Computed Parameter: IIRgyroz_InitialStates\r\n   * Referenced by: '<S77>/IIRgyroz'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: TSamp_WtEt\r\n   * Referenced by: '<S84>/TSamp'\r\n   */\r\n  200.0F,\r\n\r\n  /* Computed Parameter: opticalFlowToVelocity_gain_Gain\r\n   * Referenced by: '<S74>/opticalFlowToVelocity_gain'\r\n   */\r\n  1.0F,\r\n\r\n  /* Computed Parameter: Delay_InitialCondition\r\n   * Referenced by: '<S74>/Delay'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: invertzaxisGain_Gain\r\n   * Referenced by: '<S3>/invertzaxisGain'\r\n   */\r\n  -1.0F,\r\n\r\n  /* Computed Parameter: prsToAltGain_Gain\r\n   * Referenced by: '<S3>/prsToAltGain'\r\n   */\r\n  0.0832137167F,\r\n\r\n  /* Computed Parameter: pressureFilter_IIR_NumCoef\r\n   * Referenced by: '<S15>/pressureFilter_IIR'\r\n   */\r\n  { 3.75683794E-6F, 1.12705138E-5F, 1.12705138E-5F, 3.75683794E-6F },\r\n\r\n  /* Computed Parameter: pressureFilter_IIR_DenCoef\r\n   * Referenced by: '<S15>/pressureFilter_IIR'\r\n   */\r\n  { 1.0F, -2.93717074F, 2.87629962F, -0.939098954F },\r\n\r\n  /* Computed Parameter: pressureFilter_IIR_InitialStates\r\n   * Referenced by: '<S15>/pressureFilter_IIR'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Delay_InitialCondition_b\r\n   * Referenced by: '<S1>/Delay'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: X0_Value_j\r\n   * Referenced by: '<S149>/X0'\r\n   */\r\n  { 0.1F, 0.0F },\r\n\r\n  /* Computed Parameter: Constant_Value_e\r\n   * Referenced by: '<S150>/Constant'\r\n   */\r\n  2.0F,\r\n\r\n  /* Computed Parameter: Delay_InitialCondition_n\r\n   * Referenced by: '<S75>/Delay'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Integrator_gainval\r\n   * Referenced by: '<S75>/Integrator'\r\n   */\r\n  0.005F,\r\n\r\n  /* Computed Parameter: Integrator_IC\r\n   * Referenced by: '<S75>/Integrator'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: UseIPPosSwitch_Threshold\r\n   * Referenced by: '<S75>/UseIPPosSwitch'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: P0_Value_m\r\n   * Referenced by: '<S78>/P0'\r\n   */\r\n  { 0.717328072F, -0.0F, -0.0F, 0.717328072F },\r\n\r\n  /* Computed Parameter: G_Value_h\r\n   * Referenced by: '<S78>/G'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 1.0F },\r\n\r\n  /* Computed Parameter: H_Value_c\r\n   * Referenced by: '<S78>/H'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: N_Value_g\r\n   * Referenced by: '<S78>/N'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: Q_Value_f\r\n   * Referenced by: '<S78>/Q'\r\n   */\r\n  { 0.09F, 0.0F, 0.0F, 0.09F },\r\n\r\n  /* Computed Parameter: R_Value_k\r\n   * Referenced by: '<S78>/R'\r\n   */\r\n  { 5.0F, 0.0F, 0.0F, 5.0F },\r\n\r\n  /* Computed Parameter: P0_Value_h\r\n   * Referenced by: '<S149>/P0'\r\n   */\r\n  { 0.00173705805F, -0.0F, -0.0F, 0.00173705805F },\r\n\r\n  /* Computed Parameter: G_Value_p\r\n   * Referenced by: '<S149>/G'\r\n   */\r\n  { 0.1F, 0.0F, 0.0F, 0.1F },\r\n\r\n  /* Computed Parameter: H_Value_d\r\n   * Referenced by: '<S149>/H'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: N_Value_j\r\n   * Referenced by: '<S149>/N'\r\n   */\r\n  { 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: Q_Value_n\r\n   * Referenced by: '<S149>/Q'\r\n   */\r\n  { 0.001F, 0.0F, 0.0F, 0.001F },\r\n\r\n  /* Computed Parameter: R_Value_kf\r\n   * Referenced by: '<S149>/R'\r\n   */\r\n  { 0.3F, 0.0F, 0.0F, 0.3F },\r\n\r\n  /* Expression: pInitialization.isSqrtUsed\r\n   * Referenced by: '<S64>/isSqrtUsed'\r\n   */\r\n  false,\r\n\r\n  /* Expression: pInitialization.isSqrtUsed\r\n   * Referenced by: '<S144>/isSqrtUsed'\r\n   */\r\n  false,\r\n\r\n  /* Expression: pInitialization.isSqrtUsed\r\n   * Referenced by: '<S200>/isSqrtUsed'\r\n   */\r\n  false,\r\n\r\n  /* Start of '<S178>/Enabled Subsystem' */\r\n  {\r\n    /* Computed Parameter: deltax_Y0\r\n     * Referenced by: '<S204>/deltax'\r\n     */\r\n    0.0F\r\n  }\r\n  ,\r\n\r\n  /* End of '<S178>/Enabled Subsystem' */\r\n\r\n  /* Start of '<S171>/MeasurementUpdate' */\r\n  {\r\n    /* Computed Parameter: Lykyhatkk1_Y0\r\n     * Referenced by: '<S202>/L*(y[k]-yhat[k|k-1])'\r\n     */\r\n    0.0F\r\n  }\r\n  ,\r\n\r\n  /* End of '<S171>/MeasurementUpdate' */\r\n\r\n  /* Start of '<S122>/Enabled Subsystem' */\r\n  {\r\n    /* Computed Parameter: deltax_Y0\r\n     * Referenced by: '<S148>/deltax'\r\n     */\r\n    0.0F\r\n  }\r\n  ,\r\n\r\n  /* End of '<S122>/Enabled Subsystem' */\r\n\r\n  /* Start of '<S115>/MeasurementUpdate' */\r\n  {\r\n    /* Computed Parameter: Lykyhatkk1_Y0\r\n     * Referenced by: '<S146>/L*(y[k]-yhat[k|k-1])'\r\n     */\r\n    0.0F\r\n  }\r\n  /* End of '<S115>/MeasurementUpdate' */\r\n};\r\n\r\nMdlrefDW_stateEstimator_T stateEstimator_MdlrefDW;\r\n\r\n/* Block signals (default storage) */\r\nB_stateEstimator_c_T stateEstimator_B;\r\n\r\n/* Block states (default storage) */\r\nDW_stateEstimator_f_T stateEstimator_DW;\r\n\r\n/*\r\n * Output and update for atomic system:\r\n *    '<S144>/SqrtUsedFcn'\r\n *    '<S200>/SqrtUsedFcn'\r\n */\r\nvoid stateEstimator_SqrtUsedFcn(const real32_T rtu_u[4], boolean_T\r\n  rtu_isSqrtUsed, real32_T rty_P[4])\r\n{\r\n  int32_T i;\r\n  real32_T tmp;\r\n  if (rtu_isSqrtUsed) {\r\n    for (i = 0; i < 2; i++) {\r\n      tmp = rtu_u[i + 2];\r\n      rty_P[i] = tmp * rtu_u[2] + rtu_u[i] * rtu_u[0];\r\n      rty_P[i + 2] = tmp * rtu_u[3] + rtu_u[i] * rtu_u[1];\r\n    }\r\n  } else {\r\n    for (i = 0; i < 2; i++) {\r\n      rty_P[i] = rtu_u[i];\r\n      rty_P[i + 2] = rtu_u[i + 2];\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n * System initialize for enable system:\r\n *    '<S115>/MeasurementUpdate'\r\n *    '<S171>/MeasurementUpdate'\r\n */\r\nvoid stateEstimator_MeasurementUpdate_Init(real32_T rty_Lykyhatkk1[2],\r\n  P_MeasurementUpdate_stateEstimator_T *localP)\r\n{\r\n  /* SystemInitialize for Outport: '<S146>/L*(y[k]-yhat[k|k-1])' */\r\n  rty_Lykyhatkk1[0] = localP->Lykyhatkk1_Y0;\r\n  rty_Lykyhatkk1[1] = localP->Lykyhatkk1_Y0;\r\n}\r\n\r\n/*\r\n * Disable for enable system:\r\n *    '<S115>/MeasurementUpdate'\r\n *    '<S171>/MeasurementUpdate'\r\n */\r\nvoid stateEstimator_MeasurementUpdate_Disable(real32_T rty_Lykyhatkk1[2],\r\n  DW_MeasurementUpdate_stateEstimator_T *localDW,\r\n  P_MeasurementUpdate_stateEstimator_T *localP)\r\n{\r\n  /* Outputs for Enabled SubSystem: '<S115>/MeasurementUpdate' incorporates:\r\n   *  EnablePort: '<S146>/Enable'\r\n   */\r\n  /* Disable for Outport: '<S146>/L*(y[k]-yhat[k|k-1])' */\r\n  rty_Lykyhatkk1[0] = localP->Lykyhatkk1_Y0;\r\n  rty_Lykyhatkk1[1] = localP->Lykyhatkk1_Y0;\r\n\r\n  /* End of Outputs for SubSystem: '<S115>/MeasurementUpdate' */\r\n  localDW->MeasurementUpdate_MODE = false;\r\n}\r\n\r\n/*\r\n * Output and update for enable system:\r\n *    '<S115>/MeasurementUpdate'\r\n *    '<S171>/MeasurementUpdate'\r\n */\r\nvoid stateEstimator_MeasurementUpdate(boolean_T rtu_Enable, const real32_T\r\n  rtu_Lk[4], const real32_T rtu_yk[2], const real32_T rtu_Ck[4], const real32_T\r\n  rtu_xhatkk1[2], const real32_T rtu_Dk[4], const real32_T rtu_uk[2], real32_T\r\n  rty_Lykyhatkk1[2], DW_MeasurementUpdate_stateEstimator_T *localDW,\r\n  P_MeasurementUpdate_stateEstimator_T *localP)\r\n{\r\n  real32_T rtu_yk_idx_0;\r\n  real32_T rtu_yk_idx_1;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S115>/MeasurementUpdate' incorporates:\r\n   *  EnablePort: '<S146>/Enable'\r\n   */\r\n  if (rtu_Enable) {\r\n    localDW->MeasurementUpdate_MODE = true;\r\n\r\n    /* Sum: '<S146>/Sum' incorporates:\r\n     *  Product: '<S146>/C[k]*xhat[k|k-1]'\r\n     *  Product: '<S146>/D[k]*u[k]'\r\n     *  Sum: '<S146>/Add1'\r\n     */\r\n    rtu_yk_idx_0 = rtu_yk[0] - ((rtu_Ck[0] * rtu_xhatkk1[0] + rtu_xhatkk1[1] *\r\n      rtu_Ck[2]) + (rtu_Dk[0] * rtu_uk[0] + rtu_uk[1] * rtu_Dk[2]));\r\n    rtu_yk_idx_1 = rtu_yk[1] - ((rtu_xhatkk1[0] * rtu_Ck[1] + rtu_xhatkk1[1] *\r\n      rtu_Ck[3]) + (rtu_uk[0] * rtu_Dk[1] + rtu_uk[1] * rtu_Dk[3]));\r\n\r\n    /* Product: '<S146>/Product3' */\r\n    rty_Lykyhatkk1[0] = 0.0F;\r\n    rty_Lykyhatkk1[0] += rtu_Lk[0] * rtu_yk_idx_0;\r\n    rty_Lykyhatkk1[0] += rtu_Lk[2] * rtu_yk_idx_1;\r\n    rty_Lykyhatkk1[1] = 0.0F;\r\n    rty_Lykyhatkk1[1] += rtu_Lk[1] * rtu_yk_idx_0;\r\n    rty_Lykyhatkk1[1] += rtu_Lk[3] * rtu_yk_idx_1;\r\n  } else if (localDW->MeasurementUpdate_MODE) {\r\n    stateEstimator_MeasurementUpdate_Disable(rty_Lykyhatkk1, localDW, localP);\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S115>/MeasurementUpdate' */\r\n}\r\n\r\n/*\r\n * System initialize for enable system:\r\n *    '<S122>/Enabled Subsystem'\r\n *    '<S178>/Enabled Subsystem'\r\n */\r\nvoid stateEstimator_EnabledSubsystem_Init(real32_T rty_deltax[2],\r\n  P_EnabledSubsystem_stateEstimator_T *localP)\r\n{\r\n  /* SystemInitialize for Outport: '<S148>/deltax' */\r\n  rty_deltax[0] = localP->deltax_Y0;\r\n  rty_deltax[1] = localP->deltax_Y0;\r\n}\r\n\r\n/*\r\n * Disable for enable system:\r\n *    '<S122>/Enabled Subsystem'\r\n *    '<S178>/Enabled Subsystem'\r\n */\r\nvoid stateEstimator_EnabledSubsystem_Disable(real32_T rty_deltax[2],\r\n  DW_EnabledSubsystem_stateEstimator_T *localDW,\r\n  P_EnabledSubsystem_stateEstimator_T *localP)\r\n{\r\n  /* Outputs for Enabled SubSystem: '<S122>/Enabled Subsystem' incorporates:\r\n   *  EnablePort: '<S148>/Enable'\r\n   */\r\n  /* Disable for Outport: '<S148>/deltax' */\r\n  rty_deltax[0] = localP->deltax_Y0;\r\n  rty_deltax[1] = localP->deltax_Y0;\r\n\r\n  /* End of Outputs for SubSystem: '<S122>/Enabled Subsystem' */\r\n  localDW->EnabledSubsystem_MODE = false;\r\n}\r\n\r\n/*\r\n * Output and update for enable system:\r\n *    '<S122>/Enabled Subsystem'\r\n *    '<S178>/Enabled Subsystem'\r\n */\r\nvoid stateEstimator_EnabledSubsystem(boolean_T rtu_Enable, const real32_T\r\n  rtu_Mk[4], const real32_T rtu_Ck[4], const real32_T rtu_yk[2], const real32_T\r\n  rtu_xhatkk1[2], real32_T rty_deltax[2], DW_EnabledSubsystem_stateEstimator_T\r\n  *localDW, P_EnabledSubsystem_stateEstimator_T *localP)\r\n{\r\n  real32_T rtu_yk_idx_0;\r\n  real32_T rtu_yk_idx_1;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S122>/Enabled Subsystem' incorporates:\r\n   *  EnablePort: '<S148>/Enable'\r\n   */\r\n  if (rtu_Enable) {\r\n    localDW->EnabledSubsystem_MODE = true;\r\n\r\n    /* Sum: '<S148>/Add1' incorporates:\r\n     *  Product: '<S148>/Product'\r\n     */\r\n    rtu_yk_idx_0 = rtu_yk[0] - (rtu_Ck[0] * rtu_xhatkk1[0] + rtu_xhatkk1[1] *\r\n      rtu_Ck[2]);\r\n    rtu_yk_idx_1 = rtu_yk[1] - (rtu_xhatkk1[0] * rtu_Ck[1] + rtu_xhatkk1[1] *\r\n      rtu_Ck[3]);\r\n\r\n    /* Product: '<S148>/Product2' */\r\n    rty_deltax[0] = 0.0F;\r\n    rty_deltax[0] += rtu_Mk[0] * rtu_yk_idx_0;\r\n    rty_deltax[0] += rtu_Mk[2] * rtu_yk_idx_1;\r\n    rty_deltax[1] = 0.0F;\r\n    rty_deltax[1] += rtu_Mk[1] * rtu_yk_idx_0;\r\n    rty_deltax[1] += rtu_Mk[3] * rtu_yk_idx_1;\r\n  } else if (localDW->EnabledSubsystem_MODE) {\r\n    stateEstimator_EnabledSubsystem_Disable(rty_deltax, localDW, localP);\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S122>/Enabled Subsystem' */\r\n}\r\n\r\n/* System initialize for referenced model: 'stateEstimator' */\r\nvoid stateEstimator_Init(void)\r\n{\r\n  int32_T i;\r\n\r\n  /* InitializeConditions for Memory: '<S2>/Memory' incorporates:\r\n   *  Gain: '<S2>/gyro_sensitivity'\r\n   */\r\n  stateEstimator_DW.Memory_PreviousInput[0] =\r\n    stateEstimator_P_g.Memory_InitialCondition[0];\r\n  stateEstimator_DW.Memory_PreviousInput[1] =\r\n    stateEstimator_P_g.Memory_InitialCondition[1];\r\n  stateEstimator_DW.Memory_PreviousInput[2] =\r\n    stateEstimator_P_g.Memory_InitialCondition[2];\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S5>/IIR_IMUgyro_r' */\r\n  for (i = 0; i < 5; i++) {\r\n    stateEstimator_DW.IIR_IMUgyro_r_states[i] =\r\n      stateEstimator_P_g.IIR_IMUgyro_r_InitialStates;\r\n  }\r\n\r\n  /* End of InitializeConditions for DiscreteFilter: '<S5>/IIR_IMUgyro_r' */\r\n\r\n  /* InitializeConditions for DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n  for (i = 0; i < 15; i++) {\r\n    stateEstimator_DW.FIR_IMUaccel_states[i] =\r\n      stateEstimator_P_g.FIR_IMUaccel_InitialStates;\r\n  }\r\n\r\n  /* End of InitializeConditions for DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n\r\n  /* InitializeConditions for Delay: '<S78>/MemoryX' */\r\n  stateEstimator_DW.icLoad = true;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S77>/IIRgyroz' */\r\n  for (i = 0; i < 10; i++) {\r\n    stateEstimator_DW.IIRgyroz_states[i] =\r\n      stateEstimator_P_g.IIRgyroz_InitialStates;\r\n  }\r\n\r\n  /* End of InitializeConditions for DiscreteFilter: '<S77>/IIRgyroz' */\r\n\r\n  /* InitializeConditions for UnitDelay: '<S84>/UD' incorporates:\r\n   *  Sum: '<S84>/Diff'\r\n   *\r\n   * Block description for '<S84>/UD':\r\n   *\r\n   *  Store in Global RAM\r\n   *\r\n   * Block description for '<S84>/Diff':\r\n   *\r\n   *  Add in CPU\r\n   */\r\n  stateEstimator_DW.UD_DSTATE[0] =\r\n    stateEstimator_P_g.DiscreteDerivative_ICPrevScaledInput;\r\n\r\n  /* InitializeConditions for Delay: '<S74>/Delay' */\r\n  stateEstimator_DW.Delay_DSTATE[0] = stateEstimator_P_g.Delay_InitialCondition;\r\n\r\n  /* InitializeConditions for UnitDelay: '<S84>/UD' incorporates:\r\n   *  Sum: '<S84>/Diff'\r\n   *\r\n   * Block description for '<S84>/UD':\r\n   *\r\n   *  Store in Global RAM\r\n   *\r\n   * Block description for '<S84>/Diff':\r\n   *\r\n   *  Add in CPU\r\n   */\r\n  stateEstimator_DW.UD_DSTATE[1] =\r\n    stateEstimator_P_g.DiscreteDerivative_ICPrevScaledInput;\r\n\r\n  /* InitializeConditions for Delay: '<S74>/Delay' */\r\n  stateEstimator_DW.Delay_DSTATE[1] = stateEstimator_P_g.Delay_InitialCondition;\r\n\r\n  /* InitializeConditions for Delay: '<S3>/Delay2' */\r\n  stateEstimator_DW.Delay2_DSTATE = stateEstimator_P_g.Delay2_InitialCondition;\r\n\r\n  /* InitializeConditions for Delay: '<S14>/MemoryX' */\r\n  stateEstimator_DW.icLoad_p = true;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_states[0] =\r\n    stateEstimator_P_g.soonarFilter_IIR_InitialStates;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S15>/pressureFilter_IIR' */\r\n  stateEstimator_DW.pressureFilter_IIR_states[0] =\r\n    stateEstimator_P_g.pressureFilter_IIR_InitialStates;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_states[1] =\r\n    stateEstimator_P_g.soonarFilter_IIR_InitialStates;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S15>/pressureFilter_IIR' */\r\n  stateEstimator_DW.pressureFilter_IIR_states[1] =\r\n    stateEstimator_P_g.pressureFilter_IIR_InitialStates;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_states[2] =\r\n    stateEstimator_P_g.soonarFilter_IIR_InitialStates;\r\n\r\n  /* InitializeConditions for DiscreteFilter: '<S15>/pressureFilter_IIR' */\r\n  stateEstimator_DW.pressureFilter_IIR_states[2] =\r\n    stateEstimator_P_g.pressureFilter_IIR_InitialStates;\r\n\r\n  /* InitializeConditions for Delay: '<S149>/MemoryX' */\r\n  stateEstimator_DW.icLoad_g = true;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S75>/Integrator' */\r\n  stateEstimator_DW.Integrator_PrevResetState = 2;\r\n\r\n  /* InitializeConditions for Delay: '<S1>/Delay' */\r\n  stateEstimator_DW.Delay_DSTATE_p[0] =\r\n    stateEstimator_P_g.Delay_InitialCondition_b;\r\n\r\n  /* InitializeConditions for Delay: '<S75>/Delay' */\r\n  stateEstimator_DW.Delay_DSTATE_l[0] =\r\n    stateEstimator_P_g.Delay_InitialCondition_n;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S75>/Integrator' */\r\n  stateEstimator_DW.Integrator_DSTATE[0] = stateEstimator_P_g.Integrator_IC;\r\n\r\n  /* SystemInitialize for Merge: '<S2>/Merge' */\r\n  stateEstimator_B.Merge[0] = stateEstimator_P_g.Merge_InitialOutput;\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S42>/Enabled Subsystem' */\r\n  /* SystemInitialize for Product: '<S68>/Product2' incorporates:\r\n   *  Outport: '<S68>/deltax'\r\n   */\r\n  stateEstimator_B.Product2[0] = stateEstimator_P_g.deltax_Y0;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S42>/Enabled Subsystem' */\r\n\r\n  /* InitializeConditions for Delay: '<S1>/Delay' */\r\n  stateEstimator_DW.Delay_DSTATE_p[1] =\r\n    stateEstimator_P_g.Delay_InitialCondition_b;\r\n\r\n  /* InitializeConditions for Delay: '<S75>/Delay' */\r\n  stateEstimator_DW.Delay_DSTATE_l[1] =\r\n    stateEstimator_P_g.Delay_InitialCondition_n;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S75>/Integrator' */\r\n  stateEstimator_DW.Integrator_DSTATE[1] = stateEstimator_P_g.Integrator_IC;\r\n\r\n  /* SystemInitialize for Merge: '<S2>/Merge' */\r\n  stateEstimator_B.Merge[1] = stateEstimator_P_g.Merge_InitialOutput;\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S42>/Enabled Subsystem' */\r\n  /* SystemInitialize for Product: '<S68>/Product2' incorporates:\r\n   *  Outport: '<S68>/deltax'\r\n   */\r\n  stateEstimator_B.Product2[1] = stateEstimator_P_g.deltax_Y0;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S42>/Enabled Subsystem' */\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S122>/Enabled Subsystem' */\r\n  stateEstimator_EnabledSubsystem_Init(stateEstimator_B.Product2_k,\r\n    &stateEstimator_P_g.EnabledSubsystem_f);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S122>/Enabled Subsystem' */\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S115>/MeasurementUpdate' */\r\n  stateEstimator_MeasurementUpdate_Init(stateEstimator_B.Product3_m,\r\n    &stateEstimator_P_g.MeasurementUpdate_e);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S115>/MeasurementUpdate' */\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S171>/MeasurementUpdate' */\r\n  stateEstimator_MeasurementUpdate_Init(stateEstimator_B.Product3_j,\r\n    &stateEstimator_P_g.MeasurementUpdate_b);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S171>/MeasurementUpdate' */\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S178>/Enabled Subsystem' */\r\n  stateEstimator_EnabledSubsystem_Init(stateEstimator_B.Product2_e,\r\n    &stateEstimator_P_g.EnabledSubsystem_m);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S178>/Enabled Subsystem' */\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S36>/MeasurementUpdate' */\r\n  /* SystemInitialize for Product: '<S66>/Product3' incorporates:\r\n   *  Outport: '<S66>/L*(y[k]-yhat[k|k-1])'\r\n   */\r\n  stateEstimator_B.Product3[0] = stateEstimator_P_g.Lykyhatkk1_Y0;\r\n  stateEstimator_B.Product3[1] = stateEstimator_P_g.Lykyhatkk1_Y0;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S36>/MeasurementUpdate' */\r\n}\r\n\r\n/* Disable for referenced model: 'stateEstimator' */\r\nvoid stateEstimator_Disable(void)\r\n{\r\n  /* Disable for Enabled SubSystem: '<S42>/Enabled Subsystem' */\r\n  if (stateEstimator_DW.EnabledSubsystem_MODE) {\r\n    /* Disable for Product: '<S68>/Product2' incorporates:\r\n     *  Outport: '<S68>/deltax'\r\n     */\r\n    stateEstimator_B.Product2[0] = stateEstimator_P_g.deltax_Y0;\r\n    stateEstimator_B.Product2[1] = stateEstimator_P_g.deltax_Y0;\r\n    stateEstimator_DW.EnabledSubsystem_MODE = false;\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S42>/Enabled Subsystem' */\r\n\r\n  /* Disable for Enabled SubSystem: '<S122>/Enabled Subsystem' */\r\n  if (stateEstimator_DW.EnabledSubsystem_f.EnabledSubsystem_MODE) {\r\n    stateEstimator_EnabledSubsystem_Disable(stateEstimator_B.Product2_k,\r\n      &stateEstimator_DW.EnabledSubsystem_f,\r\n      &stateEstimator_P_g.EnabledSubsystem_f);\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S122>/Enabled Subsystem' */\r\n\r\n  /* Disable for Enabled SubSystem: '<S115>/MeasurementUpdate' */\r\n  if (stateEstimator_DW.MeasurementUpdate_e.MeasurementUpdate_MODE) {\r\n    stateEstimator_MeasurementUpdate_Disable(stateEstimator_B.Product3_m,\r\n      &stateEstimator_DW.MeasurementUpdate_e,\r\n      &stateEstimator_P_g.MeasurementUpdate_e);\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S115>/MeasurementUpdate' */\r\n\r\n  /* Disable for Enabled SubSystem: '<S171>/MeasurementUpdate' */\r\n  if (stateEstimator_DW.MeasurementUpdate_b.MeasurementUpdate_MODE) {\r\n    stateEstimator_MeasurementUpdate_Disable(stateEstimator_B.Product3_j,\r\n      &stateEstimator_DW.MeasurementUpdate_b,\r\n      &stateEstimator_P_g.MeasurementUpdate_b);\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S171>/MeasurementUpdate' */\r\n\r\n  /* Disable for Enabled SubSystem: '<S178>/Enabled Subsystem' */\r\n  if (stateEstimator_DW.EnabledSubsystem_m.EnabledSubsystem_MODE) {\r\n    stateEstimator_EnabledSubsystem_Disable(stateEstimator_B.Product2_e,\r\n      &stateEstimator_DW.EnabledSubsystem_m,\r\n      &stateEstimator_P_g.EnabledSubsystem_m);\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S178>/Enabled Subsystem' */\r\n\r\n  /* Disable for Enabled SubSystem: '<S36>/MeasurementUpdate' */\r\n  if (stateEstimator_DW.MeasurementUpdate_MODE) {\r\n    /* Disable for Product: '<S66>/Product3' incorporates:\r\n     *  Outport: '<S66>/L*(y[k]-yhat[k|k-1])'\r\n     */\r\n    stateEstimator_B.Product3[0] = stateEstimator_P_g.Lykyhatkk1_Y0;\r\n    stateEstimator_B.Product3[1] = stateEstimator_P_g.Lykyhatkk1_Y0;\r\n    stateEstimator_DW.MeasurementUpdate_MODE = false;\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S36>/MeasurementUpdate' */\r\n}\r\n\r\n/* Output and update for referenced model: 'stateEstimator' */\r\nvoid stateEstimator_run(const boolean_T arg_controlModePosVSOrient_flagin, const\r\n  sensordata_t *arg_sensordata_datin, const real32_T arg_usePosVIS_flagin, const\r\n  real32_T arg_opticalFlow_datin[3], const real32_T arg_posVIS_datin[4],\r\n  statesEstim_t *arg_states_estimout, const real32_T\r\n  arg_sensorCalibration_datin[8])\r\n{\r\n  /* local block i/o variables */\r\n  boolean_T rtb_DataTypeConversionEnable_i;\r\n  boolean_T rtb_DataTypeConversionEnable_h;\r\n  real32_T rtb_DataTypeConversion1_idx_0;\r\n  real32_T rtb_VectorConcatenate_tmp;\r\n  real32_T rtb_VectorConcatenate_tmp_0;\r\n  real32_T rtb_VectorConcatenate_tmp_1;\r\n  real32_T rtb_VectorConcatenate_tmp_2;\r\n  real32_T rtb_VectorConcatenate_tmp_3;\r\n  real32_T rtb_VectorConcatenate_tmp_4;\r\n  real32_T rtb_VectorConcatenate_tmp_tmp;\r\n  real32_T rtb_VectorConcatenate_tmp_tmp_0;\r\n  real32_T u0;\r\n  real32_T y;\r\n  boolean_T rtb_Compare_i;\r\n  boolean_T rtb_LogicalOperator_cg;\r\n\r\n  /* SignalConversion generated from: '<S13>/Vector Concatenate' incorporates:\r\n   *  Constant: '<S12>/Constant'\r\n   */\r\n  stateEstimator_B.VectorConcatenate[0] = stateEstimator_P_g.Constant_Value_i;\r\n\r\n  /* SignalConversion generated from: '<S13>/Vector Concatenate' incorporates:\r\n   *  Constant: '<S12>/Constant'\r\n   */\r\n  stateEstimator_B.VectorConcatenate[1] = stateEstimator_P_g.Constant_Value_i;\r\n\r\n  /* SignalConversion generated from: '<S12>/Trigonometric Function' incorporates:\r\n   *  Memory: '<S2>/Memory'\r\n   */\r\n  stateEstimator_B.rtb_sincos_o2_idx_1 = stateEstimator_DW.Memory_PreviousInput\r\n    [1];\r\n  stateEstimator_B.rtb_sincos_o2_idx_2 = stateEstimator_DW.Memory_PreviousInput\r\n    [0];\r\n\r\n  /* Trigonometry: '<S12>/Trigonometric Function' incorporates:\r\n   *  Gain: '<S2>/gyro_sensitivity'\r\n   *  Memory: '<S2>/Memory'\r\n   *  SignalConversion generated from: '<S12>/Trigonometric Function'\r\n   */\r\n  stateEstimator_DW.Memory_PreviousInput[0] = (real32_T)sin\r\n    (stateEstimator_DW.Memory_PreviousInput[2]);\r\n  rtb_DataTypeConversion1_idx_0 = (real32_T)cos\r\n    (stateEstimator_DW.Memory_PreviousInput[2]);\r\n  stateEstimator_DW.Memory_PreviousInput[1] = (real32_T)sin\r\n    (stateEstimator_DW.Memory_PreviousInput[1]);\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)cos\r\n    (stateEstimator_B.rtb_sincos_o2_idx_1);\r\n\r\n  /* SignalConversion generated from: '<S13>/Vector Concatenate' */\r\n  stateEstimator_B.VectorConcatenate[2] =\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n  /* SignalConversion generated from: '<S13>/Vector Concatenate' */\r\n  stateEstimator_B.VectorConcatenate[3] =\r\n    stateEstimator_DW.Memory_PreviousInput[0];\r\n\r\n  /* Product: '<S12>/Product1' */\r\n  stateEstimator_B.VectorConcatenate[4] = rtb_DataTypeConversion1_idx_0 *\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n  /* Product: '<S12>/Product3' */\r\n  stateEstimator_B.VectorConcatenate[5] =\r\n    stateEstimator_DW.Memory_PreviousInput[0] *\r\n    stateEstimator_DW.Memory_PreviousInput[1];\r\n\r\n  /* SignalConversion generated from: '<S13>/Vector Concatenate' */\r\n  stateEstimator_B.VectorConcatenate[6] = rtb_DataTypeConversion1_idx_0;\r\n\r\n  /* Product: '<S12>/Product2' incorporates:\r\n   *  Gain: '<S12>/Gain'\r\n   */\r\n  stateEstimator_B.VectorConcatenate[7] = stateEstimator_P_g.Gain_Gain_c *\r\n    stateEstimator_DW.Memory_PreviousInput[0] *\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n  /* Product: '<S12>/Product4' */\r\n  stateEstimator_B.VectorConcatenate[8] = rtb_DataTypeConversion1_idx_0 *\r\n    stateEstimator_DW.Memory_PreviousInput[1];\r\n\r\n  /* Product: '<S12>/Divide' incorporates:\r\n   *  Reshape: '<S13>/Reshape (9) to [3x3] column-major'\r\n   *  Reshape: '<S73>/Reshape (9) to [3x3] column-major'\r\n   */\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 9; stateEstimator_B.i++) {\r\n    stateEstimator_B.VectorConcatenate[stateEstimator_B.i] /=\r\n      stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n  }\r\n\r\n  /* End of Product: '<S12>/Divide' */\r\n\r\n  /* Bias: '<S5>/Bias' incorporates:\r\n   *  DataTypeConversion: '<S5>/Data Type Conversion'\r\n   */\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 6; stateEstimator_B.i++) {\r\n    stateEstimator_B.Sum1[stateEstimator_B.i] =\r\n      arg_sensorCalibration_datin[stateEstimator_B.i] +\r\n      stateEstimator_P_g.Bias_Bias[stateEstimator_B.i];\r\n  }\r\n\r\n  /* End of Bias: '<S5>/Bias' */\r\n\r\n  /* Gain: '<S5>/inverseIMU_gain' incorporates:\r\n   *  Sum: '<S5>/Sum1'\r\n   */\r\n  stateEstimator_B.inverseIMU_gain[0] = (arg_sensordata_datin->ddx -\r\n    stateEstimator_B.Sum1[0]) * stateEstimator_P_g.inverseIMU_gain_Gain[0];\r\n  stateEstimator_B.inverseIMU_gain[1] = (arg_sensordata_datin->ddy -\r\n    stateEstimator_B.Sum1[1]) * stateEstimator_P_g.inverseIMU_gain_Gain[1];\r\n  stateEstimator_B.inverseIMU_gain[2] = (arg_sensordata_datin->ddz -\r\n    stateEstimator_B.Sum1[2]) * stateEstimator_P_g.inverseIMU_gain_Gain[2];\r\n  stateEstimator_B.inverseIMU_gain[3] = (arg_sensordata_datin->p -\r\n    stateEstimator_B.Sum1[3]) * stateEstimator_P_g.inverseIMU_gain_Gain[3];\r\n  stateEstimator_B.inverseIMU_gain[4] = (arg_sensordata_datin->q -\r\n    stateEstimator_B.Sum1[4]) * stateEstimator_P_g.inverseIMU_gain_Gain[4];\r\n  stateEstimator_B.inverseIMU_gain[5] = (arg_sensordata_datin->r -\r\n    stateEstimator_B.Sum1[5]) * stateEstimator_P_g.inverseIMU_gain_Gain[5];\r\n\r\n  /* DiscreteFilter: '<S5>/IIR_IMUgyro_r' */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 =\r\n    stateEstimator_B.inverseIMU_gain[5];\r\n  stateEstimator_B.denIdx = 1;\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 5; stateEstimator_B.i++) {\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1 -=\r\n      stateEstimator_P_g.IIR_IMUgyro_r_DenCoef[stateEstimator_B.denIdx] *\r\n      stateEstimator_DW.IIR_IMUgyro_r_states[stateEstimator_B.i];\r\n    stateEstimator_B.denIdx++;\r\n  }\r\n\r\n  stateEstimator_DW.IIR_IMUgyro_r_tmp =\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1 /\r\n    stateEstimator_P_g.IIR_IMUgyro_r_DenCoef[0];\r\n  stateEstimator_B.numAccum = stateEstimator_P_g.IIR_IMUgyro_r_NumCoef[0] *\r\n    stateEstimator_DW.IIR_IMUgyro_r_tmp;\r\n  stateEstimator_B.denIdx = 1;\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 5; stateEstimator_B.i++) {\r\n    stateEstimator_B.numAccum +=\r\n      stateEstimator_P_g.IIR_IMUgyro_r_NumCoef[stateEstimator_B.denIdx] *\r\n      stateEstimator_DW.IIR_IMUgyro_r_states[stateEstimator_B.i];\r\n    stateEstimator_B.denIdx++;\r\n  }\r\n\r\n  /* SignalConversion generated from: '<S2>/Product' */\r\n  rtb_DataTypeConversion1_idx_0 = stateEstimator_B.inverseIMU_gain[3];\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 =\r\n    stateEstimator_B.inverseIMU_gain[4];\r\n\r\n  /* Product: '<S2>/Product' incorporates:\r\n   *  DiscreteFilter: '<S5>/IIR_IMUgyro_r'\r\n   *  Reshape: '<S73>/Reshape (9) to [3x3] column-major'\r\n   */\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 3; stateEstimator_B.i++) {\r\n    stateEstimator_B.sincos_o1[stateEstimator_B.i] =\r\n      (stateEstimator_B.VectorConcatenate[stateEstimator_B.i + 3] *\r\n       stateEstimator_B.rtb_DataTypeConversion1_idx_1 +\r\n       stateEstimator_B.VectorConcatenate[stateEstimator_B.i] *\r\n       rtb_DataTypeConversion1_idx_0) +\r\n      stateEstimator_B.VectorConcatenate[stateEstimator_B.i + 6] *\r\n      stateEstimator_B.numAccum;\r\n  }\r\n\r\n  /* End of Product: '<S2>/Product' */\r\n\r\n  /* DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n  rtb_DataTypeConversion1_idx_0 = stateEstimator_B.inverseIMU_gain[0] *\r\n    stateEstimator_P_g.FIR_IMUaccel_Coefficients[0];\r\n  stateEstimator_B.cff = 1;\r\n  stateEstimator_B.i = stateEstimator_DW.FIR_IMUaccel_circBuf;\r\n  while (stateEstimator_B.i < 5) {\r\n    rtb_DataTypeConversion1_idx_0 +=\r\n      stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_B.i] *\r\n      stateEstimator_P_g.FIR_IMUaccel_Coefficients[stateEstimator_B.cff];\r\n    stateEstimator_B.cff++;\r\n    stateEstimator_B.i++;\r\n  }\r\n\r\n  stateEstimator_B.i = 0;\r\n  while (stateEstimator_B.i < stateEstimator_DW.FIR_IMUaccel_circBuf) {\r\n    rtb_DataTypeConversion1_idx_0 +=\r\n      stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_B.i] *\r\n      stateEstimator_P_g.FIR_IMUaccel_Coefficients[stateEstimator_B.cff];\r\n    stateEstimator_B.cff++;\r\n    stateEstimator_B.i++;\r\n  }\r\n\r\n  stateEstimator_B.FIR_IMUaccel[0] = rtb_DataTypeConversion1_idx_0;\r\n\r\n  /* Math: '<S2>/Math Function' incorporates:\r\n   *  Constant: '<S2>/Constant'\r\n   *  DiscreteFir: '<S5>/FIR_IMUaccel'\r\n   */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)floor\r\n    (stateEstimator_P_g.Constant_Value_n);\r\n  if ((rtb_DataTypeConversion1_idx_0 < 0.0F) &&\r\n      (stateEstimator_P_g.Constant_Value_n >\r\n       stateEstimator_B.rtb_DataTypeConversion1_idx_1)) {\r\n    y = -rt_powf_snf(-rtb_DataTypeConversion1_idx_0,\r\n                     stateEstimator_P_g.Constant_Value_n);\r\n  } else {\r\n    y = rt_powf_snf(rtb_DataTypeConversion1_idx_0,\r\n                    stateEstimator_P_g.Constant_Value_n);\r\n  }\r\n\r\n  /* DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n  rtb_DataTypeConversion1_idx_0 = stateEstimator_P_g.FIR_IMUaccel_Coefficients[0]\r\n    * stateEstimator_B.inverseIMU_gain[1];\r\n  stateEstimator_B.cff = 1;\r\n  stateEstimator_B.i = stateEstimator_DW.FIR_IMUaccel_circBuf;\r\n  while (stateEstimator_B.i < 5) {\r\n    rtb_DataTypeConversion1_idx_0 +=\r\n      stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_B.i + 5] *\r\n      stateEstimator_P_g.FIR_IMUaccel_Coefficients[stateEstimator_B.cff];\r\n    stateEstimator_B.cff++;\r\n    stateEstimator_B.i++;\r\n  }\r\n\r\n  stateEstimator_B.i = 0;\r\n  while (stateEstimator_B.i < stateEstimator_DW.FIR_IMUaccel_circBuf) {\r\n    rtb_DataTypeConversion1_idx_0 +=\r\n      stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_B.i + 5] *\r\n      stateEstimator_P_g.FIR_IMUaccel_Coefficients[stateEstimator_B.cff];\r\n    stateEstimator_B.cff++;\r\n    stateEstimator_B.i++;\r\n  }\r\n\r\n  stateEstimator_B.FIR_IMUaccel[1] = rtb_DataTypeConversion1_idx_0;\r\n\r\n  /* DataTypeConversion: '<S2>/Data Type Conversion2' incorporates:\r\n   *  DiscreteFir: '<S5>/FIR_IMUaccel'\r\n   */\r\n  u0 = rtb_DataTypeConversion1_idx_0;\r\n\r\n  /* DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n  rtb_DataTypeConversion1_idx_0 = stateEstimator_P_g.FIR_IMUaccel_Coefficients[0]\r\n    * stateEstimator_B.inverseIMU_gain[2];\r\n  stateEstimator_B.cff = 1;\r\n  stateEstimator_B.i = stateEstimator_DW.FIR_IMUaccel_circBuf;\r\n  while (stateEstimator_B.i < 5) {\r\n    rtb_DataTypeConversion1_idx_0 +=\r\n      stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_B.i + 10] *\r\n      stateEstimator_P_g.FIR_IMUaccel_Coefficients[stateEstimator_B.cff];\r\n    stateEstimator_B.cff++;\r\n    stateEstimator_B.i++;\r\n  }\r\n\r\n  stateEstimator_B.i = 0;\r\n  while (stateEstimator_B.i < stateEstimator_DW.FIR_IMUaccel_circBuf) {\r\n    rtb_DataTypeConversion1_idx_0 +=\r\n      stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_B.i + 10] *\r\n      stateEstimator_P_g.FIR_IMUaccel_Coefficients[stateEstimator_B.cff];\r\n    stateEstimator_B.cff++;\r\n    stateEstimator_B.i++;\r\n  }\r\n\r\n  stateEstimator_B.FIR_IMUaccel[2] = rtb_DataTypeConversion1_idx_0;\r\n\r\n  /* Math: '<S2>/Math Function' incorporates:\r\n   *  Constant: '<S2>/Constant'\r\n   *  DiscreteFir: '<S5>/FIR_IMUaccel'\r\n   */\r\n  if ((u0 < 0.0F) && (stateEstimator_P_g.Constant_Value_n >\r\n                      stateEstimator_B.rtb_DataTypeConversion1_idx_1)) {\r\n    u0 = -rt_powf_snf(-u0, stateEstimator_P_g.Constant_Value_n);\r\n  } else {\r\n    u0 = rt_powf_snf(u0, stateEstimator_P_g.Constant_Value_n);\r\n  }\r\n\r\n  if ((rtb_DataTypeConversion1_idx_0 < 0.0F) &&\r\n      (stateEstimator_P_g.Constant_Value_n >\r\n       stateEstimator_B.rtb_DataTypeConversion1_idx_1)) {\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1 = -rt_powf_snf\r\n      (-rtb_DataTypeConversion1_idx_0, stateEstimator_P_g.Constant_Value_n);\r\n  } else {\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1 = rt_powf_snf\r\n      (rtb_DataTypeConversion1_idx_0, stateEstimator_P_g.Constant_Value_n);\r\n  }\r\n\r\n  /* Sqrt: '<S2>/Sqrt' incorporates:\r\n   *  Math: '<S2>/Math Function'\r\n   *  Sum: '<S2>/Sum of Elements'\r\n   */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)sqrt((y + u0) +\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1);\r\n\r\n  /* If: '<S2>/If' incorporates:\r\n   *  Constant: '<S6>/Constant'\r\n   *  Constant: '<S7>/Constant'\r\n   *  Logic: '<S2>/Logical Operator'\r\n   *  RelationalOperator: '<S6>/Compare'\r\n   *  RelationalOperator: '<S7>/Compare'\r\n   */\r\n  if ((stateEstimator_B.rtb_DataTypeConversion1_idx_1 >\r\n       stateEstimator_P_g.CompareToConstant_const) &&\r\n      (stateEstimator_B.rtb_DataTypeConversion1_idx_1 <\r\n       stateEstimator_P_g.CompareToConstant1_const)) {\r\n    /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem' incorporates:\r\n     *  ActionPort: '<S8>/Action Port'\r\n     */\r\n    /* Sum: '<S8>/Sum' incorporates:\r\n     *  DiscreteFir: '<S5>/FIR_IMUaccel'\r\n     *  Gain: '<S2>/gyro_sensitivity'\r\n     *  Gain: '<S8>/Gain'\r\n     *  Gain: '<S8>/Gain1'\r\n     *  Memory: '<S2>/Memory'\r\n     *  Merge: '<S2>/Merge'\r\n     *  Product: '<S8>/Divide'\r\n     *  SignalConversion generated from: '<S12>/Trigonometric Function'\r\n     *  Sum: '<S2>/Sum'\r\n     *  Trigonometry: '<S8>/Trigonometric Function'\r\n     */\r\n    stateEstimator_B.Merge[1] = (stateEstimator_P_g.gyro_sensitivity_Gain *\r\n      stateEstimator_B.sincos_o1[2] + stateEstimator_DW.Memory_PreviousInput[2])\r\n      * stateEstimator_P_g.Gain_Gain + (real32_T)atan\r\n      (stateEstimator_B.FIR_IMUaccel[1] / rtb_DataTypeConversion1_idx_0) *\r\n      stateEstimator_P_g.Gain1_Gain;\r\n\r\n    /* Gain: '<S8>/Gain2' */\r\n    u0 = stateEstimator_P_g.Gain2_Gain * stateEstimator_B.FIR_IMUaccel[0];\r\n\r\n    /* Trigonometry: '<S8>/Trigonometric Function1' */\r\n    if (u0 > 1.0F) {\r\n      u0 = 1.0F;\r\n    } else if (u0 < -1.0F) {\r\n      u0 = -1.0F;\r\n    }\r\n\r\n    /* Sum: '<S8>/Sum1' incorporates:\r\n     *  Gain: '<S2>/gyro_sensitivity'\r\n     *  Gain: '<S8>/Gain3'\r\n     *  Gain: '<S8>/Gain4'\r\n     *  Merge: '<S2>/Merge'\r\n     *  Sum: '<S2>/Sum'\r\n     *  Trigonometry: '<S8>/Trigonometric Function1'\r\n     */\r\n    stateEstimator_B.Merge[0] = (stateEstimator_P_g.gyro_sensitivity_Gain *\r\n      stateEstimator_B.sincos_o1[1] + stateEstimator_B.rtb_sincos_o2_idx_1) *\r\n      stateEstimator_P_g.Gain4_Gain + stateEstimator_P_g.Gain3_Gain * (real32_T)\r\n      asin(u0);\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/If Action Subsystem' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem2' incorporates:\r\n     *  ActionPort: '<S10>/Action Port'\r\n     */\r\n    /* Merge: '<S2>/Merge' incorporates:\r\n     *  Gain: '<S2>/gyro_sensitivity'\r\n     *  Inport: '<S10>/prin'\r\n     *  Memory: '<S2>/Memory'\r\n     *  SignalConversion generated from: '<S12>/Trigonometric Function'\r\n     *  Sum: '<S2>/Sum'\r\n     */\r\n    stateEstimator_B.Merge[0] = stateEstimator_P_g.gyro_sensitivity_Gain *\r\n      stateEstimator_B.sincos_o1[1] + stateEstimator_B.rtb_sincos_o2_idx_1;\r\n    stateEstimator_B.Merge[1] = stateEstimator_P_g.gyro_sensitivity_Gain *\r\n      stateEstimator_B.sincos_o1[2] + stateEstimator_DW.Memory_PreviousInput[2];\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/If Action Subsystem2' */\r\n  }\r\n\r\n  /* End of If: '<S2>/If' */\r\n\r\n  /* If: '<S2>/If1' incorporates:\r\n   *  Constant: '<S210>/Constant'\r\n   *  Logic: '<S5>/Logical Operator'\r\n   *  RelationalOperator: '<S210>/Compare'\r\n   */\r\n  if ((arg_usePosVIS_flagin != 0.0F) && (arg_posVIS_datin[0] !=\r\n       stateEstimator_P_g.Checkifvalidvisualpositionestimateavailable_const)) {\r\n    /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S9>/Action Port'\r\n     */\r\n    /* DataTypeConversion: '<S2>/Data Type Conversion3' incorporates:\r\n     *  Gain: '<S2>/gyro_sensitivity'\r\n     *  Gain: '<S9>/Gain'\r\n     *  Gain: '<S9>/Gain1'\r\n     *  Sum: '<S2>/Sum'\r\n     *  Sum: '<S9>/Sum'\r\n     */\r\n    stateEstimator_DW.Memory_PreviousInput[0] =\r\n      (stateEstimator_P_g.gyro_sensitivity_Gain * stateEstimator_B.sincos_o1[0]\r\n       + stateEstimator_B.rtb_sincos_o2_idx_2) * stateEstimator_P_g.Gain_Gain_i\r\n      + stateEstimator_P_g.Gain1_Gain_k * arg_posVIS_datin[3];\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/If Action Subsystem1' */\r\n  } else {\r\n    /* DataTypeConversion: '<S2>/Data Type Conversion3' incorporates:\r\n     *  Gain: '<S2>/gyro_sensitivity'\r\n     *  Sum: '<S2>/Sum'\r\n     */\r\n    stateEstimator_DW.Memory_PreviousInput[0] =\r\n      stateEstimator_P_g.gyro_sensitivity_Gain * stateEstimator_B.sincos_o1[0] +\r\n      stateEstimator_B.rtb_sincos_o2_idx_2;\r\n  }\r\n\r\n  /* End of If: '<S2>/If1' */\r\n\r\n  /* DataTypeConversion: '<S2>/Data Type Conversion3' incorporates:\r\n   *  Gain: '<S2>/gyro_sensitivity'\r\n   */\r\n  stateEstimator_DW.Memory_PreviousInput[1] = stateEstimator_B.Merge[0];\r\n  stateEstimator_DW.Memory_PreviousInput[2] = stateEstimator_B.Merge[1];\r\n\r\n  /* Trigonometry: '<S16>/sincos' incorporates:\r\n   *  Trigonometry: '<S151>/sincos'\r\n   *  Trigonometry: '<S80>/sincos'\r\n   */\r\n  stateEstimator_B.rtb_sincos_o2_idx_0 = (real32_T)sin\r\n    (stateEstimator_DW.Memory_PreviousInput[0]);\r\n  stateEstimator_B.rtb_sincos_o2_idx_1 = (real32_T)cos\r\n    (stateEstimator_DW.Memory_PreviousInput[0]);\r\n  stateEstimator_B.rtb_sincos_o2_idx_2 = (real32_T)sin\r\n    (stateEstimator_DW.Memory_PreviousInput[1]);\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)cos\r\n    (stateEstimator_DW.Memory_PreviousInput[1]);\r\n  y = (real32_T)sin(stateEstimator_DW.Memory_PreviousInput[2]);\r\n  u0 = (real32_T)cos(stateEstimator_DW.Memory_PreviousInput[2]);\r\n\r\n  /* Fcn: '<S16>/Fcn11' incorporates:\r\n   *  Fcn: '<S151>/Fcn11'\r\n   *  Fcn: '<S80>/Fcn11'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  rtb_VectorConcatenate_tmp = stateEstimator_B.rtb_sincos_o2_idx_1 *\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n  stateEstimator_B.VectorConcatenate[0] = rtb_VectorConcatenate_tmp;\r\n\r\n  /* Fcn: '<S16>/Fcn21' incorporates:\r\n   *  Fcn: '<S151>/Fcn21'\r\n   *  Fcn: '<S80>/Fcn21'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  rtb_VectorConcatenate_tmp_tmp = stateEstimator_B.rtb_sincos_o2_idx_2 * y;\r\n  rtb_VectorConcatenate_tmp_0 = stateEstimator_B.rtb_sincos_o2_idx_0 * u0;\r\n  stateEstimator_B.VectorConcatenate[1] = rtb_VectorConcatenate_tmp_tmp *\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 - rtb_VectorConcatenate_tmp_0;\r\n\r\n  /* Fcn: '<S16>/Fcn31' incorporates:\r\n   *  Fcn: '<S151>/Fcn31'\r\n   *  Fcn: '<S80>/Fcn31'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  rtb_VectorConcatenate_tmp_tmp_0 = stateEstimator_B.rtb_sincos_o2_idx_2 * u0;\r\n  rtb_VectorConcatenate_tmp_1 = stateEstimator_B.rtb_sincos_o2_idx_0 * y;\r\n  stateEstimator_B.VectorConcatenate[2] = rtb_VectorConcatenate_tmp_tmp_0 *\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 + rtb_VectorConcatenate_tmp_1;\r\n\r\n  /* Fcn: '<S16>/Fcn12' incorporates:\r\n   *  Fcn: '<S151>/Fcn12'\r\n   *  Fcn: '<S80>/Fcn12'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  rtb_VectorConcatenate_tmp_2 = stateEstimator_B.rtb_sincos_o2_idx_0 *\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n  stateEstimator_B.VectorConcatenate[3] = rtb_VectorConcatenate_tmp_2;\r\n\r\n  /* Fcn: '<S16>/Fcn22' incorporates:\r\n   *  Fcn: '<S151>/Fcn22'\r\n   *  Fcn: '<S16>/Fcn21'\r\n   *  Fcn: '<S80>/Fcn22'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  rtb_VectorConcatenate_tmp_3 = stateEstimator_B.rtb_sincos_o2_idx_1 * u0;\r\n  stateEstimator_B.VectorConcatenate[4] = rtb_VectorConcatenate_tmp_tmp *\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 + rtb_VectorConcatenate_tmp_3;\r\n\r\n  /* Fcn: '<S16>/Fcn32' incorporates:\r\n   *  Fcn: '<S151>/Fcn32'\r\n   *  Fcn: '<S16>/Fcn31'\r\n   *  Fcn: '<S80>/Fcn32'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  rtb_VectorConcatenate_tmp_4 = stateEstimator_B.rtb_sincos_o2_idx_1 * y;\r\n  stateEstimator_B.VectorConcatenate[5] = rtb_VectorConcatenate_tmp_tmp_0 *\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 - rtb_VectorConcatenate_tmp_4;\r\n\r\n  /* Fcn: '<S16>/Fcn13' incorporates:\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  stateEstimator_B.VectorConcatenate[6] = -stateEstimator_B.rtb_sincos_o2_idx_2;\r\n\r\n  /* Fcn: '<S16>/Fcn23' incorporates:\r\n   *  Fcn: '<S151>/Fcn23'\r\n   *  Fcn: '<S80>/Fcn23'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  y *= stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n  stateEstimator_B.VectorConcatenate[7] = y;\r\n\r\n  /* Fcn: '<S16>/Fcn33' incorporates:\r\n   *  Fcn: '<S151>/Fcn33'\r\n   *  Fcn: '<S80>/Fcn33'\r\n   *  Trigonometry: '<S16>/sincos'\r\n   */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 *= u0;\r\n  stateEstimator_B.VectorConcatenate[8] =\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n  /* Fcn: '<S80>/Fcn11' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[0] = rtb_VectorConcatenate_tmp;\r\n\r\n  /* Fcn: '<S80>/Fcn21' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[1] = rtb_VectorConcatenate_tmp_tmp *\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 - rtb_VectorConcatenate_tmp_0;\r\n\r\n  /* Fcn: '<S80>/Fcn31' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[2] = rtb_VectorConcatenate_tmp_tmp_0\r\n    * stateEstimator_B.rtb_sincos_o2_idx_1 + rtb_VectorConcatenate_tmp_1;\r\n\r\n  /* Fcn: '<S80>/Fcn12' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[3] = rtb_VectorConcatenate_tmp_2;\r\n\r\n  /* Fcn: '<S80>/Fcn22' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[4] = rtb_VectorConcatenate_tmp_tmp *\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 + rtb_VectorConcatenate_tmp_3;\r\n\r\n  /* Fcn: '<S80>/Fcn32' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[5] = rtb_VectorConcatenate_tmp_tmp_0\r\n    * stateEstimator_B.rtb_sincos_o2_idx_0 - rtb_VectorConcatenate_tmp_4;\r\n\r\n  /* Fcn: '<S80>/Fcn13' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[6] =\r\n    -stateEstimator_B.rtb_sincos_o2_idx_2;\r\n\r\n  /* Fcn: '<S80>/Fcn23' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[7] = y;\r\n\r\n  /* Fcn: '<S80>/Fcn33' */\r\n  stateEstimator_B.Reshape9to3x3columnmajor[8] =\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n  /* Fcn: '<S151>/Fcn11' */\r\n  stateEstimator_B.MathFunction_b[0] = rtb_VectorConcatenate_tmp;\r\n\r\n  /* Fcn: '<S151>/Fcn21' */\r\n  stateEstimator_B.MathFunction_b[1] = rtb_VectorConcatenate_tmp_tmp *\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 - rtb_VectorConcatenate_tmp_0;\r\n\r\n  /* Fcn: '<S151>/Fcn31' */\r\n  stateEstimator_B.MathFunction_b[2] = rtb_VectorConcatenate_tmp_tmp_0 *\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 + rtb_VectorConcatenate_tmp_1;\r\n\r\n  /* Fcn: '<S151>/Fcn12' */\r\n  stateEstimator_B.MathFunction_b[3] = rtb_VectorConcatenate_tmp_2;\r\n\r\n  /* Fcn: '<S151>/Fcn22' */\r\n  stateEstimator_B.MathFunction_b[4] = rtb_VectorConcatenate_tmp_tmp *\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 + rtb_VectorConcatenate_tmp_3;\r\n\r\n  /* Fcn: '<S151>/Fcn32' */\r\n  stateEstimator_B.MathFunction_b[5] = rtb_VectorConcatenate_tmp_tmp_0 *\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 - rtb_VectorConcatenate_tmp_4;\r\n\r\n  /* Fcn: '<S151>/Fcn13' */\r\n  stateEstimator_B.MathFunction_b[6] = -stateEstimator_B.rtb_sincos_o2_idx_2;\r\n\r\n  /* Fcn: '<S151>/Fcn23' */\r\n  stateEstimator_B.MathFunction_b[7] = y;\r\n\r\n  /* Fcn: '<S151>/Fcn33' */\r\n  stateEstimator_B.MathFunction_b[8] =\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n  /* Math: '<S75>/Math Function' */\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 3; stateEstimator_B.i++) {\r\n    stateEstimator_B.rtb_MathFunction_b_m[3 * stateEstimator_B.i] =\r\n      stateEstimator_B.MathFunction_b[stateEstimator_B.i];\r\n    stateEstimator_B.rtb_MathFunction_b_m[3 * stateEstimator_B.i + 1] =\r\n      stateEstimator_B.MathFunction_b[stateEstimator_B.i + 3];\r\n    stateEstimator_B.rtb_MathFunction_b_m[3 * stateEstimator_B.i + 2] =\r\n      stateEstimator_B.MathFunction_b[stateEstimator_B.i + 6];\r\n  }\r\n\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 9; stateEstimator_B.i++) {\r\n    stateEstimator_B.MathFunction_b[stateEstimator_B.i] =\r\n      stateEstimator_B.rtb_MathFunction_b_m[stateEstimator_B.i];\r\n  }\r\n\r\n  /* End of Math: '<S75>/Math Function' */\r\n\r\n  /* DataTypeConversion: '<S195>/Conversion' incorporates:\r\n   *  Constant: '<S152>/KalmanGainM'\r\n   */\r\n  stateEstimator_B.Conversion_g[0] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value[0];\r\n  stateEstimator_B.Conversion_g[1] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value[1];\r\n  stateEstimator_B.Conversion_g[2] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value[2];\r\n  stateEstimator_B.Conversion_g[3] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value[3];\r\n\r\n  /* DataTypeConversion: '<S139>/Conversion' incorporates:\r\n   *  Constant: '<S96>/KalmanGainM'\r\n   */\r\n  stateEstimator_B.Conversion_p[0] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value_d[0];\r\n  stateEstimator_B.Conversion_p[1] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value_d[1];\r\n  stateEstimator_B.Conversion_p[2] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value_d[2];\r\n  stateEstimator_B.Conversion_p[3] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainM_Value_d[3];\r\n\r\n  /* DataTypeConversion: '<S138>/Conversion' incorporates:\r\n   *  Constant: '<S96>/KalmanGainL'\r\n   */\r\n  stateEstimator_B.Conversion_n4[0] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value[0];\r\n  stateEstimator_B.Conversion_n4[1] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value[1];\r\n  stateEstimator_B.Conversion_n4[2] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value[2];\r\n  stateEstimator_B.Conversion_n4[3] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value[3];\r\n\r\n  /* DataTypeConversion: '<S194>/Conversion' incorporates:\r\n   *  Constant: '<S152>/KalmanGainL'\r\n   */\r\n  stateEstimator_B.Conversion_a[0] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value_h[0];\r\n  stateEstimator_B.Conversion_a[1] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value_h[1];\r\n  stateEstimator_B.Conversion_a[2] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value_h[2];\r\n  stateEstimator_B.Conversion_a[3] = (real32_T)\r\n    stateEstimator_P_g.KalmanGainL_Value_h[3];\r\n\r\n  /* Delay: '<S78>/MemoryX' incorporates:\r\n   *  Constant: '<S78>/X0'\r\n   *  Reshape: '<S78>/ReshapeX0'\r\n   */\r\n  if (stateEstimator_DW.icLoad) {\r\n    stateEstimator_DW.MemoryX_DSTATE_d[0] = stateEstimator_P_g.X0_Value_e[0];\r\n    stateEstimator_DW.MemoryX_DSTATE_d[1] = stateEstimator_P_g.X0_Value_e[1];\r\n  }\r\n\r\n  /* Delay: '<S78>/MemoryX' */\r\n  stateEstimator_B.MemoryX_m[0] = stateEstimator_DW.MemoryX_DSTATE_d[0];\r\n  stateEstimator_B.MemoryX_m[1] = stateEstimator_DW.MemoryX_DSTATE_d[1];\r\n  for (stateEstimator_B.cff = 0; stateEstimator_B.cff < 2; stateEstimator_B.cff\r\n       ++) {\r\n    /* DiscreteFilter: '<S77>/IIRgyroz' */\r\n    stateEstimator_B.memOffset = stateEstimator_B.cff * 5;\r\n    stateEstimator_B.rtb_DataTypeConversion1_idx_1 =\r\n      stateEstimator_B.inverseIMU_gain[stateEstimator_B.cff + 3];\r\n    stateEstimator_B.denIdx = 1;\r\n    for (stateEstimator_B.i = 0; stateEstimator_B.i < 5; stateEstimator_B.i++) {\r\n      stateEstimator_B.rtb_DataTypeConversion1_idx_1 -=\r\n        stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset +\r\n        stateEstimator_B.i] *\r\n        stateEstimator_P_g.IIRgyroz_DenCoef[stateEstimator_B.denIdx];\r\n      stateEstimator_B.denIdx++;\r\n    }\r\n\r\n    stateEstimator_DW.IIRgyroz_tmp[stateEstimator_B.cff] =\r\n      stateEstimator_B.rtb_DataTypeConversion1_idx_1 /\r\n      stateEstimator_P_g.IIRgyroz_DenCoef[0];\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 = stateEstimator_P_g.IIRgyroz_NumCoef[0]\r\n      * stateEstimator_DW.IIRgyroz_tmp[stateEstimator_B.cff];\r\n    stateEstimator_B.denIdx = 1;\r\n    for (stateEstimator_B.i = 0; stateEstimator_B.i < 5; stateEstimator_B.i++) {\r\n      stateEstimator_B.rtb_sincos_o2_idx_0 +=\r\n        stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset +\r\n        stateEstimator_B.i] *\r\n        stateEstimator_P_g.IIRgyroz_NumCoef[stateEstimator_B.denIdx];\r\n      stateEstimator_B.denIdx++;\r\n    }\r\n\r\n    /* SampleTimeMath: '<S84>/TSamp' incorporates:\r\n     *  DiscreteFilter: '<S77>/IIRgyroz'\r\n     *\r\n     * About '<S84>/TSamp':\r\n     *  y = u * K where K = 1 / ( w * Ts )\r\n     */\r\n    stateEstimator_B.rtb_sincos_o2_idx_0 *= stateEstimator_P_g.TSamp_WtEt;\r\n\r\n    /* Sum: '<S84>/Diff' incorporates:\r\n     *  UnitDelay: '<S84>/UD'\r\n     *\r\n     * Block description for '<S84>/Diff':\r\n     *\r\n     *  Add in CPU\r\n     *\r\n     * Block description for '<S84>/UD':\r\n     *\r\n     *  Store in Global RAM\r\n     */\r\n    stateEstimator_DW.UD_DSTATE[stateEstimator_B.cff] =\r\n      stateEstimator_B.rtb_sincos_o2_idx_0 -\r\n      stateEstimator_DW.UD_DSTATE[stateEstimator_B.cff];\r\n\r\n    /* SampleTimeMath: '<S84>/TSamp'\r\n     *\r\n     * About '<S84>/TSamp':\r\n     *  y = u * K where K = 1 / ( w * Ts )\r\n     */\r\n    stateEstimator_B.TSamp[stateEstimator_B.cff] =\r\n      stateEstimator_B.rtb_sincos_o2_idx_0;\r\n  }\r\n\r\n  /* Gain: '<S74>/opticalFlowToVelocity_gain' */\r\n  stateEstimator_B.opticalFlowToVelocity_gain[0] =\r\n    stateEstimator_P_g.opticalFlowToVelocity_gain_Gain * arg_opticalFlow_datin[0];\r\n  stateEstimator_B.opticalFlowToVelocity_gain[1] =\r\n    stateEstimator_P_g.opticalFlowToVelocity_gain_Gain * arg_opticalFlow_datin[1];\r\n  stateEstimator_B.opticalFlowToVelocity_gain[2] =\r\n    stateEstimator_P_g.opticalFlowToVelocity_gain_Gain * arg_opticalFlow_datin[2];\r\n\r\n  /* RelationalOperator: '<S17>/Compare' incorporates:\r\n   *  Constant: '<S17>/Constant'\r\n   *  Delay: '<S3>/Delay2'\r\n   */\r\n  stateEstimator_B.Compare = (stateEstimator_DW.Delay2_DSTATE >\r\n    stateEstimator_P_g.outlierBelowFloor_const);\r\n\r\n  /* Delay: '<S14>/MemoryX' incorporates:\r\n   *  Constant: '<S14>/X0'\r\n   *  DataTypeConversion: '<S14>/DataTypeConversionReset'\r\n   *  Reshape: '<S14>/ReshapeX0'\r\n   */\r\n  stateEstimator_DW.icLoad_p = (stateEstimator_B.Compare ||\r\n    stateEstimator_DW.icLoad_p);\r\n  if (stateEstimator_DW.icLoad_p) {\r\n    stateEstimator_DW.MemoryX_DSTATE[0] = stateEstimator_P_g.X0_Value[0];\r\n    stateEstimator_DW.MemoryX_DSTATE[1] = stateEstimator_P_g.X0_Value[1];\r\n  }\r\n\r\n  /* Gain: '<S3>/invertzaxisGain' */\r\n  stateEstimator_B.invertzaxisGain = (real_T)\r\n    stateEstimator_P_g.invertzaxisGain_Gain *\r\n    arg_sensordata_datin->altitude_sonar;\r\n\r\n  /* DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_tmp = (((stateEstimator_B.invertzaxisGain -\r\n    stateEstimator_DW.soonarFilter_IIR_states[0] *\r\n    stateEstimator_P_g.soonarFilter_IIR_DenCoef[1]) -\r\n    stateEstimator_DW.soonarFilter_IIR_states[1] *\r\n    stateEstimator_P_g.soonarFilter_IIR_DenCoef[2]) -\r\n    stateEstimator_DW.soonarFilter_IIR_states[2] *\r\n    stateEstimator_P_g.soonarFilter_IIR_DenCoef[3]) /\r\n    stateEstimator_P_g.soonarFilter_IIR_DenCoef[0];\r\n\r\n  /* DiscreteFilter: '<S15>/pressureFilter_IIR' incorporates:\r\n   *  DataTypeConversion: '<S5>/Data Type Conversion'\r\n   *  Gain: '<S3>/prsToAltGain'\r\n   *  Sum: '<S5>/Sum2'\r\n   */\r\n  stateEstimator_DW.pressureFilter_IIR_tmp = ((((arg_sensordata_datin->prs -\r\n    arg_sensorCalibration_datin[6]) * stateEstimator_P_g.prsToAltGain_Gain -\r\n    stateEstimator_DW.pressureFilter_IIR_states[0] *\r\n    stateEstimator_P_g.pressureFilter_IIR_DenCoef[1]) -\r\n    stateEstimator_DW.pressureFilter_IIR_states[1] *\r\n    stateEstimator_P_g.pressureFilter_IIR_DenCoef[2]) -\r\n    stateEstimator_DW.pressureFilter_IIR_states[2] *\r\n    stateEstimator_P_g.pressureFilter_IIR_DenCoef[3]) /\r\n    stateEstimator_P_g.pressureFilter_IIR_DenCoef[0];\r\n\r\n  /* Saturate: '<S15>/SaturationSonar' */\r\n  if (stateEstimator_B.invertzaxisGain > -rtP_Sensors.altSensorMin) {\r\n    stateEstimator_B.rtb_Add_j_idx_0 = -rtP_Sensors.altSensorMin;\r\n  } else if (stateEstimator_B.invertzaxisGain <\r\n             stateEstimator_P_g.SaturationSonar_LowerSat) {\r\n    stateEstimator_B.rtb_Add_j_idx_0 =\r\n      stateEstimator_P_g.SaturationSonar_LowerSat;\r\n  } else {\r\n    stateEstimator_B.rtb_Add_j_idx_0 = stateEstimator_B.invertzaxisGain;\r\n  }\r\n\r\n  /* End of Saturate: '<S15>/SaturationSonar' */\r\n\r\n  /* Logic: '<S15>/nicemeasurementor newupdateneeded' incorporates:\r\n   *  Abs: '<S15>/Absestdiff'\r\n   *  Abs: '<S15>/Absestdiff1'\r\n   *  Abs: '<S15>/Absestdiff2'\r\n   *  Constant: '<S69>/Constant'\r\n   *  Constant: '<S70>/Constant'\r\n   *  Constant: '<S71>/Constant'\r\n   *  Constant: '<S72>/Constant'\r\n   *  Delay: '<S3>/Delay2'\r\n   *  DiscreteFilter: '<S15>/pressureFilter_IIR'\r\n   *  DiscreteFilter: '<S15>/soonarFilter_IIR'\r\n   *  Logic: '<S15>/findingoutliers'\r\n   *  Logic: '<S15>/newupdateneeded'\r\n   *  RelationalOperator: '<S69>/Compare'\r\n   *  RelationalOperator: '<S70>/Compare'\r\n   *  RelationalOperator: '<S71>/Compare'\r\n   *  RelationalOperator: '<S72>/Compare'\r\n   *  Sum: '<S15>/Add'\r\n   *  Sum: '<S15>/Add1'\r\n   *  Sum: '<S15>/Add2'\r\n   */\r\n  stateEstimator_B.nicemeasurementornewupdateneeded = (((fabs\r\n    (stateEstimator_DW.Delay2_DSTATE - stateEstimator_B.rtb_Add_j_idx_0) <=\r\n    stateEstimator_P_g.outlierJump_const) && (stateEstimator_B.invertzaxisGain <\r\n    -rtP_Sensors.altSensorMin)) || ((fabs\r\n    ((((stateEstimator_P_g.soonarFilter_IIR_NumCoef[0] *\r\n        stateEstimator_DW.soonarFilter_IIR_tmp +\r\n        stateEstimator_DW.soonarFilter_IIR_states[0] *\r\n        stateEstimator_P_g.soonarFilter_IIR_NumCoef[1]) +\r\n       stateEstimator_DW.soonarFilter_IIR_states[1] *\r\n       stateEstimator_P_g.soonarFilter_IIR_NumCoef[2]) +\r\n      stateEstimator_DW.soonarFilter_IIR_states[2] *\r\n      stateEstimator_P_g.soonarFilter_IIR_NumCoef[3]) -\r\n     stateEstimator_DW.Delay2_DSTATE) >=\r\n    stateEstimator_P_g.currentStateVeryOffsonarflt_const) && (fabs\r\n    ((((stateEstimator_P_g.pressureFilter_IIR_NumCoef[0] *\r\n        stateEstimator_DW.pressureFilter_IIR_tmp +\r\n        stateEstimator_DW.pressureFilter_IIR_states[0] *\r\n        stateEstimator_P_g.pressureFilter_IIR_NumCoef[1]) +\r\n       stateEstimator_DW.pressureFilter_IIR_states[1] *\r\n       stateEstimator_P_g.pressureFilter_IIR_NumCoef[2]) +\r\n      stateEstimator_DW.pressureFilter_IIR_states[2] *\r\n      stateEstimator_P_g.pressureFilter_IIR_NumCoef[3]) -\r\n     stateEstimator_DW.Delay2_DSTATE) >=\r\n    stateEstimator_P_g.currentEstimateVeryOffFromPressure_const)));\r\n\r\n  /* Outputs for Enabled SubSystem: '<S42>/Enabled Subsystem' incorporates:\r\n   *  EnablePort: '<S68>/Enable'\r\n   */\r\n  /* DataTypeConversion: '<S14>/DataTypeConversionEnable' */\r\n  if (stateEstimator_B.nicemeasurementornewupdateneeded) {\r\n    stateEstimator_DW.EnabledSubsystem_MODE = true;\r\n\r\n    /* Sum: '<S68>/Add1' incorporates:\r\n     *  Constant: '<S14>/C'\r\n     *  Delay: '<S14>/MemoryX'\r\n     *  Product: '<S68>/Product'\r\n     *  Reshape: '<S14>/Reshapey'\r\n     */\r\n    stateEstimator_B.Sum_c = stateEstimator_B.invertzaxisGain -\r\n      (stateEstimator_P_g.C_Value[0] * stateEstimator_DW.MemoryX_DSTATE[0] +\r\n       stateEstimator_P_g.C_Value[1] * stateEstimator_DW.MemoryX_DSTATE[1]);\r\n\r\n    /* Product: '<S68>/Product2' incorporates:\r\n     *  Constant: '<S18>/KalmanGainM'\r\n     *  DataTypeConversion: '<S59>/Conversion'\r\n     */\r\n    stateEstimator_B.Product2[0] = stateEstimator_P_g.KalmanGainM_Value_p[0] *\r\n      stateEstimator_B.Sum_c;\r\n    stateEstimator_B.Product2[1] = stateEstimator_P_g.KalmanGainM_Value_p[1] *\r\n      stateEstimator_B.Sum_c;\r\n  } else if (stateEstimator_DW.EnabledSubsystem_MODE) {\r\n    /* Disable for Product: '<S68>/Product2' incorporates:\r\n     *  Outport: '<S68>/deltax'\r\n     */\r\n    stateEstimator_B.Product2[0] = stateEstimator_P_g.deltax_Y0;\r\n    stateEstimator_B.Product2[1] = stateEstimator_P_g.deltax_Y0;\r\n    stateEstimator_DW.EnabledSubsystem_MODE = false;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S42>/Enabled Subsystem' */\r\n\r\n  /* Sum: '<S42>/Add' incorporates:\r\n   *  Delay: '<S14>/MemoryX'\r\n   */\r\n  stateEstimator_B.rtb_Add_j_idx_0 = stateEstimator_B.Product2[0] +\r\n    stateEstimator_DW.MemoryX_DSTATE[0];\r\n  stateEstimator_B.Sum_c = stateEstimator_B.Product2[1] +\r\n    stateEstimator_DW.MemoryX_DSTATE[1];\r\n\r\n  /* Abs: '<S77>/Abs' incorporates:\r\n   *  Abs: '<S77>/Abs4'\r\n   */\r\n  stateEstimator_B.rtb_sincos_o2_idx_2 = (real32_T)fabs\r\n    (stateEstimator_B.inverseIMU_gain[3]);\r\n\r\n  /* Abs: '<S77>/Abs1' incorporates:\r\n   *  Abs: '<S77>/Abs5'\r\n   */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)fabs\r\n    (stateEstimator_B.inverseIMU_gain[4]);\r\n\r\n  /* Abs: '<S77>/Abs3' incorporates:\r\n   *  Abs: '<S150>/Abs1'\r\n   */\r\n  stateEstimator_B.rtb_sincos_o2_idx_0 = (real32_T)fabs\r\n    (stateEstimator_DW.Memory_PreviousInput[2]);\r\n\r\n  /* Abs: '<S77>/Abs2' incorporates:\r\n   *  Abs: '<S150>/Abs'\r\n   */\r\n  stateEstimator_B.rtb_sincos_o2_idx_1 = (real32_T)fabs\r\n    (stateEstimator_DW.Memory_PreviousInput[1]);\r\n\r\n  /* Logic: '<S77>/Logical Operator3' incorporates:\r\n   *  Abs: '<S77>/Abs'\r\n   *  Abs: '<S77>/Abs1'\r\n   *  Abs: '<S77>/Abs2'\r\n   *  Abs: '<S77>/Abs3'\r\n   *  Abs: '<S77>/Abs6'\r\n   *  Abs: '<S77>/Abs7'\r\n   *  Abs: '<S77>/Abs8'\r\n   *  Abs: '<S77>/Abs9'\r\n   *  Constant: '<S85>/Constant'\r\n   *  Constant: '<S86>/Constant'\r\n   *  Constant: '<S87>/Constant'\r\n   *  Constant: '<S88>/Constant'\r\n   *  Constant: '<S89>/Constant'\r\n   *  Constant: '<S90>/Constant'\r\n   *  Constant: '<S91>/Constant'\r\n   *  Constant: '<S92>/Constant'\r\n   *  Constant: '<S93>/Constant'\r\n   *  Constant: '<S94>/Constant'\r\n   *  Constant: '<S95>/Constant'\r\n   *  DataTypeConversion: '<S3>/Data Type Conversion'\r\n   *  Delay: '<S74>/Delay'\r\n   *  Logic: '<S77>/Logical Operator'\r\n   *  Logic: '<S77>/Logical Operator1'\r\n   *  Logic: '<S77>/Logical Operator2'\r\n   *  RelationalOperator: '<S85>/Compare'\r\n   *  RelationalOperator: '<S86>/Compare'\r\n   *  RelationalOperator: '<S87>/Compare'\r\n   *  RelationalOperator: '<S88>/Compare'\r\n   *  RelationalOperator: '<S89>/Compare'\r\n   *  RelationalOperator: '<S90>/Compare'\r\n   *  RelationalOperator: '<S91>/Compare'\r\n   *  RelationalOperator: '<S92>/Compare'\r\n   *  RelationalOperator: '<S93>/Compare'\r\n   *  RelationalOperator: '<S94>/Compare'\r\n   *  RelationalOperator: '<S95>/Compare'\r\n   *  Reshape: '<S14>/Reshapexhat'\r\n   *  Sum: '<S77>/Add'\r\n   */\r\n  stateEstimator_B.LogicalOperator3 = ((((stateEstimator_B.rtb_sincos_o2_idx_1 <=\r\n    stateEstimator_P_g.maxp_const) && (stateEstimator_B.rtb_sincos_o2_idx_0 <=\r\n    stateEstimator_P_g.maxq_const) && (stateEstimator_B.rtb_sincos_o2_idx_2 <=\r\n    stateEstimator_P_g.maxw1_const) &&\r\n    (stateEstimator_B.rtb_DataTypeConversion1_idx_1 <=\r\n     stateEstimator_P_g.maxw2_const) && ((real32_T)fabs\r\n    (stateEstimator_DW.UD_DSTATE[0]) <= stateEstimator_P_g.maxdw1_const) &&\r\n    ((real32_T)fabs(stateEstimator_DW.UD_DSTATE[1]) <=\r\n     stateEstimator_P_g.maxdw2_const)) || ((stateEstimator_B.rtb_sincos_o2_idx_2\r\n    <= stateEstimator_P_g.maxp2_const) &&\r\n    (stateEstimator_B.rtb_DataTypeConversion1_idx_1 <=\r\n     stateEstimator_P_g.maxq2_const))) && ((real32_T)fabs\r\n    (stateEstimator_B.opticalFlowToVelocity_gain[0] -\r\n     stateEstimator_DW.Delay_DSTATE[0]) <= stateEstimator_P_g.maxw3_const) &&\r\n    ((real32_T)fabs(stateEstimator_B.opticalFlowToVelocity_gain[1] -\r\n                    stateEstimator_DW.Delay_DSTATE[1]) <=\r\n     stateEstimator_P_g.maxw4_const) && ((real32_T)\r\n    stateEstimator_B.rtb_Add_j_idx_0 <= stateEstimator_P_g.minHeightforOF_const));\r\n\r\n  /* DataTypeConversion: '<S78>/DataTypeConversionEnable' */\r\n  rtb_DataTypeConversionEnable_i = stateEstimator_B.LogicalOperator3;\r\n\r\n  /* Reshape: '<S78>/Reshapey' */\r\n  stateEstimator_B.Reshapey_o[0] = stateEstimator_B.opticalFlowToVelocity_gain[0];\r\n  stateEstimator_B.Reshapey_o[1] = stateEstimator_B.opticalFlowToVelocity_gain[1];\r\n\r\n  /* Outputs for Enabled SubSystem: '<S122>/Enabled Subsystem' */\r\n  /* Constant: '<S78>/C' */\r\n  stateEstimator_EnabledSubsystem(rtb_DataTypeConversionEnable_i,\r\n    stateEstimator_B.Conversion_p, stateEstimator_P_g.C_Value_f,\r\n    stateEstimator_B.Reshapey_o, stateEstimator_B.MemoryX_m,\r\n    stateEstimator_B.Product2_k, &stateEstimator_DW.EnabledSubsystem_f,\r\n    &stateEstimator_P_g.EnabledSubsystem_f);\r\n\r\n  /* End of Outputs for SubSystem: '<S122>/Enabled Subsystem' */\r\n\r\n  /* Reshape: '<S78>/Reshapexhat' incorporates:\r\n   *  Delay: '<S74>/Delay'\r\n   *  Sum: '<S122>/Add'\r\n   */\r\n  stateEstimator_DW.Delay_DSTATE[0] = stateEstimator_B.Product2_k[0] +\r\n    stateEstimator_B.MemoryX_m[0];\r\n  stateEstimator_DW.Delay_DSTATE[1] = stateEstimator_B.Product2_k[1] +\r\n    stateEstimator_B.MemoryX_m[1];\r\n\r\n  /* SignalConversion generated from: '<S3>/Product1' incorporates:\r\n   *  Delay: '<S1>/Delay'\r\n   */\r\n  stateEstimator_B.unnamed_idx_0 = stateEstimator_DW.Delay_DSTATE_p[0];\r\n  stateEstimator_B.unnamed_idx_1 = stateEstimator_DW.Delay_DSTATE_p[1];\r\n\r\n  /* Product: '<S3>/Product1' incorporates:\r\n   *  Reshape: '<S14>/Reshapexhat'\r\n   *  Reshape: '<S73>/Reshape (9) to [3x3] column-major'\r\n   *  SignalConversion generated from: '<S3>/Product1'\r\n   */\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 3; stateEstimator_B.i++) {\r\n    stateEstimator_B.rtb_VectorConcatenate_c[stateEstimator_B.i] =\r\n      (stateEstimator_B.VectorConcatenate[stateEstimator_B.i + 3] *\r\n       stateEstimator_B.unnamed_idx_1 +\r\n       stateEstimator_B.VectorConcatenate[stateEstimator_B.i] *\r\n       stateEstimator_B.unnamed_idx_0) +\r\n      stateEstimator_B.VectorConcatenate[stateEstimator_B.i + 6] *\r\n      stateEstimator_B.Sum_c;\r\n  }\r\n\r\n  /* End of Product: '<S3>/Product1' */\r\n\r\n  /* DataTypeConversion: '<S3>/Data Type Conversion2' */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)\r\n    stateEstimator_B.rtb_VectorConcatenate_c[2];\r\n\r\n  /* SignalConversion generated from: '<S75>/Product' incorporates:\r\n   *  Delay: '<S74>/Delay'\r\n   */\r\n  stateEstimator_B.rtb_sincos_o2_idx_2 = stateEstimator_DW.Delay_DSTATE[0];\r\n  y = stateEstimator_DW.Delay_DSTATE[1];\r\n\r\n  /* RelationalOperator: '<S79>/Compare' incorporates:\r\n   *  Constant: '<S79>/Constant'\r\n   *  DataTypeConversion: '<S3>/Data Type Conversion'\r\n   *  Reshape: '<S14>/Reshapexhat'\r\n   */\r\n  rtb_Compare_i = ((real32_T)stateEstimator_B.rtb_Add_j_idx_0 <=\r\n                   stateEstimator_P_g.DeactivateAccelerationIfOFisnotusedduetolowaltitude_const);\r\n\r\n  /* Logic: '<S76>/Logical Operator' incorporates:\r\n   *  Constant: '<S81>/Constant'\r\n   *  Constant: '<S82>/Constant'\r\n   *  RelationalOperator: '<S81>/Compare'\r\n   *  RelationalOperator: '<S82>/Compare'\r\n   */\r\n  rtb_LogicalOperator_cg = ((stateEstimator_B.opticalFlowToVelocity_gain[0] !=\r\n    stateEstimator_P_g.donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto200_con)\r\n    || (stateEstimator_B.opticalFlowToVelocity_gain[1] !=\r\n        stateEstimator_P_g.donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto2001_co));\r\n  for (stateEstimator_B.i = 0; stateEstimator_B.i < 3; stateEstimator_B.i++) {\r\n    /* Product: '<S75>/Product' incorporates:\r\n     *  Math: '<S75>/Math Function'\r\n     *  SignalConversion generated from: '<S75>/Product'\r\n     */\r\n    stateEstimator_B.Product[stateEstimator_B.i] = 0.0F;\r\n    stateEstimator_B.Product[stateEstimator_B.i] +=\r\n      stateEstimator_B.MathFunction_b[stateEstimator_B.i] *\r\n      stateEstimator_B.rtb_sincos_o2_idx_2;\r\n    stateEstimator_B.Product[stateEstimator_B.i] +=\r\n      stateEstimator_B.MathFunction_b[stateEstimator_B.i + 3] * y;\r\n    stateEstimator_B.Product[stateEstimator_B.i] +=\r\n      stateEstimator_B.MathFunction_b[stateEstimator_B.i + 6] *\r\n      stateEstimator_B.rtb_DataTypeConversion1_idx_1;\r\n\r\n    /* Sum: '<S3>/Sum' incorporates:\r\n     *  Constant: '<S3>/Constant'\r\n     *  DiscreteFir: '<S5>/FIR_IMUaccel'\r\n     *  Math: '<S3>/Math Function'\r\n     *  Product: '<S3>/Product'\r\n     *  Reshape: '<S73>/Reshape (9) to [3x3] column-major'\r\n     */\r\n    stateEstimator_B.Sum[stateEstimator_B.i] =\r\n      ((stateEstimator_B.VectorConcatenate[3 * stateEstimator_B.i + 1] *\r\n        stateEstimator_B.FIR_IMUaccel[1] + stateEstimator_B.VectorConcatenate[3 *\r\n        stateEstimator_B.i] * stateEstimator_B.FIR_IMUaccel[0]) +\r\n       stateEstimator_B.VectorConcatenate[3 * stateEstimator_B.i + 2] *\r\n       rtb_DataTypeConversion1_idx_0) +\r\n      stateEstimator_P_g.Constant_Value[stateEstimator_B.i];\r\n\r\n    /* Sum: '<S76>/Add' incorporates:\r\n     *  Constant: '<S76>/gravity'\r\n     *  Product: '<S76>/Product1'\r\n     *  Reshape: '<S83>/Reshape (9) to [3x3] column-major'\r\n     */\r\n    stateEstimator_B.rtb_FIR_IMUaccel_k[stateEstimator_B.i] =\r\n      stateEstimator_B.FIR_IMUaccel[stateEstimator_B.i] -\r\n      ((stateEstimator_B.Reshape9to3x3columnmajor[stateEstimator_B.i + 3] *\r\n        stateEstimator_P_g.gravity_Value[1] +\r\n        stateEstimator_B.Reshape9to3x3columnmajor[stateEstimator_B.i] *\r\n        stateEstimator_P_g.gravity_Value[0]) +\r\n       stateEstimator_B.Reshape9to3x3columnmajor[stateEstimator_B.i + 6] *\r\n       stateEstimator_P_g.gravity_Value[2]);\r\n  }\r\n\r\n  /* Product: '<S76>/Product' incorporates:\r\n   *  Gain: '<S76>/gainaccinput'\r\n   */\r\n  stateEstimator_B.Product_p[0] = (real32_T)\r\n    (stateEstimator_P_g.gainaccinput_Gain * stateEstimator_B.rtb_FIR_IMUaccel_k\r\n     [0]) * (real32_T)rtb_LogicalOperator_cg * (real32_T)rtb_Compare_i;\r\n  stateEstimator_B.Product_p[1] = (real32_T)\r\n    (stateEstimator_P_g.gainaccinput_Gain * stateEstimator_B.rtb_FIR_IMUaccel_k\r\n     [1]) * (real32_T)rtb_LogicalOperator_cg * (real32_T)rtb_Compare_i;\r\n\r\n  /* Reshape: '<S78>/Reshapeu' */\r\n  stateEstimator_B.Reshapeu_h[0] = stateEstimator_B.Product_p[0];\r\n  stateEstimator_B.Reshapeu_h[1] = stateEstimator_B.Product_p[1];\r\n\r\n  /* DataTypeConversion: '<S111>/Conversion' */\r\n  stateEstimator_B.Conversion_j[0] = stateEstimator_B.MemoryX_m[0];\r\n  stateEstimator_B.Conversion_j[1] = stateEstimator_B.MemoryX_m[1];\r\n\r\n  /* Outputs for Enabled SubSystem: '<S115>/MeasurementUpdate' */\r\n  /* Constant: '<S78>/C' incorporates:\r\n   *  Constant: '<S78>/D'\r\n   */\r\n  stateEstimator_MeasurementUpdate(rtb_DataTypeConversionEnable_i,\r\n    stateEstimator_B.Conversion_n4, stateEstimator_B.Reshapey_o,\r\n    stateEstimator_P_g.C_Value_f, stateEstimator_B.Conversion_j,\r\n    stateEstimator_P_g.D_Value_f, stateEstimator_B.Reshapeu_h,\r\n    stateEstimator_B.Product3_m, &stateEstimator_DW.MeasurementUpdate_e,\r\n    &stateEstimator_P_g.MeasurementUpdate_e);\r\n\r\n  /* End of Outputs for SubSystem: '<S115>/MeasurementUpdate' */\r\n\r\n  /* Reshape: '<S149>/Reshapeu' */\r\n  stateEstimator_B.Reshapeu_i[0] = stateEstimator_B.Product[0];\r\n  stateEstimator_B.Reshapeu_i[1] = stateEstimator_B.Product[1];\r\n\r\n  /* Delay: '<S149>/MemoryX' incorporates:\r\n   *  Constant: '<S149>/X0'\r\n   *  Reshape: '<S149>/ReshapeX0'\r\n   */\r\n  if (stateEstimator_DW.icLoad_g) {\r\n    stateEstimator_DW.MemoryX_DSTATE_dl[0] = stateEstimator_P_g.X0_Value_j[0];\r\n    stateEstimator_DW.MemoryX_DSTATE_dl[1] = stateEstimator_P_g.X0_Value_j[1];\r\n  }\r\n\r\n  /* Delay: '<S149>/MemoryX' */\r\n  stateEstimator_B.MemoryX_f[0] = stateEstimator_DW.MemoryX_DSTATE_dl[0];\r\n  stateEstimator_B.MemoryX_f[1] = stateEstimator_DW.MemoryX_DSTATE_dl[1];\r\n\r\n  /* DataTypeConversion: '<S167>/Conversion' */\r\n  stateEstimator_B.Conversion_pu[0] = stateEstimator_B.MemoryX_f[0];\r\n  stateEstimator_B.Conversion_pu[1] = stateEstimator_B.MemoryX_f[1];\r\n\r\n  /* Sum: '<S150>/Add1' incorporates:\r\n   *  Delay: '<S75>/Delay'\r\n   */\r\n  stateEstimator_DW.Delay_DSTATE_l[0] = arg_posVIS_datin[0] -\r\n    stateEstimator_DW.Delay_DSTATE_l[0];\r\n\r\n  /* Math: '<S150>/Math Function' incorporates:\r\n   *  Constant: '<S150>/Constant'\r\n   *  Delay: '<S75>/Delay'\r\n   */\r\n  stateEstimator_B.rtb_DataTypeConversion1_idx_1 = (real32_T)floor\r\n    (stateEstimator_P_g.Constant_Value_e);\r\n  if ((stateEstimator_DW.Delay_DSTATE_l[0] < 0.0F) &&\r\n      (stateEstimator_P_g.Constant_Value_e >\r\n       stateEstimator_B.rtb_DataTypeConversion1_idx_1)) {\r\n    stateEstimator_DW.Delay_DSTATE_l[0] = -rt_powf_snf\r\n      (-stateEstimator_DW.Delay_DSTATE_l[0], stateEstimator_P_g.Constant_Value_e);\r\n  } else {\r\n    stateEstimator_DW.Delay_DSTATE_l[0] = rt_powf_snf\r\n      (stateEstimator_DW.Delay_DSTATE_l[0], stateEstimator_P_g.Constant_Value_e);\r\n  }\r\n\r\n  /* Sum: '<S150>/Add1' incorporates:\r\n   *  Delay: '<S75>/Delay'\r\n   */\r\n  stateEstimator_DW.Delay_DSTATE_l[1] = arg_posVIS_datin[1] -\r\n    stateEstimator_DW.Delay_DSTATE_l[1];\r\n\r\n  /* Math: '<S150>/Math Function' incorporates:\r\n   *  Constant: '<S150>/Constant'\r\n   *  Delay: '<S75>/Delay'\r\n   */\r\n  if ((stateEstimator_DW.Delay_DSTATE_l[1] < 0.0F) &&\r\n      (stateEstimator_P_g.Constant_Value_e >\r\n       stateEstimator_B.rtb_DataTypeConversion1_idx_1)) {\r\n    stateEstimator_DW.Delay_DSTATE_l[1] = -rt_powf_snf\r\n      (-stateEstimator_DW.Delay_DSTATE_l[1], stateEstimator_P_g.Constant_Value_e);\r\n  } else {\r\n    stateEstimator_DW.Delay_DSTATE_l[1] = rt_powf_snf\r\n      (stateEstimator_DW.Delay_DSTATE_l[1], stateEstimator_P_g.Constant_Value_e);\r\n  }\r\n\r\n  /* Logic: '<S150>/Logical Operator3' incorporates:\r\n   *  Constant: '<S205>/Constant'\r\n   *  Constant: '<S206>/Constant'\r\n   *  Constant: '<S207>/Constant'\r\n   *  Constant: '<S208>/Constant'\r\n   *  Delay: '<S75>/Delay'\r\n   *  RelationalOperator: '<S205>/Compare'\r\n   *  RelationalOperator: '<S206>/Compare'\r\n   *  RelationalOperator: '<S207>/Compare'\r\n   *  RelationalOperator: '<S208>/Compare'\r\n   *  Sqrt: '<S150>/Sqrt'\r\n   *  Sum: '<S150>/Sum of Elements'\r\n   */\r\n  stateEstimator_B.LogicalOperator3_o = ((stateEstimator_B.rtb_sincos_o2_idx_1 <=\r\n    stateEstimator_P_g.maxp3_const) && (stateEstimator_B.rtb_sincos_o2_idx_0 <=\r\n    stateEstimator_P_g.maxq3_const) && (arg_posVIS_datin[0] !=\r\n    stateEstimator_P_g.checkifPosavailable_const) && ((real32_T)sqrt\r\n    (stateEstimator_DW.Delay_DSTATE_l[0] + stateEstimator_DW.Delay_DSTATE_l[1]) <\r\n    stateEstimator_P_g.planarjumpsVISPOS_const));\r\n\r\n  /* DataTypeConversion: '<S149>/DataTypeConversionEnable' */\r\n  rtb_DataTypeConversionEnable_h = stateEstimator_B.LogicalOperator3_o;\r\n\r\n  /* Reshape: '<S149>/Reshapey' */\r\n  stateEstimator_B.Reshapey_a[0] = arg_posVIS_datin[0];\r\n  stateEstimator_B.Reshapey_a[1] = arg_posVIS_datin[1];\r\n\r\n  /* Outputs for Enabled SubSystem: '<S171>/MeasurementUpdate' */\r\n  /* Constant: '<S149>/C' incorporates:\r\n   *  Constant: '<S149>/D'\r\n   */\r\n  stateEstimator_MeasurementUpdate(rtb_DataTypeConversionEnable_h,\r\n    stateEstimator_B.Conversion_a, stateEstimator_B.Reshapey_a,\r\n    stateEstimator_P_g.C_Value_p, stateEstimator_B.Conversion_pu,\r\n    stateEstimator_P_g.D_Value_b, stateEstimator_B.Reshapeu_i,\r\n    stateEstimator_B.Product3_j, &stateEstimator_DW.MeasurementUpdate_b,\r\n    &stateEstimator_P_g.MeasurementUpdate_b);\r\n\r\n  /* End of Outputs for SubSystem: '<S171>/MeasurementUpdate' */\r\n\r\n  /* Outputs for Enabled SubSystem: '<S178>/Enabled Subsystem' */\r\n  stateEstimator_EnabledSubsystem(rtb_DataTypeConversionEnable_h,\r\n    stateEstimator_B.Conversion_g, stateEstimator_P_g.C_Value_p,\r\n    stateEstimator_B.Reshapey_a, stateEstimator_B.MemoryX_f,\r\n    stateEstimator_B.Product2_e, &stateEstimator_DW.EnabledSubsystem_m,\r\n    &stateEstimator_P_g.EnabledSubsystem_m);\r\n\r\n  /* End of Outputs for SubSystem: '<S178>/Enabled Subsystem' */\r\n\r\n  /* Reshape: '<S149>/Reshapexhat' incorporates:\r\n   *  Delay: '<S75>/Delay'\r\n   *  Sum: '<S178>/Add'\r\n   */\r\n  stateEstimator_DW.Delay_DSTATE_l[0] = stateEstimator_B.Product2_e[0] +\r\n    stateEstimator_B.MemoryX_f[0];\r\n  stateEstimator_DW.Delay_DSTATE_l[1] = stateEstimator_B.Product2_e[1] +\r\n    stateEstimator_B.MemoryX_f[1];\r\n\r\n  /* DiscreteIntegrator: '<S75>/Integrator' */\r\n  if (arg_controlModePosVSOrient_flagin &&\r\n      (stateEstimator_DW.Integrator_PrevResetState <= 0)) {\r\n    stateEstimator_DW.Integrator_DSTATE[0] = stateEstimator_P_g.Integrator_IC;\r\n    stateEstimator_DW.Integrator_DSTATE[1] = stateEstimator_P_g.Integrator_IC;\r\n  }\r\n\r\n  /* Switch: '<S75>/UseIPPosSwitch' incorporates:\r\n   *  Delay: '<S75>/Delay'\r\n   *  DiscreteIntegrator: '<S75>/Integrator'\r\n   */\r\n  if (arg_usePosVIS_flagin > stateEstimator_P_g.UseIPPosSwitch_Threshold) {\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 = stateEstimator_DW.Delay_DSTATE_l[0];\r\n    stateEstimator_B.rtb_sincos_o2_idx_2 = stateEstimator_DW.Delay_DSTATE_l[1];\r\n  } else {\r\n    stateEstimator_B.rtb_sincos_o2_idx_1 = stateEstimator_DW.Integrator_DSTATE[0];\r\n    stateEstimator_B.rtb_sincos_o2_idx_2 = stateEstimator_DW.Integrator_DSTATE[1];\r\n  }\r\n\r\n  /* End of Switch: '<S75>/UseIPPosSwitch' */\r\n\r\n  /* Outputs for Enabled SubSystem: '<S36>/MeasurementUpdate' incorporates:\r\n   *  EnablePort: '<S66>/Enable'\r\n   */\r\n  /* DataTypeConversion: '<S14>/DataTypeConversionEnable' */\r\n  if (stateEstimator_B.nicemeasurementornewupdateneeded) {\r\n    stateEstimator_DW.MeasurementUpdate_MODE = true;\r\n\r\n    /* Product: '<S66>/D[k]*u[k]' incorporates:\r\n     *  Constant: '<S14>/D'\r\n     *  Delay: '<S3>/Delay2'\r\n     *  Reshape: '<S14>/Reshapeu'\r\n     */\r\n    stateEstimator_DW.Delay2_DSTATE = stateEstimator_P_g.D_Value *\r\n      stateEstimator_B.Sum[2];\r\n\r\n    /* Sum: '<S66>/Sum' incorporates:\r\n     *  Constant: '<S14>/C'\r\n     *  Delay: '<S14>/MemoryX'\r\n     *  Delay: '<S3>/Delay2'\r\n     *  Product: '<S66>/C[k]*xhat[k|k-1]'\r\n     *  Reshape: '<S14>/Reshapey'\r\n     *  Sum: '<S66>/Add1'\r\n     */\r\n    stateEstimator_B.Sum_c = stateEstimator_B.invertzaxisGain -\r\n      ((stateEstimator_P_g.C_Value[0] * stateEstimator_DW.MemoryX_DSTATE[0] +\r\n        stateEstimator_P_g.C_Value[1] * stateEstimator_DW.MemoryX_DSTATE[1]) +\r\n       stateEstimator_DW.Delay2_DSTATE);\r\n\r\n    /* Product: '<S66>/Product3' incorporates:\r\n     *  Constant: '<S18>/KalmanGainL'\r\n     *  DataTypeConversion: '<S58>/Conversion'\r\n     */\r\n    stateEstimator_B.Product3[0] = stateEstimator_P_g.KalmanGainL_Value_e[0] *\r\n      stateEstimator_B.Sum_c;\r\n    stateEstimator_B.Product3[1] = stateEstimator_P_g.KalmanGainL_Value_e[1] *\r\n      stateEstimator_B.Sum_c;\r\n  } else if (stateEstimator_DW.MeasurementUpdate_MODE) {\r\n    /* Disable for Product: '<S66>/Product3' incorporates:\r\n     *  Outport: '<S66>/L*(y[k]-yhat[k|k-1])'\r\n     */\r\n    stateEstimator_B.Product3[0] = stateEstimator_P_g.Lykyhatkk1_Y0;\r\n    stateEstimator_B.Product3[1] = stateEstimator_P_g.Lykyhatkk1_Y0;\r\n    stateEstimator_DW.MeasurementUpdate_MODE = false;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S36>/MeasurementUpdate' */\r\n\r\n  /* BusCreator generated from: '<Root>/states_estimout' incorporates:\r\n   *  DataTypeConversion: '<S3>/Data Type Conversion'\r\n   *  DataTypeConversion: '<S3>/Data Type Conversion2'\r\n   *  Delay: '<S74>/Delay'\r\n   *  DiscreteFilter: '<S5>/IIR_IMUgyro_r'\r\n   *  Reshape: '<S14>/Reshapexhat'\r\n   *  SignalConversion generated from: '<S2>/Product'\r\n   */\r\n  arg_states_estimout->X = stateEstimator_B.rtb_sincos_o2_idx_1;\r\n  arg_states_estimout->Y = stateEstimator_B.rtb_sincos_o2_idx_2;\r\n  arg_states_estimout->Z = (real32_T)stateEstimator_B.rtb_Add_j_idx_0;\r\n  arg_states_estimout->yaw = stateEstimator_DW.Memory_PreviousInput[0];\r\n  arg_states_estimout->pitch = stateEstimator_DW.Memory_PreviousInput[1];\r\n  arg_states_estimout->roll = stateEstimator_DW.Memory_PreviousInput[2];\r\n  arg_states_estimout->dx = stateEstimator_DW.Delay_DSTATE[0];\r\n  arg_states_estimout->dy = stateEstimator_DW.Delay_DSTATE[1];\r\n  arg_states_estimout->dz = (real32_T)stateEstimator_B.rtb_VectorConcatenate_c[2];\r\n  arg_states_estimout->p = stateEstimator_B.inverseIMU_gain[3];\r\n  arg_states_estimout->q = stateEstimator_B.inverseIMU_gain[4];\r\n  arg_states_estimout->r = stateEstimator_B.numAccum;\r\n\r\n  /* MATLAB Function: '<S64>/SqrtUsedFcn' incorporates:\r\n   *  Constant: '<S18>/CovarianceZ'\r\n   *  Constant: '<S64>/isSqrtUsed'\r\n   */\r\n  if (stateEstimator_P_g.isSqrtUsed_Value) {\r\n    for (stateEstimator_B.i = 0; stateEstimator_B.i < 2; stateEstimator_B.i++) {\r\n      stateEstimator_B.Sum_c =\r\n        stateEstimator_P_g.CovarianceZ_Value[stateEstimator_B.i + 2];\r\n      stateEstimator_B.P[stateEstimator_B.i] = stateEstimator_B.Sum_c *\r\n        stateEstimator_P_g.CovarianceZ_Value[2] +\r\n        stateEstimator_P_g.CovarianceZ_Value[stateEstimator_B.i] *\r\n        stateEstimator_P_g.CovarianceZ_Value[0];\r\n      stateEstimator_B.P[stateEstimator_B.i + 2] = stateEstimator_B.Sum_c *\r\n        stateEstimator_P_g.CovarianceZ_Value[3] +\r\n        stateEstimator_P_g.CovarianceZ_Value[stateEstimator_B.i] *\r\n        stateEstimator_P_g.CovarianceZ_Value[1];\r\n    }\r\n  } else {\r\n    for (stateEstimator_B.i = 0; stateEstimator_B.i < 2; stateEstimator_B.i++) {\r\n      stateEstimator_B.P[stateEstimator_B.i] =\r\n        stateEstimator_P_g.CovarianceZ_Value[stateEstimator_B.i];\r\n      stateEstimator_B.P[stateEstimator_B.i + 2] =\r\n        stateEstimator_P_g.CovarianceZ_Value[stateEstimator_B.i + 2];\r\n    }\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S64>/SqrtUsedFcn' */\r\n\r\n  /* DataTypeConversion: '<S141>/Conversion' incorporates:\r\n   *  Constant: '<S96>/CovarianceZ'\r\n   */\r\n  stateEstimator_B.Conversion_i[0] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_b[0];\r\n  stateEstimator_B.Conversion_i[1] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_b[1];\r\n  stateEstimator_B.Conversion_i[2] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_b[2];\r\n  stateEstimator_B.Conversion_i[3] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_b[3];\r\n\r\n  /* MATLAB Function: '<S144>/SqrtUsedFcn' incorporates:\r\n   *  Constant: '<S144>/isSqrtUsed'\r\n   */\r\n  stateEstimator_SqrtUsedFcn(stateEstimator_B.Conversion_i,\r\n    stateEstimator_P_g.isSqrtUsed_Value_l, stateEstimator_B.P_b);\r\n\r\n  /* DataTypeConversion: '<S197>/Conversion' incorporates:\r\n   *  Constant: '<S152>/CovarianceZ'\r\n   */\r\n  stateEstimator_B.Conversion_ao[0] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_l[0];\r\n  stateEstimator_B.Conversion_ao[1] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_l[1];\r\n  stateEstimator_B.Conversion_ao[2] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_l[2];\r\n  stateEstimator_B.Conversion_ao[3] = (real32_T)\r\n    stateEstimator_P_g.CovarianceZ_Value_l[3];\r\n\r\n  /* MATLAB Function: '<S200>/SqrtUsedFcn' incorporates:\r\n   *  Constant: '<S200>/isSqrtUsed'\r\n   */\r\n  stateEstimator_SqrtUsedFcn(stateEstimator_B.Conversion_ao,\r\n    stateEstimator_P_g.isSqrtUsed_Value_h, stateEstimator_B.P_k);\r\n\r\n  /* Update for DiscreteFilter: '<S5>/IIR_IMUgyro_r' */\r\n  stateEstimator_DW.IIR_IMUgyro_r_states[4] =\r\n    stateEstimator_DW.IIR_IMUgyro_r_states[3];\r\n  stateEstimator_DW.IIR_IMUgyro_r_states[3] =\r\n    stateEstimator_DW.IIR_IMUgyro_r_states[2];\r\n  stateEstimator_DW.IIR_IMUgyro_r_states[2] =\r\n    stateEstimator_DW.IIR_IMUgyro_r_states[1];\r\n  stateEstimator_DW.IIR_IMUgyro_r_states[1] =\r\n    stateEstimator_DW.IIR_IMUgyro_r_states[0];\r\n  stateEstimator_DW.IIR_IMUgyro_r_states[0] =\r\n    stateEstimator_DW.IIR_IMUgyro_r_tmp;\r\n\r\n  /* Update for DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n  /* Update circular buffer index */\r\n  stateEstimator_DW.FIR_IMUaccel_circBuf--;\r\n  if (stateEstimator_DW.FIR_IMUaccel_circBuf < 0) {\r\n    stateEstimator_DW.FIR_IMUaccel_circBuf = 4;\r\n  }\r\n\r\n  /* Update circular buffer */\r\n  stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_DW.FIR_IMUaccel_circBuf] =\r\n    stateEstimator_B.inverseIMU_gain[0];\r\n  stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_DW.FIR_IMUaccel_circBuf +\r\n    5] = stateEstimator_B.inverseIMU_gain[1];\r\n  stateEstimator_DW.FIR_IMUaccel_states[stateEstimator_DW.FIR_IMUaccel_circBuf +\r\n    10] = stateEstimator_B.inverseIMU_gain[2];\r\n\r\n  /* End of Update for DiscreteFir: '<S5>/FIR_IMUaccel' */\r\n\r\n  /* Update for Delay: '<S78>/MemoryX' incorporates:\r\n   *  Constant: '<S78>/A'\r\n   *  Constant: '<S78>/B'\r\n   *  Product: '<S115>/A[k]*xhat[k|k-1]'\r\n   *  Product: '<S115>/B[k]*u[k]'\r\n   *  Sum: '<S115>/Add'\r\n   */\r\n  stateEstimator_DW.icLoad = false;\r\n  stateEstimator_DW.MemoryX_DSTATE_d[0] = ((stateEstimator_P_g.B_Value_p[0] *\r\n    stateEstimator_B.Reshapeu_h[0] + stateEstimator_B.Reshapeu_h[1] *\r\n    stateEstimator_P_g.B_Value_p[2]) + (stateEstimator_P_g.A_Value_c[0] *\r\n    stateEstimator_B.Conversion_j[0] + stateEstimator_B.Conversion_j[1] *\r\n    stateEstimator_P_g.A_Value_c[2])) + stateEstimator_B.Product3_m[0];\r\n  stateEstimator_DW.MemoryX_DSTATE_d[1] = ((stateEstimator_B.Reshapeu_h[0] *\r\n    stateEstimator_P_g.B_Value_p[1] + stateEstimator_B.Reshapeu_h[1] *\r\n    stateEstimator_P_g.B_Value_p[3]) + (stateEstimator_B.Conversion_j[0] *\r\n    stateEstimator_P_g.A_Value_c[1] + stateEstimator_B.Conversion_j[1] *\r\n    stateEstimator_P_g.A_Value_c[3])) + stateEstimator_B.Product3_m[1];\r\n\r\n  /* Update for Delay: '<S3>/Delay2' incorporates:\r\n   *  Reshape: '<S14>/Reshapexhat'\r\n   */\r\n  stateEstimator_DW.Delay2_DSTATE = stateEstimator_B.rtb_Add_j_idx_0;\r\n\r\n  /* Update for Delay: '<S14>/MemoryX' */\r\n  stateEstimator_DW.icLoad_p = false;\r\n  for (stateEstimator_B.cff = 0; stateEstimator_B.cff < 2; stateEstimator_B.cff\r\n       ++) {\r\n    /* Update for DiscreteFilter: '<S77>/IIRgyroz' */\r\n    stateEstimator_B.memOffset = stateEstimator_B.cff * 5;\r\n    stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 4] =\r\n      stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 3];\r\n    stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 3] =\r\n      stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 2];\r\n    stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 2] =\r\n      stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 1];\r\n    stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset + 1] =\r\n      stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset];\r\n    stateEstimator_DW.IIRgyroz_states[stateEstimator_B.memOffset] =\r\n      stateEstimator_DW.IIRgyroz_tmp[stateEstimator_B.cff];\r\n\r\n    /* Update for UnitDelay: '<S84>/UD' incorporates:\r\n     *  Sum: '<S84>/Diff'\r\n     *\r\n     * Block description for '<S84>/UD':\r\n     *\r\n     *  Store in Global RAM\r\n     *\r\n     * Block description for '<S84>/Diff':\r\n     *\r\n     *  Add in CPU\r\n     */\r\n    stateEstimator_DW.UD_DSTATE[stateEstimator_B.cff] =\r\n      stateEstimator_B.TSamp[stateEstimator_B.cff];\r\n\r\n    /* Product: '<S36>/A[k]*xhat[k|k-1]' incorporates:\r\n     *  Constant: '<S14>/A'\r\n     *  Delay: '<S14>/MemoryX'\r\n     */\r\n    stateEstimator_B.dv[stateEstimator_B.cff] =\r\n      stateEstimator_P_g.A_Value[stateEstimator_B.cff + 2] *\r\n      stateEstimator_DW.MemoryX_DSTATE[1] +\r\n      stateEstimator_P_g.A_Value[stateEstimator_B.cff] *\r\n      stateEstimator_DW.MemoryX_DSTATE[0];\r\n  }\r\n\r\n  /* Update for Delay: '<S14>/MemoryX' incorporates:\r\n   *  Constant: '<S14>/B'\r\n   *  Product: '<S36>/B[k]*u[k]'\r\n   *  Product: '<S66>/Product3'\r\n   *  Reshape: '<S14>/Reshapeu'\r\n   *  Sum: '<S36>/Add'\r\n   */\r\n  stateEstimator_DW.MemoryX_DSTATE[0] = (stateEstimator_P_g.B_Value[0] *\r\n    stateEstimator_B.Sum[2] + stateEstimator_B.dv[0]) +\r\n    stateEstimator_B.Product3[0];\r\n\r\n  /* Update for DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_states[2] =\r\n    stateEstimator_DW.soonarFilter_IIR_states[1];\r\n\r\n  /* Update for DiscreteFilter: '<S15>/pressureFilter_IIR' */\r\n  stateEstimator_DW.pressureFilter_IIR_states[2] =\r\n    stateEstimator_DW.pressureFilter_IIR_states[1];\r\n\r\n  /* Update for Delay: '<S1>/Delay' incorporates:\r\n   *  Delay: '<S74>/Delay'\r\n   */\r\n  stateEstimator_DW.Delay_DSTATE_p[0] = stateEstimator_DW.Delay_DSTATE[0];\r\n\r\n  /* Update for Delay: '<S14>/MemoryX' incorporates:\r\n   *  Constant: '<S14>/B'\r\n   *  Product: '<S36>/B[k]*u[k]'\r\n   *  Product: '<S66>/Product3'\r\n   *  Reshape: '<S14>/Reshapeu'\r\n   *  Sum: '<S36>/Add'\r\n   */\r\n  stateEstimator_DW.MemoryX_DSTATE[1] = (stateEstimator_P_g.B_Value[1] *\r\n    stateEstimator_B.Sum[2] + stateEstimator_B.dv[1]) +\r\n    stateEstimator_B.Product3[1];\r\n\r\n  /* Update for DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_states[1] =\r\n    stateEstimator_DW.soonarFilter_IIR_states[0];\r\n\r\n  /* Update for DiscreteFilter: '<S15>/pressureFilter_IIR' */\r\n  stateEstimator_DW.pressureFilter_IIR_states[1] =\r\n    stateEstimator_DW.pressureFilter_IIR_states[0];\r\n\r\n  /* Update for Delay: '<S1>/Delay' incorporates:\r\n   *  Delay: '<S74>/Delay'\r\n   */\r\n  stateEstimator_DW.Delay_DSTATE_p[1] = stateEstimator_DW.Delay_DSTATE[1];\r\n\r\n  /* Update for DiscreteFilter: '<S15>/soonarFilter_IIR' */\r\n  stateEstimator_DW.soonarFilter_IIR_states[0] =\r\n    stateEstimator_DW.soonarFilter_IIR_tmp;\r\n\r\n  /* Update for DiscreteFilter: '<S15>/pressureFilter_IIR' */\r\n  stateEstimator_DW.pressureFilter_IIR_states[0] =\r\n    stateEstimator_DW.pressureFilter_IIR_tmp;\r\n\r\n  /* Update for Delay: '<S149>/MemoryX' incorporates:\r\n   *  Constant: '<S149>/A'\r\n   *  Constant: '<S149>/B'\r\n   *  Product: '<S171>/A[k]*xhat[k|k-1]'\r\n   *  Product: '<S171>/B[k]*u[k]'\r\n   *  Sum: '<S171>/Add'\r\n   */\r\n  stateEstimator_DW.icLoad_g = false;\r\n  stateEstimator_DW.MemoryX_DSTATE_dl[0] = ((stateEstimator_P_g.B_Value_pu[0] *\r\n    stateEstimator_B.Reshapeu_i[0] + stateEstimator_B.Reshapeu_i[1] *\r\n    stateEstimator_P_g.B_Value_pu[2]) + (stateEstimator_P_g.A_Value_b[0] *\r\n    stateEstimator_B.Conversion_pu[0] + stateEstimator_B.Conversion_pu[1] *\r\n    stateEstimator_P_g.A_Value_b[2])) + stateEstimator_B.Product3_j[0];\r\n  stateEstimator_DW.MemoryX_DSTATE_dl[1] = ((stateEstimator_B.Reshapeu_i[0] *\r\n    stateEstimator_P_g.B_Value_pu[1] + stateEstimator_B.Reshapeu_i[1] *\r\n    stateEstimator_P_g.B_Value_pu[3]) + (stateEstimator_B.Conversion_pu[0] *\r\n    stateEstimator_P_g.A_Value_b[1] + stateEstimator_B.Conversion_pu[1] *\r\n    stateEstimator_P_g.A_Value_b[3])) + stateEstimator_B.Product3_j[1];\r\n\r\n  /* Update for DiscreteIntegrator: '<S75>/Integrator' */\r\n  stateEstimator_DW.Integrator_DSTATE[0] +=\r\n    stateEstimator_P_g.Integrator_gainval * stateEstimator_B.Product[0];\r\n  stateEstimator_DW.Integrator_DSTATE[1] +=\r\n    stateEstimator_P_g.Integrator_gainval * stateEstimator_B.Product[1];\r\n  stateEstimator_DW.Integrator_PrevResetState = (int8_T)\r\n    arg_controlModePosVSOrient_flagin;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid stateEstimator_o_initialize(const char_T **rt_errorStatus)\r\n{\r\n  RT_MODEL_stateEstimator_T *const stateEstimator_M =\r\n    &(stateEstimator_MdlrefDW.rtm);\r\n\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* non-finite (run-time) assignments */\r\n  stateEstimator_P_g.SaturationSonar_LowerSat = rtMinusInf;\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatusPointer(stateEstimator_M, rt_errorStatus);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"stateEstimator.h","type":"header","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\stateEstimator","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: stateEstimator.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_stateEstimator_h_\r\n#define RTW_HEADER_stateEstimator_h_\r\n#include <math.h>\r\n#ifndef stateEstimator_COMMON_INCLUDES_\r\n#define stateEstimator_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* stateEstimator_COMMON_INCLUDES_ */\r\n\r\n#include \"stateEstimator_types.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n#include \"rtGetInf.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Block states (default storage) for system '<S115>/MeasurementUpdate' */\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  boolean_T MeasurementUpdate_MODE;    /* '<S115>/MeasurementUpdate' */\r\n} DW_MeasurementUpdate_stateEstimator_T;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n/* Block states (default storage) for system '<S122>/Enabled Subsystem' */\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  boolean_T EnabledSubsystem_MODE;     /* '<S122>/Enabled Subsystem' */\r\n} DW_EnabledSubsystem_stateEstimator_T;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n/* Block signals for model 'stateEstimator' */\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  real32_T VectorConcatenate[9];       /* '<S13>/Vector Concatenate' */\r\n  real32_T Reshape9to3x3columnmajor[9];\r\n                                 /* '<S83>/Reshape (9) to [3x3] column-major' */\r\n  real32_T MathFunction_b[9];          /* '<S75>/Math Function' */\r\n  real32_T rtb_MathFunction_b_m[9];\r\n  real_T P[4];                         /* '<S64>/SqrtUsedFcn' */\r\n  real_T Sum[3];                       /* '<S3>/Sum' */\r\n  real_T rtb_VectorConcatenate_c[3];\r\n  real_T rtb_FIR_IMUaccel_k[3];\r\n  real32_T Sum1[6];                    /* '<S5>/Sum1' */\r\n  real32_T inverseIMU_gain[6];\r\n  real_T Product2[2];                  /* '<S68>/Product2' */\r\n  real_T Product3[2];                  /* '<S66>/Product3' */\r\n  real_T dv[2];\r\n  real32_T Conversion_p[4];            /* '<S139>/Conversion' */\r\n  real32_T Conversion_n4[4];           /* '<S138>/Conversion' */\r\n  real32_T Conversion_a[4];            /* '<S194>/Conversion' */\r\n  real32_T Conversion_g[4];            /* '<S195>/Conversion' */\r\n  real32_T Conversion_i[4];            /* '<S141>/Conversion' */\r\n  real32_T P_b[4];                     /* '<S144>/SqrtUsedFcn' */\r\n  real32_T Conversion_ao[4];           /* '<S197>/Conversion' */\r\n  real32_T P_k[4];                     /* '<S200>/SqrtUsedFcn' */\r\n  real32_T opticalFlowToVelocity_gain[3];/* '<S74>/opticalFlowToVelocity_gain' */\r\n  real32_T Product[3];                 /* '<S75>/Product' */\r\n  real32_T sincos_o1[3];               /* '<S16>/sincos' */\r\n  real32_T FIR_IMUaccel[3];            /* '<S5>/FIR_IMUaccel' */\r\n  real_T invertzaxisGain;              /* '<S3>/invertzaxisGain' */\r\n  real_T Sum_c;                        /* '<S66>/Sum' */\r\n  real_T rtb_Add_j_idx_0;\r\n  real_T unnamed_idx_0;\r\n  real_T unnamed_idx_1;\r\n  real32_T Merge[2];                   /* '<S2>/Merge' */\r\n  real32_T Product_p[2];               /* '<S76>/Product' */\r\n  real32_T Product2_e[2];              /* '<S204>/Product2' */\r\n  real32_T Product3_j[2];              /* '<S202>/Product3' */\r\n  real32_T Product2_k[2];              /* '<S148>/Product2' */\r\n  real32_T Product3_m[2];              /* '<S146>/Product3' */\r\n  real32_T TSamp[2];                   /* '<S84>/TSamp' */\r\n  real32_T Reshapey_o[2];              /* '<S78>/Reshapey' */\r\n  real32_T MemoryX_m[2];               /* '<S78>/MemoryX' */\r\n  real32_T Conversion_j[2];            /* '<S111>/Conversion' */\r\n  real32_T Reshapeu_h[2];              /* '<S78>/Reshapeu' */\r\n  real32_T Reshapey_a[2];              /* '<S149>/Reshapey' */\r\n  real32_T Conversion_pu[2];           /* '<S167>/Conversion' */\r\n  real32_T Reshapeu_i[2];              /* '<S149>/Reshapeu' */\r\n  real32_T MemoryX_f[2];               /* '<S149>/MemoryX' */\r\n  real32_T numAccum;\r\n  real32_T rtb_sincos_o2_idx_0;\r\n  real32_T rtb_sincos_o2_idx_1;\r\n  real32_T rtb_sincos_o2_idx_2;\r\n  real32_T rtb_DataTypeConversion1_idx_1;\r\n  int32_T denIdx;\r\n  int32_T cff;\r\n  int32_T memOffset;\r\n  int32_T i;\r\n  boolean_T Compare;                   /* '<S17>/Compare' */\r\n  boolean_T nicemeasurementornewupdateneeded;\r\n                                 /* '<S15>/nicemeasurementor newupdateneeded' */\r\n  boolean_T LogicalOperator3;          /* '<S77>/Logical Operator3' */\r\n  boolean_T LogicalOperator3_o;        /* '<S150>/Logical Operator3' */\r\n} B_stateEstimator_c_T;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n/* Block states (default storage) for model 'stateEstimator' */\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  real_T Delay2_DSTATE;                /* '<S3>/Delay2' */\r\n  real_T MemoryX_DSTATE[2];            /* '<S14>/MemoryX' */\r\n  real_T soonarFilter_IIR_states[3];   /* '<S15>/soonarFilter_IIR' */\r\n  real_T soonarFilter_IIR_tmp;         /* '<S15>/soonarFilter_IIR' */\r\n  real32_T IIR_IMUgyro_r_states[5];    /* '<S5>/IIR_IMUgyro_r' */\r\n  real32_T FIR_IMUaccel_states[15];    /* '<S5>/FIR_IMUaccel' */\r\n  real32_T MemoryX_DSTATE_d[2];        /* '<S78>/MemoryX' */\r\n  real32_T IIRgyroz_states[10];        /* '<S77>/IIRgyroz' */\r\n  real32_T UD_DSTATE[2];               /* '<S84>/UD' */\r\n  real32_T Delay_DSTATE[2];            /* '<S74>/Delay' */\r\n  real32_T pressureFilter_IIR_states[3];/* '<S15>/pressureFilter_IIR' */\r\n  real32_T Delay_DSTATE_p[2];          /* '<S1>/Delay' */\r\n  real32_T MemoryX_DSTATE_dl[2];       /* '<S149>/MemoryX' */\r\n  real32_T Delay_DSTATE_l[2];          /* '<S75>/Delay' */\r\n  real32_T Integrator_DSTATE[2];       /* '<S75>/Integrator' */\r\n  int32_T FIR_IMUaccel_circBuf;        /* '<S5>/FIR_IMUaccel' */\r\n  real32_T Memory_PreviousInput[3];    /* '<S2>/Memory' */\r\n  real32_T IIR_IMUgyro_r_tmp;          /* '<S5>/IIR_IMUgyro_r' */\r\n  real32_T IIRgyroz_tmp[2];            /* '<S77>/IIRgyroz' */\r\n  real32_T pressureFilter_IIR_tmp;     /* '<S15>/pressureFilter_IIR' */\r\n  int8_T Integrator_PrevResetState;    /* '<S75>/Integrator' */\r\n  boolean_T icLoad;                    /* '<S78>/MemoryX' */\r\n  boolean_T icLoad_p;                  /* '<S14>/MemoryX' */\r\n  boolean_T icLoad_g;                  /* '<S149>/MemoryX' */\r\n  boolean_T EnabledSubsystem_MODE;     /* '<S42>/Enabled Subsystem' */\r\n  boolean_T MeasurementUpdate_MODE;    /* '<S36>/MeasurementUpdate' */\r\n  DW_EnabledSubsystem_stateEstimator_T EnabledSubsystem_m;/* '<S178>/Enabled Subsystem' */\r\n  DW_MeasurementUpdate_stateEstimator_T MeasurementUpdate_b;/* '<S171>/MeasurementUpdate' */\r\n  DW_EnabledSubsystem_stateEstimator_T EnabledSubsystem_f;/* '<S122>/Enabled Subsystem' */\r\n  DW_MeasurementUpdate_stateEstimator_T MeasurementUpdate_e;/* '<S115>/MeasurementUpdate' */\r\n} DW_stateEstimator_f_T;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\n/* Parameters for system: '<S115>/MeasurementUpdate' */\r\nstruct P_MeasurementUpdate_stateEstimator_T_ {\r\n  real32_T Lykyhatkk1_Y0;              /* Computed Parameter: Lykyhatkk1_Y0\r\n                                        * Referenced by: '<S146>/L*(y[k]-yhat[k|k-1])'\r\n                                        */\r\n};\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\n/* Parameters for system: '<S122>/Enabled Subsystem' */\r\nstruct P_EnabledSubsystem_stateEstimator_T_ {\r\n  real32_T deltax_Y0;                  /* Computed Parameter: deltax_Y0\r\n                                        * Referenced by: '<S148>/deltax'\r\n                                        */\r\n};\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\n/* Parameters (default storage) */\r\nstruct P_stateEstimator_T_ {\r\n  real_T outlierBelowFloor_const;     /* Mask Parameter: outlierBelowFloor_const\r\n                                       * Referenced by: '<S17>/Constant'\r\n                                       */\r\n  real_T outlierJump_const;            /* Mask Parameter: outlierJump_const\r\n                                        * Referenced by: '<S72>/Constant'\r\n                                        */\r\n  real_T currentStateVeryOffsonarflt_const;\r\n                            /* Mask Parameter: currentStateVeryOffsonarflt_const\r\n                             * Referenced by: '<S71>/Constant'\r\n                             */\r\n  real_T currentEstimateVeryOffFromPressure_const;\r\n                     /* Mask Parameter: currentEstimateVeryOffFromPressure_const\r\n                      * Referenced by: '<S70>/Constant'\r\n                      */\r\n  real32_T DiscreteDerivative_ICPrevScaledInput;\r\n                         /* Mask Parameter: DiscreteDerivative_ICPrevScaledInput\r\n                          * Referenced by: '<S84>/UD'\r\n                          */\r\n  real32_T Checkifvalidvisualpositionestimateavailable_const;\r\n            /* Mask Parameter: Checkifvalidvisualpositionestimateavailable_const\r\n             * Referenced by: '<S210>/Constant'\r\n             */\r\n  real32_T CompareToConstant_const;   /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S6>/Constant'\r\n                                       */\r\n  real32_T CompareToConstant1_const; /* Mask Parameter: CompareToConstant1_const\r\n                                      * Referenced by: '<S7>/Constant'\r\n                                      */\r\n  real32_T maxp_const;                 /* Mask Parameter: maxp_const\r\n                                        * Referenced by: '<S87>/Constant'\r\n                                        */\r\n  real32_T maxq_const;                 /* Mask Parameter: maxq_const\r\n                                        * Referenced by: '<S89>/Constant'\r\n                                        */\r\n  real32_T maxw1_const;                /* Mask Parameter: maxw1_const\r\n                                        * Referenced by: '<S91>/Constant'\r\n                                        */\r\n  real32_T maxw2_const;                /* Mask Parameter: maxw2_const\r\n                                        * Referenced by: '<S92>/Constant'\r\n                                        */\r\n  real32_T maxdw1_const;               /* Mask Parameter: maxdw1_const\r\n                                        * Referenced by: '<S85>/Constant'\r\n                                        */\r\n  real32_T maxdw2_const;               /* Mask Parameter: maxdw2_const\r\n                                        * Referenced by: '<S86>/Constant'\r\n                                        */\r\n  real32_T maxp2_const;                /* Mask Parameter: maxp2_const\r\n                                        * Referenced by: '<S88>/Constant'\r\n                                        */\r\n  real32_T maxq2_const;                /* Mask Parameter: maxq2_const\r\n                                        * Referenced by: '<S90>/Constant'\r\n                                        */\r\n  real32_T maxw3_const;                /* Mask Parameter: maxw3_const\r\n                                        * Referenced by: '<S93>/Constant'\r\n                                        */\r\n  real32_T maxw4_const;                /* Mask Parameter: maxw4_const\r\n                                        * Referenced by: '<S94>/Constant'\r\n                                        */\r\n  real32_T minHeightforOF_const;       /* Mask Parameter: minHeightforOF_const\r\n                                        * Referenced by: '<S95>/Constant'\r\n                                        */\r\n  real32_T DeactivateAccelerationIfOFisnotusedduetolowaltitude_const;\r\n    /* Mask Parameter: DeactivateAccelerationIfOFisnotusedduetolowaltitude_const\r\n     * Referenced by: '<S79>/Constant'\r\n     */\r\n  real32_T donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto200_con;\r\n  /* Mask Parameter: donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto200_con\r\n   * Referenced by: '<S81>/Constant'\r\n   */\r\n  real32_T donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto2001_co;\r\n  /* Mask Parameter: donotuseaccifopticalflowneveravailableNoteOF60HzbutZOHto2001_co\r\n   * Referenced by: '<S82>/Constant'\r\n   */\r\n  real32_T maxp3_const;                /* Mask Parameter: maxp3_const\r\n                                        * Referenced by: '<S206>/Constant'\r\n                                        */\r\n  real32_T maxq3_const;                /* Mask Parameter: maxq3_const\r\n                                        * Referenced by: '<S207>/Constant'\r\n                                        */\r\n  real32_T checkifPosavailable_const;\r\n                                    /* Mask Parameter: checkifPosavailable_const\r\n                                     * Referenced by: '<S205>/Constant'\r\n                                     */\r\n  real32_T planarjumpsVISPOS_const;   /* Mask Parameter: planarjumpsVISPOS_const\r\n                                       * Referenced by: '<S208>/Constant'\r\n                                       */\r\n  real_T Lykyhatkk1_Y0;                /* Expression: 0\r\n                                        * Referenced by: '<S66>/L*(y[k]-yhat[k|k-1])'\r\n                                        */\r\n  real_T deltax_Y0;                    /* Expression: 0\r\n                                        * Referenced by: '<S68>/deltax'\r\n                                        */\r\n  real_T KalmanGainM_Value[4];         /* Expression: pInitialization.M\r\n                                        * Referenced by: '<S152>/KalmanGainM'\r\n                                        */\r\n  real_T KalmanGainM_Value_d[4];       /* Expression: pInitialization.M\r\n                                        * Referenced by: '<S96>/KalmanGainM'\r\n                                        */\r\n  real_T A_Value[4];                   /* Expression: pInitialization.A\r\n                                        * Referenced by: '<S14>/A'\r\n                                        */\r\n  real_T KalmanGainL_Value[4];         /* Expression: pInitialization.L\r\n                                        * Referenced by: '<S96>/KalmanGainL'\r\n                                        */\r\n  real_T KalmanGainL_Value_h[4];       /* Expression: pInitialization.L\r\n                                        * Referenced by: '<S152>/KalmanGainL'\r\n                                        */\r\n  real_T Delay2_InitialCondition;      /* Expression: 0\r\n                                        * Referenced by: '<S3>/Delay2'\r\n                                        */\r\n  real_T X0_Value[2];                  /* Expression: pInitialization.X0\r\n                                        * Referenced by: '<S14>/X0'\r\n                                        */\r\n  real_T SaturationSonar_LowerSat;     /* Expression: -inf\r\n                                        * Referenced by: '<S15>/SaturationSonar'\r\n                                        */\r\n  real_T soonarFilter_IIR_NumCoef[4];/* Expression: Estimator.alt.filterSonarNum\r\n                                      * Referenced by: '<S15>/soonarFilter_IIR'\r\n                                      */\r\n  real_T soonarFilter_IIR_DenCoef[4];/* Expression: Estimator.alt.filterSonarDen\r\n                                      * Referenced by: '<S15>/soonarFilter_IIR'\r\n                                      */\r\n  real_T soonarFilter_IIR_InitialStates;/* Expression: 0\r\n                                         * Referenced by: '<S15>/soonarFilter_IIR'\r\n                                         */\r\n  real_T KalmanGainM_Value_p[2];       /* Expression: pInitialization.M\r\n                                        * Referenced by: '<S18>/KalmanGainM'\r\n                                        */\r\n  real_T C_Value[2];                   /* Expression: pInitialization.C\r\n                                        * Referenced by: '<S14>/C'\r\n                                        */\r\n  real_T gravity_Value[3];             /* Expression: [0 0 -g]\r\n                                        * Referenced by: '<S76>/gravity'\r\n                                        */\r\n  real_T Constant_Value[3];            /* Expression: [0 0 g]\r\n                                        * Referenced by: '<S3>/Constant'\r\n                                        */\r\n  real_T gainaccinput_Gain;   /* Expression: Estimator.pos.accelerationInputGain\r\n                               * Referenced by: '<S76>/gainaccinput'\r\n                               */\r\n  real_T D_Value;                      /* Expression: pInitialization.D\r\n                                        * Referenced by: '<S14>/D'\r\n                                        */\r\n  real_T KalmanGainL_Value_e[2];       /* Expression: pInitialization.L\r\n                                        * Referenced by: '<S18>/KalmanGainL'\r\n                                        */\r\n  real_T B_Value[2];                   /* Expression: pInitialization.B\r\n                                        * Referenced by: '<S14>/B'\r\n                                        */\r\n  real_T CovarianceZ_Value[4];         /* Expression: pInitialization.Z\r\n                                        * Referenced by: '<S18>/CovarianceZ'\r\n                                        */\r\n  real_T P0_Value[4];                  /* Expression: pInitialization.P0\r\n                                        * Referenced by: '<S14>/P0'\r\n                                        */\r\n  real_T CovarianceZ_Value_b[4];       /* Expression: pInitialization.Z\r\n                                        * Referenced by: '<S96>/CovarianceZ'\r\n                                        */\r\n  real_T CovarianceZ_Value_l[4];       /* Expression: pInitialization.Z\r\n                                        * Referenced by: '<S152>/CovarianceZ'\r\n                                        */\r\n  real_T G_Value[2];                   /* Expression: pInitialization.G\r\n                                        * Referenced by: '<S14>/G'\r\n                                        */\r\n  real_T H_Value;                      /* Expression: pInitialization.H\r\n                                        * Referenced by: '<S14>/H'\r\n                                        */\r\n  real_T N_Value;                      /* Expression: pInitialization.N\r\n                                        * Referenced by: '<S14>/N'\r\n                                        */\r\n  real_T Q_Value;                      /* Expression: pInitialization.Q\r\n                                        * Referenced by: '<S14>/Q'\r\n                                        */\r\n  real_T R_Value;                      /* Expression: pInitialization.R\r\n                                        * Referenced by: '<S14>/R'\r\n                                        */\r\n  real32_T Gain1_Gain;                 /* Computed Parameter: Gain1_Gain\r\n                                        * Referenced by: '<S8>/Gain1'\r\n                                        */\r\n  real32_T Gain_Gain;                  /* Computed Parameter: Gain_Gain\r\n                                        * Referenced by: '<S8>/Gain'\r\n                                        */\r\n  real32_T Gain2_Gain;                 /* Computed Parameter: Gain2_Gain\r\n                                        * Referenced by: '<S8>/Gain2'\r\n                                        */\r\n  real32_T Gain3_Gain;                 /* Computed Parameter: Gain3_Gain\r\n                                        * Referenced by: '<S8>/Gain3'\r\n                                        */\r\n  real32_T Gain4_Gain;                 /* Computed Parameter: Gain4_Gain\r\n                                        * Referenced by: '<S8>/Gain4'\r\n                                        */\r\n  real32_T Gain_Gain_i;                /* Computed Parameter: Gain_Gain_i\r\n                                        * Referenced by: '<S9>/Gain'\r\n                                        */\r\n  real32_T Gain1_Gain_k;               /* Computed Parameter: Gain1_Gain_k\r\n                                        * Referenced by: '<S9>/Gain1'\r\n                                        */\r\n  real32_T Constant_Value_i;           /* Expression: single(0)\r\n                                        * Referenced by: '<S12>/Constant'\r\n                                        */\r\n  real32_T Memory_InitialCondition[3];\r\n                        /* Expression: single(Estimator.complementaryFilterInit)\r\n                         * Referenced by: '<S2>/Memory'\r\n                         */\r\n  real32_T Gain_Gain_c;                /* Computed Parameter: Gain_Gain_c\r\n                                        * Referenced by: '<S12>/Gain'\r\n                                        */\r\n  real32_T Bias_Bias[6];               /* Computed Parameter: Bias_Bias\r\n                                        * Referenced by: '<S5>/Bias'\r\n                                        */\r\n  real32_T inverseIMU_gain_Gain[6];  /* Computed Parameter: inverseIMU_gain_Gain\r\n                                      * Referenced by: '<S5>/inverseIMU_gain'\r\n                                      */\r\n  real32_T IIR_IMUgyro_r_NumCoef[6];/* Computed Parameter: IIR_IMUgyro_r_NumCoef\r\n                                     * Referenced by: '<S5>/IIR_IMUgyro_r'\r\n                                     */\r\n  real32_T IIR_IMUgyro_r_DenCoef[6];/* Computed Parameter: IIR_IMUgyro_r_DenCoef\r\n                                     * Referenced by: '<S5>/IIR_IMUgyro_r'\r\n                                     */\r\n  real32_T IIR_IMUgyro_r_InitialStates;\r\n                              /* Computed Parameter: IIR_IMUgyro_r_InitialStates\r\n                               * Referenced by: '<S5>/IIR_IMUgyro_r'\r\n                               */\r\n  real32_T gyro_sensitivity_Gain;   /* Computed Parameter: gyro_sensitivity_Gain\r\n                                     * Referenced by: '<S2>/gyro_sensitivity'\r\n                                     */\r\n  real32_T FIR_IMUaccel_InitialStates;\r\n                               /* Computed Parameter: FIR_IMUaccel_InitialStates\r\n                                * Referenced by: '<S5>/FIR_IMUaccel'\r\n                                */\r\n  real32_T FIR_IMUaccel_Coefficients[6];\r\n                                /* Computed Parameter: FIR_IMUaccel_Coefficients\r\n                                 * Referenced by: '<S5>/FIR_IMUaccel'\r\n                                 */\r\n  real32_T Constant_Value_n;           /* Computed Parameter: Constant_Value_n\r\n                                        * Referenced by: '<S2>/Constant'\r\n                                        */\r\n  real32_T Merge_InitialOutput;       /* Computed Parameter: Merge_InitialOutput\r\n                                       * Referenced by: '<S2>/Merge'\r\n                                       */\r\n  real32_T C_Value_p[4];               /* Computed Parameter: C_Value_p\r\n                                        * Referenced by: '<S149>/C'\r\n                                        */\r\n  real32_T C_Value_f[4];               /* Computed Parameter: C_Value_f\r\n                                        * Referenced by: '<S78>/C'\r\n                                        */\r\n  real32_T A_Value_c[4];               /* Computed Parameter: A_Value_c\r\n                                        * Referenced by: '<S78>/A'\r\n                                        */\r\n  real32_T B_Value_p[4];               /* Computed Parameter: B_Value_p\r\n                                        * Referenced by: '<S78>/B'\r\n                                        */\r\n  real32_T D_Value_f[4];               /* Computed Parameter: D_Value_f\r\n                                        * Referenced by: '<S78>/D'\r\n                                        */\r\n  real32_T A_Value_b[4];               /* Computed Parameter: A_Value_b\r\n                                        * Referenced by: '<S149>/A'\r\n                                        */\r\n  real32_T B_Value_pu[4];              /* Computed Parameter: B_Value_pu\r\n                                        * Referenced by: '<S149>/B'\r\n                                        */\r\n  real32_T D_Value_b[4];               /* Computed Parameter: D_Value_b\r\n                                        * Referenced by: '<S149>/D'\r\n                                        */\r\n  real32_T X0_Value_e[2];              /* Computed Parameter: X0_Value_e\r\n                                        * Referenced by: '<S78>/X0'\r\n                                        */\r\n  real32_T IIRgyroz_NumCoef[6];        /* Computed Parameter: IIRgyroz_NumCoef\r\n                                        * Referenced by: '<S77>/IIRgyroz'\r\n                                        */\r\n  real32_T IIRgyroz_DenCoef[6];        /* Computed Parameter: IIRgyroz_DenCoef\r\n                                        * Referenced by: '<S77>/IIRgyroz'\r\n                                        */\r\n  real32_T IIRgyroz_InitialStates; /* Computed Parameter: IIRgyroz_InitialStates\r\n                                    * Referenced by: '<S77>/IIRgyroz'\r\n                                    */\r\n  real32_T TSamp_WtEt;                 /* Computed Parameter: TSamp_WtEt\r\n                                        * Referenced by: '<S84>/TSamp'\r\n                                        */\r\n  real32_T opticalFlowToVelocity_gain_Gain;\r\n                          /* Computed Parameter: opticalFlowToVelocity_gain_Gain\r\n                           * Referenced by: '<S74>/opticalFlowToVelocity_gain'\r\n                           */\r\n  real32_T Delay_InitialCondition; /* Computed Parameter: Delay_InitialCondition\r\n                                    * Referenced by: '<S74>/Delay'\r\n                                    */\r\n  real32_T invertzaxisGain_Gain;     /* Computed Parameter: invertzaxisGain_Gain\r\n                                      * Referenced by: '<S3>/invertzaxisGain'\r\n                                      */\r\n  real32_T prsToAltGain_Gain;          /* Computed Parameter: prsToAltGain_Gain\r\n                                        * Referenced by: '<S3>/prsToAltGain'\r\n                                        */\r\n  real32_T pressureFilter_IIR_NumCoef[4];\r\n                               /* Computed Parameter: pressureFilter_IIR_NumCoef\r\n                                * Referenced by: '<S15>/pressureFilter_IIR'\r\n                                */\r\n  real32_T pressureFilter_IIR_DenCoef[4];\r\n                               /* Computed Parameter: pressureFilter_IIR_DenCoef\r\n                                * Referenced by: '<S15>/pressureFilter_IIR'\r\n                                */\r\n  real32_T pressureFilter_IIR_InitialStates;\r\n                         /* Computed Parameter: pressureFilter_IIR_InitialStates\r\n                          * Referenced by: '<S15>/pressureFilter_IIR'\r\n                          */\r\n  real32_T Delay_InitialCondition_b;\r\n                                 /* Computed Parameter: Delay_InitialCondition_b\r\n                                  * Referenced by: '<S1>/Delay'\r\n                                  */\r\n  real32_T X0_Value_j[2];              /* Computed Parameter: X0_Value_j\r\n                                        * Referenced by: '<S149>/X0'\r\n                                        */\r\n  real32_T Constant_Value_e;           /* Computed Parameter: Constant_Value_e\r\n                                        * Referenced by: '<S150>/Constant'\r\n                                        */\r\n  real32_T Delay_InitialCondition_n;\r\n                                 /* Computed Parameter: Delay_InitialCondition_n\r\n                                  * Referenced by: '<S75>/Delay'\r\n                                  */\r\n  real32_T Integrator_gainval;         /* Computed Parameter: Integrator_gainval\r\n                                        * Referenced by: '<S75>/Integrator'\r\n                                        */\r\n  real32_T Integrator_IC;              /* Computed Parameter: Integrator_IC\r\n                                        * Referenced by: '<S75>/Integrator'\r\n                                        */\r\n  real32_T UseIPPosSwitch_Threshold;\r\n                                 /* Computed Parameter: UseIPPosSwitch_Threshold\r\n                                  * Referenced by: '<S75>/UseIPPosSwitch'\r\n                                  */\r\n  real32_T P0_Value_m[4];              /* Computed Parameter: P0_Value_m\r\n                                        * Referenced by: '<S78>/P0'\r\n                                        */\r\n  real32_T G_Value_h[4];               /* Computed Parameter: G_Value_h\r\n                                        * Referenced by: '<S78>/G'\r\n                                        */\r\n  real32_T H_Value_c[4];               /* Computed Parameter: H_Value_c\r\n                                        * Referenced by: '<S78>/H'\r\n                                        */\r\n  real32_T N_Value_g[4];               /* Computed Parameter: N_Value_g\r\n                                        * Referenced by: '<S78>/N'\r\n                                        */\r\n  real32_T Q_Value_f[4];               /* Computed Parameter: Q_Value_f\r\n                                        * Referenced by: '<S78>/Q'\r\n                                        */\r\n  real32_T R_Value_k[4];               /* Computed Parameter: R_Value_k\r\n                                        * Referenced by: '<S78>/R'\r\n                                        */\r\n  real32_T P0_Value_h[4];              /* Computed Parameter: P0_Value_h\r\n                                        * Referenced by: '<S149>/P0'\r\n                                        */\r\n  real32_T G_Value_p[4];               /* Computed Parameter: G_Value_p\r\n                                        * Referenced by: '<S149>/G'\r\n                                        */\r\n  real32_T H_Value_d[4];               /* Computed Parameter: H_Value_d\r\n                                        * Referenced by: '<S149>/H'\r\n                                        */\r\n  real32_T N_Value_j[4];               /* Computed Parameter: N_Value_j\r\n                                        * Referenced by: '<S149>/N'\r\n                                        */\r\n  real32_T Q_Value_n[4];               /* Computed Parameter: Q_Value_n\r\n                                        * Referenced by: '<S149>/Q'\r\n                                        */\r\n  real32_T R_Value_kf[4];              /* Computed Parameter: R_Value_kf\r\n                                        * Referenced by: '<S149>/R'\r\n                                        */\r\n  boolean_T isSqrtUsed_Value;          /* Expression: pInitialization.isSqrtUsed\r\n                                        * Referenced by: '<S64>/isSqrtUsed'\r\n                                        */\r\n  boolean_T isSqrtUsed_Value_l;        /* Expression: pInitialization.isSqrtUsed\r\n                                        * Referenced by: '<S144>/isSqrtUsed'\r\n                                        */\r\n  boolean_T isSqrtUsed_Value_h;        /* Expression: pInitialization.isSqrtUsed\r\n                                        * Referenced by: '<S200>/isSqrtUsed'\r\n                                        */\r\n  P_EnabledSubsystem_stateEstimator_T EnabledSubsystem_m;/* '<S178>/Enabled Subsystem' */\r\n  P_MeasurementUpdate_stateEstimator_T MeasurementUpdate_b;/* '<S171>/MeasurementUpdate' */\r\n  P_EnabledSubsystem_stateEstimator_T EnabledSubsystem_f;/* '<S122>/Enabled Subsystem' */\r\n  P_MeasurementUpdate_stateEstimator_T MeasurementUpdate_e;/* '<S115>/MeasurementUpdate' */\r\n};\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_stateEstimator_T {\r\n  const char_T **errorStatus;\r\n};\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\ntypedef struct {\r\n  RT_MODEL_stateEstimator_T rtm;\r\n} MdlrefDW_stateEstimator_T;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n/* Model block global parameters (default storage) */\r\nextern struct_pAcs5k38eV6MpgiqrKAV4 rtP_Sensors;/* Variable: Sensors\r\n                                                 * Referenced by:\r\n                                                 *   '<S15>/SaturationSonar'\r\n                                                 *   '<S69>/Constant'\r\n                                                 */\r\nextern void stateEstimator_Init(void);\r\nextern void stateEstimator_Disable(void);\r\nextern void stateEstimator_run(const boolean_T arg_controlModePosVSOrient_flagin,\r\n  const sensordata_t *arg_sensordata_datin, const real32_T arg_usePosVIS_flagin,\r\n  const real32_T arg_opticalFlow_datin[3], const real32_T arg_posVIS_datin[4],\r\n  statesEstim_t *arg_states_estimout, const real32_T\r\n  arg_sensorCalibration_datin[8]);\r\n\r\n/* Model reference registration function */\r\nextern void stateEstimator_o_initialize(const char_T **rt_errorStatus);\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\nextern void stateEstimator_SqrtUsedFcn(const real32_T rtu_u[4], boolean_T\r\n  rtu_isSqrtUsed, real32_T rty_P[4]);\r\nextern void stateEstimator_MeasurementUpdate_Init(real32_T rty_Lykyhatkk1[2],\r\n  P_MeasurementUpdate_stateEstimator_T *localP);\r\nextern void stateEstimator_MeasurementUpdate_Disable(real32_T rty_Lykyhatkk1[2],\r\n  DW_MeasurementUpdate_stateEstimator_T *localDW,\r\n  P_MeasurementUpdate_stateEstimator_T *localP);\r\nextern void stateEstimator_MeasurementUpdate(boolean_T rtu_Enable, const\r\n  real32_T rtu_Lk[4], const real32_T rtu_yk[2], const real32_T rtu_Ck[4], const\r\n  real32_T rtu_xhatkk1[2], const real32_T rtu_Dk[4], const real32_T rtu_uk[2],\r\n  real32_T rty_Lykyhatkk1[2], DW_MeasurementUpdate_stateEstimator_T *localDW,\r\n  P_MeasurementUpdate_stateEstimator_T *localP);\r\nextern void stateEstimator_EnabledSubsystem_Init(real32_T rty_deltax[2],\r\n  P_EnabledSubsystem_stateEstimator_T *localP);\r\nextern void stateEstimator_EnabledSubsystem_Disable(real32_T rty_deltax[2],\r\n  DW_EnabledSubsystem_stateEstimator_T *localDW,\r\n  P_EnabledSubsystem_stateEstimator_T *localP);\r\nextern void stateEstimator_EnabledSubsystem(boolean_T rtu_Enable, const real32_T\r\n  rtu_Mk[4], const real32_T rtu_Ck[4], const real32_T rtu_yk[2], const real32_T\r\n  rtu_xhatkk1[2], real32_T rty_deltax[2], DW_EnabledSubsystem_stateEstimator_T\r\n  *localDW, P_EnabledSubsystem_stateEstimator_T *localP);\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\nextern MdlrefDW_stateEstimator_T stateEstimator_MdlrefDW;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\n/* Block signals (default storage) */\r\nextern B_stateEstimator_c_T stateEstimator_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_stateEstimator_f_T stateEstimator_DW;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'stateEstimator'\r\n * '<S1>'   : 'stateEstimator/State Estimator'\r\n * '<S2>'   : 'stateEstimator/State Estimator/Complementary Filter'\r\n * '<S3>'   : 'stateEstimator/State Estimator/EstimatorAltitude'\r\n * '<S4>'   : 'stateEstimator/State Estimator/EstimatorXYPosition'\r\n * '<S5>'   : 'stateEstimator/State Estimator/SensorPreprocessing'\r\n * '<S6>'   : 'stateEstimator/State Estimator/Complementary Filter/Compare To Constant'\r\n * '<S7>'   : 'stateEstimator/State Estimator/Complementary Filter/Compare To Constant1'\r\n * '<S8>'   : 'stateEstimator/State Estimator/Complementary Filter/If Action Subsystem'\r\n * '<S9>'   : 'stateEstimator/State Estimator/Complementary Filter/If Action Subsystem1'\r\n * '<S10>'  : 'stateEstimator/State Estimator/Complementary Filter/If Action Subsystem2'\r\n * '<S11>'  : 'stateEstimator/State Estimator/Complementary Filter/If Action Subsystem3'\r\n * '<S12>'  : 'stateEstimator/State Estimator/Complementary Filter/Wbe'\r\n * '<S13>'  : 'stateEstimator/State Estimator/Complementary Filter/Wbe/Create 3x3 Matrix'\r\n * '<S14>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude'\r\n * '<S15>'  : 'stateEstimator/State Estimator/EstimatorAltitude/OutlierHandling'\r\n * '<S16>'  : 'stateEstimator/State Estimator/EstimatorAltitude/Rotation Angles to Direction Cosine Matrix'\r\n * '<S17>'  : 'stateEstimator/State Estimator/EstimatorAltitude/outlierBelowFloor'\r\n * '<S18>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculatePL'\r\n * '<S19>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculateYhat'\r\n * '<S20>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CovarianceOutputConfigurator'\r\n * '<S21>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionA'\r\n * '<S22>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionB'\r\n * '<S23>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionC'\r\n * '<S24>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionD'\r\n * '<S25>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionG'\r\n * '<S26>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionH'\r\n * '<S27>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionN'\r\n * '<S28>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionP'\r\n * '<S29>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionP0'\r\n * '<S30>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionQ'\r\n * '<S31>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionR'\r\n * '<S32>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionX'\r\n * '<S33>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionX0'\r\n * '<S34>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/DataTypeConversionu'\r\n * '<S35>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/MemoryP'\r\n * '<S36>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/Observer'\r\n * '<S37>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/ReducedQRN'\r\n * '<S38>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/Reshapeyhat'\r\n * '<S39>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/ScalarExpansionP0'\r\n * '<S40>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/ScalarExpansionQ'\r\n * '<S41>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/ScalarExpansionR'\r\n * '<S42>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/UseCurrentEstimator'\r\n * '<S43>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkA'\r\n * '<S44>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkB'\r\n * '<S45>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkC'\r\n * '<S46>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkD'\r\n * '<S47>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkEnable'\r\n * '<S48>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkG'\r\n * '<S49>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkH'\r\n * '<S50>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkN'\r\n * '<S51>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkP0'\r\n * '<S52>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkQ'\r\n * '<S53>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkR'\r\n * '<S54>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkReset'\r\n * '<S55>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checkX0'\r\n * '<S56>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checku'\r\n * '<S57>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/checky'\r\n * '<S58>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculatePL/DataTypeConversionL'\r\n * '<S59>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculatePL/DataTypeConversionM'\r\n * '<S60>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculatePL/DataTypeConversionP'\r\n * '<S61>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculatePL/DataTypeConversionZ'\r\n * '<S62>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculatePL/Ground'\r\n * '<S63>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CalculateYhat/Ground'\r\n * '<S64>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CovarianceOutputConfigurator/decideOutput'\r\n * '<S65>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/CovarianceOutputConfigurator/decideOutput/SqrtUsedFcn'\r\n * '<S66>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/Observer/MeasurementUpdate'\r\n * '<S67>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/ReducedQRN/Ground'\r\n * '<S68>'  : 'stateEstimator/State Estimator/EstimatorAltitude/KalmanFilter_altitude/UseCurrentEstimator/Enabled Subsystem'\r\n * '<S69>'  : 'stateEstimator/State Estimator/EstimatorAltitude/OutlierHandling/checkForMinAltitude'\r\n * '<S70>'  : 'stateEstimator/State Estimator/EstimatorAltitude/OutlierHandling/currentEstimateVeryOffFromPressure'\r\n * '<S71>'  : 'stateEstimator/State Estimator/EstimatorAltitude/OutlierHandling/currentStateVeryOffsonarflt'\r\n * '<S72>'  : 'stateEstimator/State Estimator/EstimatorAltitude/OutlierHandling/outlierJump'\r\n * '<S73>'  : 'stateEstimator/State Estimator/EstimatorAltitude/Rotation Angles to Direction Cosine Matrix/Create 3x3 Matrix'\r\n * '<S74>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity'\r\n * '<S75>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition'\r\n * '<S76>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/AccelerationHandling'\r\n * '<S77>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling'\r\n * '<S78>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy'\r\n * '<S79>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/AccelerationHandling/Deactivate Acceleration If OF is not used due to low altitude'\r\n * '<S80>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/AccelerationHandling/Rotation Angles to Direction Cosine Matrix'\r\n * '<S81>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/AccelerationHandling/do not use acc if optical flow never available (Note OF@60Hz but ZOH to 200!)'\r\n * '<S82>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/AccelerationHandling/do not use acc if optical flow never available (Note OF@60Hz but ZOH to 200!)1'\r\n * '<S83>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/AccelerationHandling/Rotation Angles to Direction Cosine Matrix/Create 3x3 Matrix'\r\n * '<S84>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/DiscreteDerivative'\r\n * '<S85>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxdw1'\r\n * '<S86>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxdw2'\r\n * '<S87>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxp'\r\n * '<S88>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxp2'\r\n * '<S89>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxq'\r\n * '<S90>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxq2'\r\n * '<S91>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxw1'\r\n * '<S92>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxw2'\r\n * '<S93>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxw3'\r\n * '<S94>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/maxw4'\r\n * '<S95>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/DataHandling/minHeightforOF'\r\n * '<S96>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculatePL'\r\n * '<S97>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculateYhat'\r\n * '<S98>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CovarianceOutputConfigurator'\r\n * '<S99>'  : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionA'\r\n * '<S100>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionB'\r\n * '<S101>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionC'\r\n * '<S102>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionD'\r\n * '<S103>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionG'\r\n * '<S104>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionH'\r\n * '<S105>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionN'\r\n * '<S106>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionP'\r\n * '<S107>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionP0'\r\n * '<S108>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionQ'\r\n * '<S109>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionR'\r\n * '<S110>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionReset'\r\n * '<S111>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionX'\r\n * '<S112>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionX0'\r\n * '<S113>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/DataTypeConversionu'\r\n * '<S114>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/MemoryP'\r\n * '<S115>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/Observer'\r\n * '<S116>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/ReducedQRN'\r\n * '<S117>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/Reset'\r\n * '<S118>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/Reshapeyhat'\r\n * '<S119>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/ScalarExpansionP0'\r\n * '<S120>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/ScalarExpansionQ'\r\n * '<S121>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/ScalarExpansionR'\r\n * '<S122>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/UseCurrentEstimator'\r\n * '<S123>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkA'\r\n * '<S124>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkB'\r\n * '<S125>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkC'\r\n * '<S126>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkD'\r\n * '<S127>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkEnable'\r\n * '<S128>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkG'\r\n * '<S129>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkH'\r\n * '<S130>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkN'\r\n * '<S131>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkP0'\r\n * '<S132>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkQ'\r\n * '<S133>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkR'\r\n * '<S134>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkReset'\r\n * '<S135>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checkX0'\r\n * '<S136>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checku'\r\n * '<S137>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/checky'\r\n * '<S138>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculatePL/DataTypeConversionL'\r\n * '<S139>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculatePL/DataTypeConversionM'\r\n * '<S140>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculatePL/DataTypeConversionP'\r\n * '<S141>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculatePL/DataTypeConversionZ'\r\n * '<S142>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculatePL/Ground'\r\n * '<S143>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CalculateYhat/Ground'\r\n * '<S144>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CovarianceOutputConfigurator/decideOutput'\r\n * '<S145>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/CovarianceOutputConfigurator/decideOutput/SqrtUsedFcn'\r\n * '<S146>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/Observer/MeasurementUpdate'\r\n * '<S147>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/ReducedQRN/Ground'\r\n * '<S148>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorVelocity/KalmanFilter_dxdy/UseCurrentEstimator/Enabled Subsystem'\r\n * '<S149>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy'\r\n * '<S150>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/OutlierHandling'\r\n * '<S151>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/Rotation Angles to Direction Cosine Matrix'\r\n * '<S152>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculatePL'\r\n * '<S153>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculateYhat'\r\n * '<S154>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CovarianceOutputConfigurator'\r\n * '<S155>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionA'\r\n * '<S156>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionB'\r\n * '<S157>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionC'\r\n * '<S158>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionD'\r\n * '<S159>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionG'\r\n * '<S160>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionH'\r\n * '<S161>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionN'\r\n * '<S162>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionP'\r\n * '<S163>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionP0'\r\n * '<S164>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionQ'\r\n * '<S165>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionR'\r\n * '<S166>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionReset'\r\n * '<S167>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionX'\r\n * '<S168>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionX0'\r\n * '<S169>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/DataTypeConversionu'\r\n * '<S170>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/MemoryP'\r\n * '<S171>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/Observer'\r\n * '<S172>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/ReducedQRN'\r\n * '<S173>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/Reset'\r\n * '<S174>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/Reshapeyhat'\r\n * '<S175>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/ScalarExpansionP0'\r\n * '<S176>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/ScalarExpansionQ'\r\n * '<S177>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/ScalarExpansionR'\r\n * '<S178>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/UseCurrentEstimator'\r\n * '<S179>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkA'\r\n * '<S180>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkB'\r\n * '<S181>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkC'\r\n * '<S182>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkD'\r\n * '<S183>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkEnable'\r\n * '<S184>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkG'\r\n * '<S185>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkH'\r\n * '<S186>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkN'\r\n * '<S187>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkP0'\r\n * '<S188>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkQ'\r\n * '<S189>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkR'\r\n * '<S190>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkReset'\r\n * '<S191>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checkX0'\r\n * '<S192>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checku'\r\n * '<S193>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/checky'\r\n * '<S194>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculatePL/DataTypeConversionL'\r\n * '<S195>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculatePL/DataTypeConversionM'\r\n * '<S196>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculatePL/DataTypeConversionP'\r\n * '<S197>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculatePL/DataTypeConversionZ'\r\n * '<S198>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculatePL/Ground'\r\n * '<S199>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CalculateYhat/Ground'\r\n * '<S200>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CovarianceOutputConfigurator/decideOutput'\r\n * '<S201>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/CovarianceOutputConfigurator/decideOutput/SqrtUsedFcn'\r\n * '<S202>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/Observer/MeasurementUpdate'\r\n * '<S203>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/ReducedQRN/Ground'\r\n * '<S204>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/KalmanFilter_posxy/UseCurrentEstimator/Enabled Subsystem'\r\n * '<S205>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/OutlierHandling/checkifPosavailable'\r\n * '<S206>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/OutlierHandling/maxp3'\r\n * '<S207>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/OutlierHandling/maxq3'\r\n * '<S208>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/OutlierHandling/planarjumpsVISPOS'\r\n * '<S209>' : 'stateEstimator/State Estimator/EstimatorXYPosition/EstimatorXYPosition/Rotation Angles to Direction Cosine Matrix/Create 3x3 Matrix'\r\n * '<S210>' : 'stateEstimator/State Estimator/SensorPreprocessing/Check if valid visual position estimate available'\r\n */\r\n#endif                                 /* RTW_HEADER_stateEstimator_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"stateEstimator_private.h","type":"header","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\stateEstimator","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: stateEstimator_private.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_stateEstimator_private_h_\r\n#define RTW_HEADER_stateEstimator_private_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         (*((rtm)->errorStatus))\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    (*((rtm)->errorStatus) = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatusPointer\r\n#define rtmGetErrorStatusPointer(rtm)  (rtm)->errorStatus\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatusPointer\r\n#define rtmSetErrorStatusPointer(rtm, val) ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef stateEstimator_MDLREF_HIDE_CHILD_\r\n\r\nextern P_stateEstimator_T stateEstimator_P_g;\r\n\r\n#endif                                 /*stateEstimator_MDLREF_HIDE_CHILD_*/\r\n#endif                                /* RTW_HEADER_stateEstimator_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"stateEstimator_types.h","type":"header","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\stateEstimator","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: stateEstimator_types.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_stateEstimator_types_h_\r\n#define RTW_HEADER_stateEstimator_types_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Model Code Variants */\r\n#ifndef DEFINED_TYPEDEF_FOR_sensordata_t_\r\n#define DEFINED_TYPEDEF_FOR_sensordata_t_\r\n\r\ntypedef struct {\r\n  real32_T ddx;\r\n  real32_T ddy;\r\n  real32_T ddz;\r\n  real32_T p;\r\n  real32_T q;\r\n  real32_T r;\r\n  real32_T altitude_sonar;\r\n  real32_T prs;\r\n  real32_T vbat_V;\r\n  uint32_T vbat_percentage;\r\n} sensordata_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_statesEstim_t_\r\n#define DEFINED_TYPEDEF_FOR_statesEstim_t_\r\n\r\ntypedef struct {\r\n  real32_T X;\r\n  real32_T Y;\r\n  real32_T Z;\r\n  real32_T yaw;\r\n  real32_T pitch;\r\n  real32_T roll;\r\n  real32_T dx;\r\n  real32_T dy;\r\n  real32_T dz;\r\n  real32_T p;\r\n  real32_T q;\r\n  real32_T r;\r\n} statesEstim_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_hE1099BMemg5OfzqcWAA6G_\r\n#define DEFINED_TYPEDEF_FOR_struct_hE1099BMemg5OfzqcWAA6G_\r\n\r\ntypedef struct {\r\n  real_T date[6];\r\n  real_T posLLA[3];\r\n  real_T posNED[3];\r\n  real_T vb[3];\r\n  real_T euler[3];\r\n  real_T angRates[3];\r\n} struct_hE1099BMemg5OfzqcWAA6G;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eF5OUT33sX0T9pzS8027m_\r\n#define DEFINED_TYPEDEF_FOR_struct_eF5OUT33sX0T9pzS8027m_\r\n\r\ntypedef struct {\r\n  real_T cg[3];\r\n  real_T location[3];\r\n  real_T accNatFreq;\r\n  real_T accDamping;\r\n  real_T accScaleCross[9];\r\n  real_T accBias[3];\r\n  real_T accLimits[6];\r\n  real_T gyroNatFreq;\r\n  real_T gyroDamping;\r\n  real_T gyroScaleCross[9];\r\n  real_T gyroBias[3];\r\n  real_T gyroGBias[3];\r\n  real_T gyroLimits[6];\r\n  real_T noiseSeeds[6];\r\n  real_T noiseWeights[6];\r\n  real_T noisePower[6];\r\n} struct_eF5OUT33sX0T9pzS8027m;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_FIfaVnupBjYAxo1EdNiDlF_\r\n#define DEFINED_TYPEDEF_FOR_struct_FIfaVnupBjYAxo1EdNiDlF_\r\n\r\ntypedef struct {\r\n  real_T noisePower;\r\n  real_T noiseSeeds;\r\n} struct_FIfaVnupBjYAxo1EdNiDlF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eFnp8sKFNJLN84XLbLzaFF_\r\n#define DEFINED_TYPEDEF_FOR_struct_eFnp8sKFNJLN84XLbLzaFF_\r\n\r\ntypedef struct {\r\n  real_T posVISNoVisionAvail[4];\r\n  real_T usePosVISFlag;\r\n  real_T batteryStatus[2];\r\n} struct_eFnp8sKFNJLN84XLbLzaFF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_pAcs5k38eV6MpgiqrKAV4_\r\n#define DEFINED_TYPEDEF_FOR_struct_pAcs5k38eV6MpgiqrKAV4_\r\n\r\ntypedef struct {\r\n  real_T IMUAccelGain[3];\r\n  real_T IMUGyroGain[3];\r\n  struct_eF5OUT33sX0T9pzS8027m IMU;\r\n  struct_FIfaVnupBjYAxo1EdNiDlF Sonar;\r\n  real_T NO_VIS_X;\r\n  real_T NO_VIS_YAW;\r\n  struct_eFnp8sKFNJLN84XLbLzaFF dummy;\r\n  real_T sensorDelay;\r\n  real_T airDensity;\r\n  real_T altToPrsGain;\r\n  real_T altToPrsBias;\r\n  real_T inverseIMUGain[6];\r\n  real_T altSensorMin;\r\n  real_T velocityToOpticalFlowGain;\r\n  real_T cameraResolution[2];\r\n} struct_pAcs5k38eV6MpgiqrKAV4;\r\n\r\n#endif\r\n\r\n/* Parameters for system: '<S115>/MeasurementUpdate' */\r\ntypedef struct P_MeasurementUpdate_stateEstimator_T_\r\n  P_MeasurementUpdate_stateEstimator_T;\r\n\r\n/* Parameters for system: '<S122>/Enabled Subsystem' */\r\ntypedef struct P_EnabledSubsystem_stateEstimator_T_\r\n  P_EnabledSubsystem_stateEstimator_T;\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_stateEstimator_T_ P_stateEstimator_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_stateEstimator_T RT_MODEL_stateEstimator_T;\r\n\r\n#endif                                 /* RTW_HEADER_stateEstimator_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_powf_snf.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_powf_snf.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetInf.h\"\r\n#include <math.h>\r\n#include \"rt_powf_snf.h\"\r\n\r\nreal32_T rt_powf_snf(real32_T u0, real32_T u1)\r\n{\r\n  real32_T tmp;\r\n  real32_T tmp_0;\r\n  real32_T y;\r\n  if (rtIsNaNF(u0) || rtIsNaNF(u1)) {\r\n    y = (rtNaNF);\r\n  } else {\r\n    tmp = (real32_T)fabs(u0);\r\n    tmp_0 = (real32_T)fabs(u1);\r\n    if (rtIsInfF(u1)) {\r\n      if (tmp == 1.0F) {\r\n        y = 1.0F;\r\n      } else if (tmp > 1.0F) {\r\n        if (u1 > 0.0F) {\r\n          y = (rtInfF);\r\n        } else {\r\n          y = 0.0F;\r\n        }\r\n      } else if (u1 > 0.0F) {\r\n        y = 0.0F;\r\n      } else {\r\n        y = (rtInfF);\r\n      }\r\n    } else if (tmp_0 == 0.0F) {\r\n      y = 1.0F;\r\n    } else if (tmp_0 == 1.0F) {\r\n      if (u1 > 0.0F) {\r\n        y = u0;\r\n      } else {\r\n        y = 1.0F / u0;\r\n      }\r\n    } else if (u1 == 2.0F) {\r\n      y = u0 * u0;\r\n    } else if ((u1 == 0.5F) && (u0 >= 0.0F)) {\r\n      y = (real32_T)sqrt(u0);\r\n    } else if ((u0 < 0.0F) && (u1 > (real32_T)floor(u1))) {\r\n      y = (rtNaNF);\r\n    } else {\r\n      y = (real32_T)pow(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_powf_snf.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_powf_snf.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_powf_snf_h_\r\n#define RTW_HEADER_rt_powf_snf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real32_T rt_powf_snf(real32_T u0, real32_T u1);\r\n\r\n#endif                                 /* RTW_HEADER_rt_powf_snf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'conversionYUV'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:35:41 2021\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM 9\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\stateEstimator","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 0\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PARROT Mambo\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS 192.168.3.1\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS 192.168.3.1\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION TCP/IP\n#define MW_RTOS Baremetal\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_UI_LAUNCH 1\n#define MW_CONFIG_ENABLEPROFILING 0\n#define MW_CONFIG_ENABLEOPTICALFLOW 1\n#define MW_CONFIG_ENABLEIMAGEVISION 0\n#define MW_CONFIG_USEIMAGEVISIONFORPOSITION 0\n#define MW_CONFIG_USELOOKUP 0\n#define MW_CONFIG_NOSAFETY 1\n#define MW_CONFIG_ABORT 0\n#define MW_CONFIG_MAXACCELERATION 60\n#define MW_CONFIG_IMAGELOGGING 0\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 416\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};