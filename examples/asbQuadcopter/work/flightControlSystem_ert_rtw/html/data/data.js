var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"flightControlSystem","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flightControlSystem.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"rt_logging.h\"\r\n#ifndef SAVEFILE\r\n#define MATFILE2(file)                 #file \".mat\"\r\n#define MATFILE1(file)                 MATFILE2(file)\r\n#define MATFILE                        MATFILE1(MODEL)\r\n#else\r\n#define QUOTE1(name)                   #name\r\n#define QUOTE(name)                    QUOTE1(name)              /* need to expand name */\r\n#define MATFILE                        QUOTE(SAVEFILE)\r\n#endif\r\n\r\nvolatile int IsrOverrun = 0;\r\nboolean_T isRateRunning[2] = { 0, 0 };\r\n\r\nboolean_T need2runFlags[2] = { 0, 0 };\r\n\r\nvoid rt_OneStep(void)\r\n{\r\n  boolean_T eventFlags[2];\r\n\r\n  /* Check base rate for overrun */\r\n  if (isRateRunning[0]++) {\r\n    IsrOverrun = 1;\r\n    isRateRunning[0]--;                /* allow future iterations to succeed*/\r\n    return;\r\n  }\r\n\r\n  /*\r\n   * For a bare-board target (i.e., no operating system), the rates\r\n   * that execute this base step are buffered locally to allow for\r\n   * overlapping preemption.  The generated code includes function\r\n   * writeCodeInfoFcn() which sets the rates\r\n   * that need to run this time step.  The return values are 1 and 0\r\n   * for true and false, respectively.\r\n   */\r\n  flightControlSystem_SetEventsForThisBaseStep(eventFlags);\r\n  flightControlSystem_step0();\r\n\r\n  /* Get model outputs here */\r\n  isRateRunning[0]--;\r\n  if (eventFlags[1]) {\r\n    if (need2runFlags[1]++) {\r\n      IsrOverrun = 1;\r\n      need2runFlags[1]--;              /* allow future iterations to succeed*/\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (need2runFlags[1]) {\r\n    if (isRateRunning[1]) {\r\n      /* Yield to higher priority*/\r\n      return;\r\n    }\r\n\r\n    isRateRunning[1]++;\r\n\r\n    /* Step the model for subrate \"1\" */\r\n    switch (1)\r\n    {\r\n     case 1 :\r\n      flightControlSystem_step1();\r\n\r\n      /* Get model outputs here */\r\n      break;\r\n\r\n     default :\r\n      break;\r\n    }\r\n\r\n    need2runFlags[1]--;\r\n    isRateRunning[1]--;\r\n  }\r\n}\r\n\r\n#define UNUSED(x)                      x = x\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.005;\r\n  float systemClock = 416;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  UNUSED(modelBaseRate);\r\n  UNUSED(systemClock);\r\n  rtmSetErrorStatus(flightControlSystem_M, 0);\r\n  flightControlSystem_initialize();\r\n  ;\r\n  runModel =\r\n    rtmGetErrorStatus(flightControlSystem_M) == (NULL);\r\n  ;\r\n  while (runModel) {\r\n    rt_OneStep();\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(flightControlSystem_M) == (NULL));\r\n    runModel = !(stopRequested);\r\n  }\r\n\r\n  rt_StopDataLogging(MATFILE, flightControlSystem_M->rtwLogInfo);\r\n\r\n  /* Terminate model */\r\n  flightControlSystem_terminate();\r\n  ;\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem.c","type":"source","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flightControlSystem.h\"\r\n#include \"flightControlSystem_private.h\"\r\n\r\n/* Exported block signals */\r\nCommandBus cmd_inport;                 /* '<Root>/AC cmd' */\r\nSensorsBus sensor_inport;              /* '<Root>/Sensors' */\r\nreal32_T motors_outport[4];            /* '<S1>/controller' */\r\nuint8_T flag_outport;                  /* '<S3>/Merge' */\r\n\r\n/* Block signals (default storage) */\r\nB_flightControlSystem_T flightControlSystem_B;\r\n\r\n/* Block states (default storage) */\r\nDW_flightControlSystem_T flightControlSystem_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_flightControlSystem_T flightControlSystem_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_flightControlSystem_T flightControlSystem_M_;\r\nRT_MODEL_flightControlSystem_T *const flightControlSystem_M =\r\n  &flightControlSystem_M_;\r\nstatic void rate_monotonic_scheduler(void);\r\n\r\n/*\r\n * Set which subrates need to run this base step (base rate always runs).\r\n * This function must be called prior to calling the model step function\r\n * in order to \"remember\" which rates need to run this base step.  The\r\n * buffering of events allows for overlapping preemption.\r\n */\r\nvoid flightControlSystem_SetEventsForThisBaseStep(boolean_T *eventFlags)\r\n{\r\n  /* Task runs when its counter is zero, computed via rtmStepTask macro */\r\n  eventFlags[1] = ((boolean_T)rtmStepTask(flightControlSystem_M, 1));\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate\r\n *         and rate transition flags for tasks that exchange data.\r\n *         The function assumes rate-monotonic multitasking scheduler.\r\n *         The function must be called at model base rate so that\r\n *         the generated code self-manages all its subrates and rate\r\n *         transition flags.\r\n */\r\nstatic void rate_monotonic_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (flightControlSystem_M->Timing.TaskCounters.TID[1])++;\r\n  if ((flightControlSystem_M->Timing.TaskCounters.TID[1]) > 39) {/* Sample time: [0.2s, 0.0s] */\r\n    flightControlSystem_M->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S3>/Geofencing error'\r\n *    '<S3>/estimator//Optical flow error'\r\n *    '<S3>/Normal condition'\r\n */\r\nvoid flightControlSystem_Geofencingerror(uint8_T *rty_Out1,\r\n  P_Geofencingerror_flightControlSystem_T *localP)\r\n{\r\n  /* SignalConversion generated from: '<S13>/Out1' incorporates:\r\n   *  Constant: '<S13>/Constant'\r\n   */\r\n  *rty_Out1 = localP->Constant_Value;\r\n}\r\n\r\n/* System initialize for atomic system: '<S1>/Logging' */\r\nvoid flightControlSystem_Logging_Init(RT_MODEL_flightControlSystem_T * const\r\n  flightControlSystem_M, DW_Logging_flightControlSystem_T *localDW)\r\n{\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace2' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 12 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 12 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace2\";\r\n    localDW->ToWorkspace2_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"estim\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace2_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace6' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 10 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 10 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace6\";\r\n    localDW->ToWorkspace6_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"sensor\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace6_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace3' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 9 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 9 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace3\";\r\n    localDW->ToWorkspace3_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"cmd\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace3_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace4' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 8 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 8 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace4\";\r\n    localDW->ToWorkspace4_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"optical\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace4_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace5' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 8 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 8 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"SensorCalibration\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace5\";\r\n    localDW->ToWorkspace5_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"calib\",\r\n      1,\r\n      0,\r\n      100,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace5_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 4 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 4 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace\";\r\n    localDW->ToWorkspace_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"motor\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace1' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 8 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 8 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace1\";\r\n    localDW->ToWorkspace1_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"posref\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace1_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n}\r\n\r\n/* Output and update for atomic system: '<S1>/Logging' */\r\nvoid flightControlSystem_Logging(RT_MODEL_flightControlSystem_T * const\r\n  flightControlSystem_M, const real32_T rtu_motorCmds[4], const real32_T\r\n  rtu_posRef[8], const statesEstim_t *rtu_states_estim_Inport_3, const\r\n  CommandBus *rtu_ReferenceValueServerBus_Inport_4, const SensorsBus\r\n  *rtu_Sensors_Inport_5, real32_T rtu_sensordata_datin_Inport_6, uint32_T\r\n  rtu_sensordata_datin_Inport_6_d, real32_T rtu_sensordata_datin_Inport_6_e,\r\n  real32_T rtu_sensordata_datin_Inport_6_c, real32_T\r\n  rtu_sensordata_datin_Inport_6_cg, real32_T rtu_sensordata_datin_Inport_6_i,\r\n  real32_T rtu_sensordata_datin_Inport_6_h, real32_T\r\n  rtu_sensordata_datin_Inport_6_b, real32_T rtu_sensordata_datin_Inport_6_dz,\r\n  real32_T rtu_sensordata_datin_Inport_6_n, B_Logging_flightControlSystem_T\r\n  *localB, DW_Logging_flightControlSystem_T *localDW)\r\n{\r\n  int32_T i;\r\n  real32_T rtb_TmpSignalConversionAtToWorkspace4Inport1[8];\r\n  real32_T rtb_DataTypeConversion11;\r\n  real32_T rtb_DataTypeConversion7;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace2' incorporates:\r\n   *  SignalConversion generated from: '<S4>/states_estim_BusSelector'\r\n   */\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[0] =\r\n    rtu_states_estim_Inport_3->X;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[1] =\r\n    rtu_states_estim_Inport_3->Y;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[2] =\r\n    rtu_states_estim_Inport_3->Z;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[3] =\r\n    rtu_states_estim_Inport_3->yaw;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[4] =\r\n    rtu_states_estim_Inport_3->pitch;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[5] =\r\n    rtu_states_estim_Inport_3->roll;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[6] =\r\n    rtu_states_estim_Inport_3->dx;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[7] =\r\n    rtu_states_estim_Inport_3->dy;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[8] =\r\n    rtu_states_estim_Inport_3->dz;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[9] =\r\n    rtu_states_estim_Inport_3->p;\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\r\n   *  SignalConversion generated from: '<S4>/states_estim_BusSelector'\r\n   */\r\n  rtb_DataTypeConversion7 = rtu_states_estim_Inport_3->q;\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion11' incorporates:\r\n   *  SignalConversion generated from: '<S4>/states_estim_BusSelector'\r\n   */\r\n  rtb_DataTypeConversion11 = rtu_states_estim_Inport_3->r;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace2' */\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[10] = rtb_DataTypeConversion7;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[11] =\r\n    rtb_DataTypeConversion11;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace2' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace2_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace2Inport1[0]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion11' incorporates:\r\n   *  DataTypeConversion: '<S4>/Data Type Conversion1'\r\n   */\r\n  rtb_DataTypeConversion11 = rtu_sensordata_datin_Inport_6;\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\r\n   *  DataTypeConversion: '<S4>/Data Type Conversion2'\r\n   */\r\n  rtb_DataTypeConversion7 = (real32_T)rtu_sensordata_datin_Inport_6_d;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace6' */\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[0] =\r\n    rtu_sensordata_datin_Inport_6_e;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[1] =\r\n    rtu_sensordata_datin_Inport_6_c;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[2] =\r\n    rtu_sensordata_datin_Inport_6_cg;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[3] =\r\n    rtu_sensordata_datin_Inport_6_i;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[4] =\r\n    rtu_sensordata_datin_Inport_6_h;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[5] =\r\n    rtu_sensordata_datin_Inport_6_b;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[6] =\r\n    rtu_sensordata_datin_Inport_6_dz;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[7] =\r\n    rtu_sensordata_datin_Inport_6_n;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[8] = rtb_DataTypeConversion11;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[9] = rtb_DataTypeConversion7;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace6' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace6_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace6Inport1[0]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion11' incorporates:\r\n   *  DataTypeConversion: '<S4>/Data Type Conversion3'\r\n   */\r\n  rtb_DataTypeConversion11 =\r\n    rtu_ReferenceValueServerBus_Inport_4->controlModePosVSOrient;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace3' incorporates:\r\n   *  SignalConversion generated from: '<S4>/ReferenceValueServerBus_BusSelector'\r\n   */\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[1] =\r\n    rtu_ReferenceValueServerBus_Inport_4->pos_ref[0];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[2] =\r\n    rtu_ReferenceValueServerBus_Inport_4->pos_ref[1];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[3] =\r\n    rtu_ReferenceValueServerBus_Inport_4->pos_ref[2];\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion7' */\r\n  rtb_DataTypeConversion7 = rtu_ReferenceValueServerBus_Inport_4->takeoff_flag;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace3' incorporates:\r\n   *  DataTypeConversion: '<S4>/Data Type Conversion9'\r\n   *  SignalConversion generated from: '<S4>/ReferenceValueServerBus_BusSelector'\r\n   */\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[5] =\r\n    rtu_ReferenceValueServerBus_Inport_4->orient_ref[0];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[6] =\r\n    rtu_ReferenceValueServerBus_Inport_4->orient_ref[1];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[7] =\r\n    rtu_ReferenceValueServerBus_Inport_4->orient_ref[2];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[8] = (real32_T)\r\n    rtu_ReferenceValueServerBus_Inport_4->live_time_ticks;\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[0] = rtb_DataTypeConversion11;\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[4] = rtb_DataTypeConversion7;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace3' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace3_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace3Inport1[0]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion11' */\r\n  rtb_DataTypeConversion11 = rtu_Sensors_Inport_5->VisionSensors.usePosVIS_flag;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace4' incorporates:\r\n   *  SignalConversion generated from: '<S4>/Sensors_BusSelector'\r\n   */\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[1] =\r\n    rtu_Sensors_Inport_5->VisionSensors.opticalFlow_data[0];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[2] =\r\n    rtu_Sensors_Inport_5->VisionSensors.opticalFlow_data[1];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[3] =\r\n    rtu_Sensors_Inport_5->VisionSensors.opticalFlow_data[2];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[4] =\r\n    rtu_Sensors_Inport_5->VisionSensors.posVIS_data[0];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[5] =\r\n    rtu_Sensors_Inport_5->VisionSensors.posVIS_data[1];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[6] =\r\n    rtu_Sensors_Inport_5->VisionSensors.posVIS_data[2];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[7] =\r\n    rtu_Sensors_Inport_5->VisionSensors.posVIS_data[3];\r\n  rtb_TmpSignalConversionAtToWorkspace4Inport1[0] = rtb_DataTypeConversion11;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace4' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace4_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &rtb_TmpSignalConversionAtToWorkspace4Inport1[0]);\r\n  }\r\n\r\n  /* SignalConversion generated from: '<S4>/Sensors_BusSelector' */\r\n  for (i = 0; i < 8; i++) {\r\n    rtb_TmpSignalConversionAtToWorkspace4Inport1[i] =\r\n      rtu_Sensors_Inport_5->SensorCalibration[i];\r\n  }\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace5' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace5_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &rtb_TmpSignalConversionAtToWorkspace4Inport1[0]);\r\n  }\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace_PWORK.LoggedData,\r\n                          &locTime, &rtu_motorCmds[0]);\r\n  }\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace1' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace1_PWORK.LoggedData,\r\n                          &locTime, &rtu_posRef[0]);\r\n  }\r\n}\r\n\r\n/* System initialize for atomic system: '<Root>/Flight Control System' */\r\nvoid flightControlSystem_FlightControlSystem_Init(RT_MODEL_flightControlSystem_T\r\n  * const flightControlSystem_M, uint8_T *rty_Flag,\r\n  DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n  P_FlightControlSystem_flightControlSystem_T *localP)\r\n{\r\n  /* InitializeConditions for Memory: '<S5>/Memory' */\r\n  localDW->Memory_PreviousInput = localP->Memory_InitialCondition;\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<S1>/Logging' */\r\n  flightControlSystem_Logging_Init(flightControlSystem_M, &localDW->Logging);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S1>/Logging' */\r\n\r\n  /* SystemInitialize for Merge: '<S3>/Merge' */\r\n  *rty_Flag = localP->Merge_InitialOutput;\r\n\r\n  /* SystemInitialize for ModelReference: '<S1>/controller' */\r\n  flightController_Init();\r\n\r\n  /* SystemInitialize for ModelReference: '<S1>/estimator' */\r\n  stateEstimator_Init();\r\n}\r\n\r\n/* Output and update for atomic system: '<Root>/Flight Control System' */\r\nvoid flightControlSystem_FlightControlSystem(RT_MODEL_flightControlSystem_T *\r\n  const flightControlSystem_M, const CommandBus *rtu_ReferenceValueServerCmds,\r\n  const SensorsBus *rtu_Sensors_Inport_2, boolean_T rtu_VisionbasedData,\r\n  real32_T rty_motorCmds[4], uint8_T *rty_Flag,\r\n  B_FlightControlSystem_flightControlSystem_T *localB,\r\n  DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n  P_FlightControlSystem_flightControlSystem_T *localP)\r\n{\r\n  /* BusCreator: '<S5>/Bus Creator' */\r\n  localB->Compare_h = rtu_ReferenceValueServerCmds->takeoff_flag;\r\n  localB->rtb_BusCreator_live_time_ticks =\r\n    rtu_ReferenceValueServerCmds->live_time_ticks;\r\n\r\n  /* Switch: '<S5>/Switch' incorporates:\r\n   *  BusCreator: '<S5>/Bus Creator'\r\n   *  Constant: '<S5>/Constant'\r\n   *  Constant: '<S5>/Constant1'\r\n   *  Constant: '<S5>/Constant2'\r\n   *  Constant: '<S5>/Constant3'\r\n   *  Logic: '<S5>/Logical Operator'\r\n   *  Memory: '<S5>/Memory'\r\n   *  SignalConversion generated from: '<S5>/Bus Creator'\r\n   */\r\n  if (rtu_VisionbasedData && rtP_enableLanding) {\r\n    localB->Switch.controlModePosVSOrient = localP->Constant1_Value;\r\n    localB->Switch.pos_ref[0] = localDW->Memory_PreviousInput.X;\r\n    localB->Switch.pos_ref[1] = localDW->Memory_PreviousInput.Y;\r\n    localB->Switch.pos_ref[2] = rtP_landingAltitude;\r\n    localB->Switch.takeoff_flag = localB->Compare_h;\r\n    localB->Switch.orient_ref[0] = localP->Constant3_Value[0];\r\n    localB->Switch.orient_ref[1] = localP->Constant3_Value[1];\r\n    localB->Switch.orient_ref[2] = localP->Constant3_Value[2];\r\n    localB->Switch.live_time_ticks = localB->rtb_BusCreator_live_time_ticks;\r\n  } else {\r\n    localB->Switch = *rtu_ReferenceValueServerCmds;\r\n  }\r\n\r\n  /* End of Switch: '<S5>/Switch' */\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector3' */\r\n  localB->rtb_x_m = rtu_Sensors_Inport_2->HALSensors.HAL_acc_SI.x;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector3' */\r\n  localB->rtb_y_c = rtu_Sensors_Inport_2->HALSensors.HAL_acc_SI.y;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector3' */\r\n  localB->rtb_z_k = rtu_Sensors_Inport_2->HALSensors.HAL_acc_SI.z;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector4' */\r\n  localB->rtb_x_c_c = rtu_Sensors_Inport_2->HALSensors.HAL_gyro_SI.x;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector4' */\r\n  localB->rtb_y_n_b = rtu_Sensors_Inport_2->HALSensors.HAL_gyro_SI.y;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector4' */\r\n  localB->rtb_z_p_p = rtu_Sensors_Inport_2->HALSensors.HAL_gyro_SI.z;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector5' */\r\n  localB->rtb_altitude_c =\r\n    rtu_Sensors_Inport_2->HALSensors.HAL_ultrasound_SI.altitude;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector6' */\r\n  localB->rtb_pressure_f =\r\n    rtu_Sensors_Inport_2->HALSensors.HAL_pressure_SI.pressure;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector1' */\r\n  localB->rtb_vbat_V_g = rtu_Sensors_Inport_2->HALSensors.HAL_vbat_SI.vbat_V;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector1' */\r\n  localB->rtb_vbat_percentage_g =\r\n    rtu_Sensors_Inport_2->HALSensors.HAL_vbat_SI.vbat_percentage;\r\n\r\n  /* BusCreator generated from: '<S1>/estimator' */\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.ddx =\r\n    localB->rtb_x_m;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.ddy =\r\n    localB->rtb_y_c;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.ddz =\r\n    localB->rtb_z_k;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.p =\r\n    localB->rtb_x_c_c;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.q =\r\n    localB->rtb_y_n_b;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.r =\r\n    localB->rtb_z_p_p;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.altitude_sonar\r\n    = localB->rtb_altitude_c;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.prs =\r\n    localB->rtb_pressure_f;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.vbat_V =\r\n    localB->rtb_vbat_V_g;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.vbat_percentage\r\n    = localB->rtb_vbat_percentage_g;\r\n\r\n  /* ModelReference: '<S1>/estimator' */\r\n  stateEstimator_run(localB->Switch.controlModePosVSOrient,\r\n                     &localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1,\r\n                     rtu_Sensors_Inport_2->VisionSensors.usePosVIS_flag,\r\n                     &rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[0],\r\n                     &rtu_Sensors_Inport_2->VisionSensors.posVIS_data[0],\r\n                     &localB->estimator,\r\n                     &rtu_Sensors_Inport_2->SensorCalibration[0]);\r\n\r\n  /* ModelReference: '<S1>/controller' */\r\n  flightController_run(&localB->Switch, &localB->estimator, &rty_motorCmds[0],\r\n                       &localB->controller_o2[0]);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/Logging' */\r\n  flightControlSystem_Logging(flightControlSystem_M, rty_motorCmds,\r\n    localB->controller_o2, &localB->estimator, rtu_ReferenceValueServerCmds,\r\n    rtu_Sensors_Inport_2, localB->rtb_vbat_V_g, localB->rtb_vbat_percentage_g,\r\n    localB->rtb_x_m, localB->rtb_y_c, localB->rtb_z_k, localB->rtb_x_c_c,\r\n    localB->rtb_y_n_b, localB->rtb_z_p_p, localB->rtb_altitude_c,\r\n    localB->rtb_pressure_f, &localB->Logging, &localDW->Logging);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/Logging' */\r\n\r\n  /* Abs: '<S3>/Abs2' */\r\n  localB->Abs5 = (real32_T)fabs\r\n    (rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[0]);\r\n\r\n  /* RelationalOperator: '<S9>/Compare' incorporates:\r\n   *  Constant: '<S9>/Constant'\r\n   */\r\n  localB->Compare_h = (localB->Abs5 > localP->CompareToConstant2_const);\r\n\r\n  /* Gain: '<S3>/Gain2' */\r\n  localB->Abs5 = localP->Gain2_Gain *\r\n    rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[0];\r\n\r\n  /* RelationalOperator: '<S12>/Compare' incorporates:\r\n   *  Abs: '<S3>/Abs6'\r\n   *  Constant: '<S12>/Constant'\r\n   *  Sum: '<S3>/Add1'\r\n   */\r\n  localB->Compare_l = ((real32_T)fabs(localB->Abs5 - localB->estimator.dx) >\r\n                       localP->CompareToConstant6_const);\r\n\r\n  /* Gain: '<S3>/Gain1' */\r\n  localB->Abs5 = localP->Gain1_Gain *\r\n    rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[1];\r\n\r\n  /* RelationalOperator: '<S10>/Compare' incorporates:\r\n   *  Abs: '<S3>/Abs3'\r\n   *  Constant: '<S10>/Constant'\r\n   *  Sum: '<S3>/Add'\r\n   */\r\n  localB->Compare_mb = ((real32_T)fabs(localB->Abs5 - localB->estimator.dy) >\r\n                        localP->CompareToConstant3_const);\r\n\r\n  /* Abs: '<S3>/Abs5' */\r\n  localB->Abs5 = (real32_T)fabs\r\n    (rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[1]);\r\n\r\n  /* If: '<S3>/If' incorporates:\r\n   *  Abs: '<S3>/Abs'\r\n   *  Abs: '<S3>/Abs1'\r\n   *  Constant: '<S11>/Constant'\r\n   *  Constant: '<S7>/Constant'\r\n   *  Constant: '<S8>/Constant'\r\n   *  Logic: '<S3>/Logical Operator'\r\n   *  Logic: '<S3>/Logical Operator1'\r\n   *  Logic: '<S3>/Logical Operator2'\r\n   *  Logic: '<S3>/Logical Operator3'\r\n   *  RelationalOperator: '<S11>/Compare'\r\n   *  RelationalOperator: '<S7>/Compare'\r\n   *  RelationalOperator: '<S8>/Compare'\r\n   */\r\n  if (((real32_T)fabs(localB->estimator.X) > localP->CompareToConstant_const) ||\r\n      ((real32_T)fabs(localB->estimator.Y) > localP->CompareToConstant1_const))\r\n  {\r\n    /* Outputs for IfAction SubSystem: '<S3>/Geofencing error' incorporates:\r\n     *  ActionPort: '<S13>/Action Port'\r\n     */\r\n    flightControlSystem_Geofencingerror(rty_Flag, &localP->Geofencingerror);\r\n\r\n    /* End of Outputs for SubSystem: '<S3>/Geofencing error' */\r\n  } else if ((localB->Compare_h && localB->Compare_l) || (localB->Compare_mb &&\r\n              (localB->Abs5 > localP->CompareToConstant5_const))) {\r\n    /* Outputs for IfAction SubSystem: '<S3>/estimator//Optical flow error' incorporates:\r\n     *  ActionPort: '<S15>/Action Port'\r\n     */\r\n    flightControlSystem_Geofencingerror(rty_Flag,\r\n      &localP->estimatorOpticalflowerror);\r\n\r\n    /* End of Outputs for SubSystem: '<S3>/estimator//Optical flow error' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S3>/Normal condition' incorporates:\r\n     *  ActionPort: '<S14>/Action Port'\r\n     */\r\n    flightControlSystem_Geofencingerror(rty_Flag, &localP->Normalcondition);\r\n\r\n    /* End of Outputs for SubSystem: '<S3>/Normal condition' */\r\n  }\r\n\r\n  /* End of If: '<S3>/If' */\r\n\r\n  /* Update for Memory: '<S5>/Memory' */\r\n  localDW->Memory_PreviousInput = localB->estimator;\r\n}\r\n\r\n/* Model step function for TID0 */\r\nvoid flightControlSystem_step0(void)   /* Sample time: [0.005s, 0.0s] */\r\n{\r\n  {                                    /* Sample time: [0.005s, 0.0s] */\r\n    rate_monotonic_scheduler();\r\n  }\r\n\r\n  /* RateTransition: '<Root>/Rate Transition' */\r\n  flightControlSystem_B.rtb_RateTransition_c =\r\n    flightControlSystem_DW.RateTransition_Buffer0;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Flight Control System' */\r\n\r\n  /* Inport: '<Root>/AC cmd' incorporates:\r\n   *  Inport: '<Root>/Sensors'\r\n   */\r\n  flightControlSystem_FlightControlSystem(flightControlSystem_M, &cmd_inport,\r\n    &sensor_inport, flightControlSystem_B.rtb_RateTransition_c, motors_outport,\r\n    &flag_outport, &flightControlSystem_B.FlightControlSystem,\r\n    &flightControlSystem_DW.FlightControlSystem,\r\n    &flightControlSystem_P.FlightControlSystem);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Flight Control System' */\r\n\r\n  /* Outport: '<Root>/Actuators' */\r\n  flightControlSystem_Y.Actuators[0] = motors_outport[0];\r\n  flightControlSystem_Y.Actuators[1] = motors_outport[1];\r\n  flightControlSystem_Y.Actuators[2] = motors_outport[2];\r\n  flightControlSystem_Y.Actuators[3] = motors_outport[3];\r\n\r\n  /* Outport: '<Root>/Flag' */\r\n  flightControlSystem_Y.Flag = flag_outport;\r\n\r\n  /* Matfile logging */\r\n  rt_UpdateTXYLogVars(flightControlSystem_M->rtwLogInfo,\r\n                      (&flightControlSystem_M->Timing.taskTime0));\r\n\r\n  /* signal main to stop simulation */\r\n  {                                    /* Sample time: [0.005s, 0.0s] */\r\n    if ((rtmGetTFinal(flightControlSystem_M)!=-1) &&\r\n        !((rtmGetTFinal(flightControlSystem_M)-\r\n           flightControlSystem_M->Timing.taskTime0) >\r\n          flightControlSystem_M->Timing.taskTime0 * (DBL_EPSILON))) {\r\n      rtmSetErrorStatus(flightControlSystem_M, \"Simulation finished\");\r\n    }\r\n  }\r\n\r\n  /* Update absolute time */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n   * overflow during the application lifespan selected.\r\n   */\r\n  flightControlSystem_M->Timing.taskTime0 =\r\n    ((time_T)(++flightControlSystem_M->Timing.clockTick0)) *\r\n    flightControlSystem_M->Timing.stepSize0;\r\n}\r\n\r\n/* Model step function for TID1 */\r\nvoid flightControlSystem_step1(void)   /* Sample time: [0.2s, 0.0s] */\r\n{\r\n  int32_T j;\r\n  int32_T j_pixListNinc;\r\n  int32_T m;\r\n  int32_T ms;\r\n  int32_T ns;\r\n  int32_T numLoops;\r\n  int32_T p;\r\n  real32_T centroid_idx_0;\r\n  real32_T centroid_idx_1;\r\n  uint32_T centerIdx;\r\n  uint32_T padIdx;\r\n  uint32_T pixIdx;\r\n  uint32_T walkerIdx;\r\n  uint8_T currentLabel;\r\n  boolean_T maxNumBlobsReached;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Image Processing System' */\r\n  /* ModelReference: '<S2>/Y1UY2V to YUV' incorporates:\r\n   *  Inport: '<Root>/Image Data'\r\n   */\r\n  conversionYUV(&imRGB[0], &flightControlSystem_B.Y1UY2VtoYUV_o1[0],\r\n                &flightControlSystem_B.Y1UY2VtoYUV_o2[0],\r\n                &flightControlSystem_B.Y1UY2VtoYUV_o3[0],\r\n                &(flightControlSystem_DW.Y1UY2VtoYUV_InstanceData.rtb));\r\n\r\n  /* S-Function (svipcolorconv): '<S2>/Color Space  Conversion' incorporates:\r\n   *  ModelReference: '<S2>/Y1UY2V to YUV'\r\n   */\r\n  /* Precompute constants */\r\n  pixIdx = ((uint16_T)26149U) * 128U;\r\n  padIdx = (((uint16_T)6419U) * 128U + ((uint16_T)13320U) * 128U) + 8192U;\r\n  centerIdx = ((uint16_T)33050U) * 128U;\r\n  for (flightControlSystem_B.loop = 0; flightControlSystem_B.loop < 19200;\r\n       flightControlSystem_B.loop++) {\r\n    /* Convert YcbCr to RGB; apply coefficients and offsets */\r\n    /* derived from the ITU BT.601-5 recommendation; all of the */\r\n    /* coefficients and offsets are scaled (by 2^14) such that */\r\n    /* the conversion can be done using integer arithmetic; this */\r\n    /* routine relies on the user supplying the data in proper */\r\n    /* ranges: Y [16..235], Cb & Cr [16..240] */\r\n    /* Note that all of the operations are grouped in such a way */\r\n    /* that the arithmetic can be done using unsigned integers */\r\n    /* Given that Y is in the proper range, yDiff should */\r\n    /* always be positive */\r\n    flightControlSystem_B.yDiff =\r\n      flightControlSystem_B.Y1UY2VtoYUV_o1[flightControlSystem_B.loop] - 16U;\r\n\r\n    /* Red; 8192 in this equations is 0.5*2^14 or 2^13; adding 0.5  */\r\n    /* before truncation will result in rounding */\r\n    flightControlSystem_B.pos = (flightControlSystem_B.yDiff * ((uint16_T)19077U)\r\n      + (uint32_T)\r\n      flightControlSystem_B.Y1UY2VtoYUV_o3[flightControlSystem_B.loop] *\r\n      ((uint16_T)26149U)) + 8192U;\r\n    if (flightControlSystem_B.pos > pixIdx) {\r\n      flightControlSystem_B.pos -= pixIdx;\r\n    } else {\r\n      flightControlSystem_B.pos = 0U;\r\n    }\r\n\r\n    walkerIdx = flightControlSystem_B.pos >> 14;\r\n\r\n    /* limit to avoid wrapping */\r\n    if (walkerIdx > 255U) {\r\n      walkerIdx = 255U;\r\n    }\r\n\r\n    /* Compute green channel */\r\n    flightControlSystem_B.pos = flightControlSystem_B.yDiff * ((uint16_T)19077U)\r\n      + padIdx;\r\n    flightControlSystem_B.neg = (uint32_T)\r\n      flightControlSystem_B.Y1UY2VtoYUV_o2[flightControlSystem_B.loop] *\r\n      ((uint16_T)6419U) + (uint32_T)\r\n      flightControlSystem_B.Y1UY2VtoYUV_o3[flightControlSystem_B.loop] *\r\n      ((uint16_T)13320U);\r\n\r\n    /* scale back */\r\n    if (flightControlSystem_B.pos > flightControlSystem_B.neg) {\r\n      flightControlSystem_B.pos -= flightControlSystem_B.neg;\r\n    } else {\r\n      flightControlSystem_B.pos = 0U;\r\n    }\r\n\r\n    flightControlSystem_B.neg = flightControlSystem_B.pos >> 14;\r\n    if (flightControlSystem_B.neg > 255U) {\r\n      flightControlSystem_B.neg = 255U;\r\n    }\r\n\r\n    /* Compute blue channel */\r\n    flightControlSystem_B.pos = (flightControlSystem_B.yDiff * ((uint16_T)19077U)\r\n      + (uint32_T)\r\n      flightControlSystem_B.Y1UY2VtoYUV_o2[flightControlSystem_B.loop] *\r\n      ((uint16_T)33050U)) + 8192U;\r\n\r\n    /* scale back */\r\n    if (flightControlSystem_B.pos > centerIdx) {\r\n      flightControlSystem_B.pos -= centerIdx;\r\n    } else {\r\n      flightControlSystem_B.pos = 0U;\r\n    }\r\n\r\n    flightControlSystem_B.yDiff = flightControlSystem_B.pos >> 14;\r\n    if (flightControlSystem_B.yDiff > 255U) {\r\n      flightControlSystem_B.yDiff = 255U;\r\n    }\r\n\r\n    /* assign back the results */\r\n    flightControlSystem_B.ColorSpaceConversion_o1[flightControlSystem_B.loop] =\r\n      (uint8_T)walkerIdx;\r\n    flightControlSystem_B.ColorSpaceConversion_o2[flightControlSystem_B.loop] =\r\n      (uint8_T)flightControlSystem_B.neg;\r\n    flightControlSystem_B.ColorSpaceConversion_o3[flightControlSystem_B.loop] =\r\n      (uint8_T)flightControlSystem_B.yDiff;\r\n  }\r\n\r\n  /* End of S-Function (svipcolorconv): '<S2>/Color Space  Conversion' */\r\n  for (flightControlSystem_B.loop = 0; flightControlSystem_B.loop < 19200;\r\n       flightControlSystem_B.loop++) {\r\n    /* Sum: '<S2>/Sum' incorporates:\r\n     *  S-Function (svipcolorconv): '<S2>/Color Space  Conversion'\r\n     */\r\n    flightControlSystem_B.n =\r\n      (flightControlSystem_B.ColorSpaceConversion_o1[flightControlSystem_B.loop]\r\n       - flightControlSystem_B.ColorSpaceConversion_o2[flightControlSystem_B.loop])\r\n      - flightControlSystem_B.ColorSpaceConversion_o3[flightControlSystem_B.loop];\r\n    if (flightControlSystem_B.n < 0) {\r\n      flightControlSystem_B.n = 0;\r\n    }\r\n\r\n    /* RelationalOperator: '<S2>/Relational Operator1' incorporates:\r\n     *  Constant: '<S2>/Constant'\r\n     *  Sum: '<S2>/Sum'\r\n     */\r\n    flightControlSystem_B.RelationalOperator1[flightControlSystem_B.loop] =\r\n      (flightControlSystem_B.n > flightControlSystem_P.Constant_Value);\r\n  }\r\n\r\n  /* S-Function (svipblob): '<S2>/Blob Analysis' incorporates:\r\n   *  RelationalOperator: '<S2>/Relational Operator1'\r\n   */\r\n  maxNumBlobsReached = false;\r\n  memset(&flightControlSystem_DW.BlobAnalysis_PAD_DW[0], 0, 123U * sizeof\r\n         (uint8_T));\r\n  currentLabel = 1U;\r\n  flightControlSystem_B.loop = 0;\r\n  flightControlSystem_B.idx = 123;\r\n  for (flightControlSystem_B.n = 0; flightControlSystem_B.n < 160;\r\n       flightControlSystem_B.n++) {\r\n    for (m = 0; m < 120; m++) {\r\n      flightControlSystem_DW.BlobAnalysis_PAD_DW[flightControlSystem_B.idx] =\r\n        (uint8_T)\r\n        (flightControlSystem_B.RelationalOperator1[flightControlSystem_B.loop] ?\r\n         255 : 0);\r\n      flightControlSystem_B.loop++;\r\n      flightControlSystem_B.idx++;\r\n    }\r\n\r\n    flightControlSystem_DW.BlobAnalysis_PAD_DW[flightControlSystem_B.idx] = 0U;\r\n    flightControlSystem_DW.BlobAnalysis_PAD_DW[flightControlSystem_B.idx + 1] =\r\n      0U;\r\n    flightControlSystem_B.idx += 2;\r\n  }\r\n\r\n  memset(&flightControlSystem_DW.BlobAnalysis_PAD_DW[flightControlSystem_B.idx],\r\n         0, 121U * sizeof(uint8_T));\r\n  flightControlSystem_B.idx = 0;\r\n  pixIdx = 0U;\r\n  flightControlSystem_B.n = 0;\r\n  while (flightControlSystem_B.n < 160) {\r\n    j = 0;\r\n    ns = (flightControlSystem_B.idx + 1) * 122;\r\n    m = 0;\r\n    while (m < 120) {\r\n      padIdx = (uint32_T)((ns + j) + 1);\r\n      if (flightControlSystem_DW.BlobAnalysis_PAD_DW[padIdx] == 255) {\r\n        flightControlSystem_DW.BlobAnalysis_PAD_DW[padIdx] = currentLabel;\r\n        flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[pixIdx] = (int16_T)\r\n          flightControlSystem_B.idx;\r\n        flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[pixIdx] = (int16_T)j;\r\n        pixIdx++;\r\n        flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[currentLabel - 1] = 1U;\r\n        flightControlSystem_DW.BlobAnalysis_STACK_DW[0U] = padIdx;\r\n        padIdx = 1U;\r\n        while (padIdx != 0U) {\r\n          padIdx--;\r\n          centerIdx = flightControlSystem_DW.BlobAnalysis_STACK_DW[padIdx];\r\n          for (flightControlSystem_B.loop = 0; flightControlSystem_B.loop < 8;\r\n               flightControlSystem_B.loop++) {\r\n            walkerIdx = centerIdx +\r\n              rtCP_BlobAnalysis_WALKER_RTP[flightControlSystem_B.loop];\r\n            if (flightControlSystem_DW.BlobAnalysis_PAD_DW[walkerIdx] == 255) {\r\n              flightControlSystem_DW.BlobAnalysis_PAD_DW[walkerIdx] =\r\n                currentLabel;\r\n              flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[pixIdx] =\r\n                (int16_T)((int16_T)(walkerIdx / 122U) - 1);\r\n              flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[pixIdx] =\r\n                (int16_T)(walkerIdx % 122U - 1U);\r\n              pixIdx++;\r\n              flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[currentLabel - 1]++;\r\n              flightControlSystem_DW.BlobAnalysis_STACK_DW[padIdx] = walkerIdx;\r\n              padIdx++;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (currentLabel == 50) {\r\n          maxNumBlobsReached = true;\r\n          flightControlSystem_B.n = 160;\r\n          m = 120;\r\n        } else {\r\n          currentLabel++;\r\n        }\r\n      }\r\n\r\n      j++;\r\n      m++;\r\n    }\r\n\r\n    flightControlSystem_B.idx++;\r\n    flightControlSystem_B.n++;\r\n  }\r\n\r\n  flightControlSystem_B.n = maxNumBlobsReached ? (int32_T)currentLabel :\r\n    (int32_T)(uint8_T)(currentLabel - 1U);\r\n  m = 0;\r\n  flightControlSystem_B.idx = 0;\r\n  flightControlSystem_B.loop = 0;\r\n  while (flightControlSystem_B.loop < flightControlSystem_B.n) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o1_k[flightControlSystem_B.loop] =\r\n      (int32_T)\r\n      flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n    ns = 0;\r\n    ms = 0;\r\n    if (flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop]\r\n        <= 260000U) {\r\n      for (j = 0; j < (int32_T)\r\n           flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n           j++) {\r\n        ns += flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[j +\r\n          flightControlSystem_B.idx];\r\n        ms += flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[j + m];\r\n      }\r\n\r\n      centroid_idx_0 = (real32_T)ms / (real32_T)\r\n        flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n      centroid_idx_1 = (real32_T)ns / (real32_T)\r\n        flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n    } else {\r\n      numLoops = (int32_T)((real32_T)\r\n                           flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop]\r\n                           / 260000.0F);\r\n      centroid_idx_0 = 0.0F;\r\n      centroid_idx_1 = 0.0F;\r\n      for (p = 0; p < numLoops; p++) {\r\n        ns = 0;\r\n        ms = 0;\r\n        for (j = 0; j < 260000; j++) {\r\n          ns += flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW\r\n            [(flightControlSystem_B.idx + j) + p * 260000];\r\n          ms += flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[(m + j) + p *\r\n            260000];\r\n        }\r\n\r\n        centroid_idx_0 += (real32_T)ms / (real32_T)\r\n          flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n        centroid_idx_1 += (real32_T)ns / (real32_T)\r\n          flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n      }\r\n\r\n      ns = 0;\r\n      ms = 0;\r\n      numLoops *= 260000;\r\n      p = (int32_T)\r\n        (flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop]\r\n         - numLoops);\r\n      for (j = 0; j < p; j++) {\r\n        ns += flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[(j +\r\n          flightControlSystem_B.idx) + numLoops];\r\n        ms += flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[(j + m) +\r\n          numLoops];\r\n      }\r\n\r\n      centroid_idx_0 += (real32_T)ms / (real32_T)\r\n        flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n      centroid_idx_1 += (real32_T)ns / (real32_T)\r\n        flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n    }\r\n\r\n    flightControlSystem_B.rtb_BlobAnalysis_o2_c[flightControlSystem_B.loop] =\r\n      centroid_idx_1 + 1.0F;\r\n    flightControlSystem_B.rtb_BlobAnalysis_o2_c[flightControlSystem_B.loop + 50U]\r\n      = centroid_idx_0 + 1.0F;\r\n    ns = 160;\r\n    ms = 120;\r\n    numLoops = 0;\r\n    p = 0;\r\n    for (j = 0; j < (int32_T)\r\n         flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n         j++) {\r\n      j_pixListNinc = j + flightControlSystem_B.idx;\r\n      if (flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[j_pixListNinc] < ns)\r\n      {\r\n        ns = flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[j_pixListNinc];\r\n      }\r\n\r\n      if (flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[j_pixListNinc] >\r\n          numLoops) {\r\n        numLoops =\r\n          flightControlSystem_DW.BlobAnalysis_N_PIXLIST_DW[j_pixListNinc];\r\n      }\r\n\r\n      j_pixListNinc = j + m;\r\n      if (flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[j_pixListNinc] < ms)\r\n      {\r\n        ms = flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[j_pixListNinc];\r\n      }\r\n\r\n      if (flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[j_pixListNinc] > p) {\r\n        p = flightControlSystem_DW.BlobAnalysis_M_PIXLIST_DW[j_pixListNinc];\r\n      }\r\n    }\r\n\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop] = ns\r\n      + 1;\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop + 50U]\r\n      = ms + 1;\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop + 100]\r\n      = (numLoops - ns) + 1;\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop + 150]\r\n      = (p - ms) + 1;\r\n    m += (int32_T)\r\n      flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n    flightControlSystem_B.idx += (int32_T)\r\n      flightControlSystem_DW.BlobAnalysis_NUM_PIX_DW[flightControlSystem_B.loop];\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n;\r\n  while (flightControlSystem_B.loop < 50) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o1_k[flightControlSystem_B.loop] =\r\n      (-1);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n;\r\n  while (flightControlSystem_B.loop < 50) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o2_c[flightControlSystem_B.loop] =\r\n      (-1.0F);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n + 50;\r\n  while (flightControlSystem_B.loop < 100) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o2_c[flightControlSystem_B.loop] =\r\n      (-1.0F);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n;\r\n  while (flightControlSystem_B.loop < 50) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop] =\r\n      (-1);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n + 50;\r\n  while (flightControlSystem_B.loop < 100) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop] =\r\n      (-1);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n + 100;\r\n  while (flightControlSystem_B.loop < 150) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop] =\r\n      (-1);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  flightControlSystem_B.loop = flightControlSystem_B.n + 150;\r\n  while (flightControlSystem_B.loop < 200) {\r\n    flightControlSystem_B.rtb_BlobAnalysis_o3_m[flightControlSystem_B.loop] =\r\n      (-1);\r\n    flightControlSystem_B.loop++;\r\n  }\r\n\r\n  /* Switch: '<S2>/Landing Flag switch' incorporates:\r\n   *  Constant: '<S2>/One'\r\n   *  Constant: '<S2>/One1'\r\n   *  Constant: '<S2>/One2'\r\n   *  RelationalOperator: '<S2>/Relational Operator'\r\n   *  S-Function (svipblob): '<S2>/Blob Analysis'\r\n   */\r\n  if (flightControlSystem_B.n >= flightControlSystem_P.One_Value) {\r\n    maxNumBlobsReached = flightControlSystem_P.One1_Value;\r\n  } else {\r\n    maxNumBlobsReached = flightControlSystem_P.One2_Value;\r\n  }\r\n\r\n  /* End of Switch: '<S2>/Landing Flag switch' */\r\n  /* End of Outputs for SubSystem: '<Root>/Image Processing System' */\r\n\r\n  /* RateTransition: '<Root>/Rate Transition' */\r\n  flightControlSystem_DW.RateTransition_Buffer0 = maxNumBlobsReached;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid flightControlSystem_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n  rtmSetTFinal(flightControlSystem_M, 30.0);\r\n  flightControlSystem_M->Timing.stepSize0 = 0.005;\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    flightControlSystem_M->rtwLogInfo = &rt_DataLoggingInfo;\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(flightControlSystem_M->rtwLogInfo, (NULL));\r\n    rtliSetLogXSignalPtrs(flightControlSystem_M->rtwLogInfo, (NULL));\r\n    rtliSetLogT(flightControlSystem_M->rtwLogInfo, \"tout\");\r\n    rtliSetLogX(flightControlSystem_M->rtwLogInfo, \"\");\r\n    rtliSetLogXFinal(flightControlSystem_M->rtwLogInfo, \"\");\r\n    rtliSetLogVarNameModifier(flightControlSystem_M->rtwLogInfo, \"rt_\");\r\n    rtliSetLogFormat(flightControlSystem_M->rtwLogInfo, 2);\r\n    rtliSetLogMaxRows(flightControlSystem_M->rtwLogInfo, 1000);\r\n    rtliSetLogDecimation(flightControlSystem_M->rtwLogInfo, 1);\r\n\r\n    /*\r\n     * Set pointers to the data and signal info for each output\r\n     */\r\n    {\r\n      static void * rt_LoggedOutputSignalPtrs[] = {\r\n        &flightControlSystem_Y.Actuators[0],\r\n        &flightControlSystem_Y.Flag\r\n      };\r\n\r\n      rtliSetLogYSignalPtrs(flightControlSystem_M->rtwLogInfo,\r\n                            ((LogSignalPtrsType)rt_LoggedOutputSignalPtrs));\r\n    }\r\n\r\n    {\r\n      static int_T rt_LoggedOutputWidths[] = {\r\n        4,\r\n        1\r\n      };\r\n\r\n      static int_T rt_LoggedOutputNumDimensions[] = {\r\n        1,\r\n        1\r\n      };\r\n\r\n      static int_T rt_LoggedOutputDimensions[] = {\r\n        4,\r\n        1\r\n      };\r\n\r\n      static boolean_T rt_LoggedOutputIsVarDims[] = {\r\n        0,\r\n        0\r\n      };\r\n\r\n      static void* rt_LoggedCurrentSignalDimensions[] = {\r\n        (NULL),\r\n        (NULL)\r\n      };\r\n\r\n      static int_T rt_LoggedCurrentSignalDimensionsSize[] = {\r\n        4,\r\n        4\r\n      };\r\n\r\n      static BuiltInDTypeId rt_LoggedOutputDataTypeIds[] = {\r\n        SS_SINGLE,\r\n        SS_UINT8\r\n      };\r\n\r\n      static int_T rt_LoggedOutputComplexSignals[] = {\r\n        0,\r\n        0\r\n      };\r\n\r\n      static RTWPreprocessingFcnPtr rt_LoggingPreprocessingFcnPtrs[] = {\r\n        (NULL),\r\n        (NULL)\r\n      };\r\n\r\n      static const char_T *rt_LoggedOutputLabels[] = {\r\n        \"motors\",\r\n        \"flag\" };\r\n\r\n      static const char_T *rt_LoggedOutputBlockNames[] = {\r\n        \"flightControlSystem/Actuators\",\r\n        \"flightControlSystem/Flag\" };\r\n\r\n      static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert[] = {\r\n        { 0, SS_SINGLE, SS_SINGLE, 0, 0, 0, 1.0, 0, 0.0 },\r\n\r\n        { 0, SS_UINT8, SS_UINT8, 0, 0, 0, 1.0, 0, 0.0 }\r\n      };\r\n\r\n      static RTWLogSignalInfo rt_LoggedOutputSignalInfo[] = {\r\n        {\r\n          2,\r\n          rt_LoggedOutputWidths,\r\n          rt_LoggedOutputNumDimensions,\r\n          rt_LoggedOutputDimensions,\r\n          rt_LoggedOutputIsVarDims,\r\n          rt_LoggedCurrentSignalDimensions,\r\n          rt_LoggedCurrentSignalDimensionsSize,\r\n          rt_LoggedOutputDataTypeIds,\r\n          rt_LoggedOutputComplexSignals,\r\n          (NULL),\r\n          rt_LoggingPreprocessingFcnPtrs,\r\n\r\n          { rt_LoggedOutputLabels },\r\n          (NULL),\r\n          (NULL),\r\n          (NULL),\r\n\r\n          { rt_LoggedOutputBlockNames },\r\n\r\n          { (NULL) },\r\n          (NULL),\r\n          rt_RTWLogDataTypeConvert\r\n        }\r\n      };\r\n\r\n      rtliSetLogYSignalInfo(flightControlSystem_M->rtwLogInfo,\r\n                            rt_LoggedOutputSignalInfo);\r\n\r\n      /* set currSigDims field */\r\n      rt_LoggedCurrentSignalDimensions[0] = &rt_LoggedOutputWidths[0];\r\n      rt_LoggedCurrentSignalDimensions[1] = &rt_LoggedOutputWidths[1];\r\n    }\r\n\r\n    rtliSetLogY(flightControlSystem_M->rtwLogInfo, \"yout\");\r\n  }\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S1>/controller' */\r\n  flightController_g_initialize(rtmGetErrorStatusPointer(flightControlSystem_M));\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S1>/estimator' */\r\n  stateEstimator_o_initialize(rtmGetErrorStatusPointer(flightControlSystem_M));\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S2>/Y1UY2V to YUV' */\r\n  conversionYUV_initialize(rtmGetErrorStatusPointer(flightControlSystem_M),\r\n    &(flightControlSystem_DW.Y1UY2VtoYUV_InstanceData.rtm));\r\n\r\n  /* Matfile logging */\r\n  rt_StartDataLoggingWithStartTime(flightControlSystem_M->rtwLogInfo, 0.0,\r\n    rtmGetTFinal(flightControlSystem_M), flightControlSystem_M->Timing.stepSize0,\r\n    (&rtmGetErrorStatus(flightControlSystem_M)));\r\n\r\n  /* InitializeConditions for RateTransition: '<Root>/Rate Transition' */\r\n  flightControlSystem_DW.RateTransition_Buffer0 =\r\n    flightControlSystem_P.RateTransition_InitialCondition;\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<Root>/Flight Control System' */\r\n\r\n  /* SystemInitialize for Inport: '<Root>/Sensors' */\r\n  flightControlSystem_FlightControlSystem_Init(flightControlSystem_M,\r\n    &flag_outport, &flightControlSystem_DW.FlightControlSystem,\r\n    &flightControlSystem_P.FlightControlSystem);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<Root>/Flight Control System' */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid flightControlSystem_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem.h","type":"header","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_flightControlSystem_h_\r\n#define RTW_HEADER_flightControlSystem_h_\r\n#include <stddef.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include <float.h>\r\n#ifndef flightControlSystem_COMMON_INCLUDES_\r\n#define flightControlSystem_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_logging.h\"\r\n#endif                                /* flightControlSystem_COMMON_INCLUDES_ */\r\n\r\n#include \"flightControlSystem_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n\r\n/* Child system includes */\r\n#include \"conversionYUV.h\"\r\n#define stateEstimator_MDLREF_HIDE_CHILD_\r\n#include \"stateEstimator.h\"\r\n#define flightController_MDLREF_HIDE_CHILD_\r\n#include \"flightController.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetRTWLogInfo\r\n#define rtmGetRTWLogInfo(rtm)          ((rtm)->rtwLogInfo)\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatusPointer\r\n#define rtmGetErrorStatusPointer(rtm)  ((const char_T **)(&((rtm)->errorStatus)))\r\n#endif\r\n\r\n#ifndef rtmStepTask\r\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   ((rtm)->Timing.taskTime0)\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                (&(rtm)->Timing.taskTime0)\r\n#endif\r\n\r\n#ifndef rtmTaskCounter\r\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\r\n#endif\r\n\r\n/* Block signals for system '<S1>/Logging' */\r\ntypedef struct {\r\n  real32_T TmpSignalConversionAtToWorkspace2Inport1[12];\r\n  real32_T TmpSignalConversionAtToWorkspace6Inport1[10];\r\n  real32_T TmpSignalConversionAtToWorkspace3Inport1[9];\r\n} B_Logging_flightControlSystem_T;\r\n\r\n/* Block states (default storage) for system '<S1>/Logging' */\r\ntypedef struct {\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace2_PWORK;                /* '<S4>/To Workspace2' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace6_PWORK;                /* '<S4>/To Workspace6' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace3_PWORK;                /* '<S4>/To Workspace3' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace4_PWORK;                /* '<S4>/To Workspace4' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace5_PWORK;                /* '<S4>/To Workspace5' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace_PWORK;                 /* '<S4>/To Workspace' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace1_PWORK;                /* '<S4>/To Workspace1' */\r\n} DW_Logging_flightControlSystem_T;\r\n\r\n/* Block signals for system '<Root>/Flight Control System' */\r\ntypedef struct {\r\n  statesEstim_t estimator;             /* '<S1>/estimator' */\r\n  sensordata_t BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1;\r\n  real32_T controller_o2[8];           /* '<S1>/controller' */\r\n  CommandBus Switch;                   /* '<S5>/Switch' */\r\n  real32_T Abs5;                       /* '<S3>/Abs5' */\r\n  real32_T rtb_x_m;\r\n  real32_T rtb_y_c;\r\n  real32_T rtb_z_k;\r\n  real32_T rtb_x_c_c;\r\n  real32_T rtb_y_n_b;\r\n  real32_T rtb_z_p_p;\r\n  real32_T rtb_altitude_c;\r\n  real32_T rtb_pressure_f;\r\n  real32_T rtb_vbat_V_g;\r\n  uint32_T rtb_BusCreator_live_time_ticks;\r\n  uint32_T rtb_vbat_percentage_g;\r\n  boolean_T Compare_h;                 /* '<S9>/Compare' */\r\n  boolean_T Compare_l;                 /* '<S12>/Compare' */\r\n  boolean_T Compare_mb;                /* '<S10>/Compare' */\r\n  B_Logging_flightControlSystem_T Logging;/* '<S1>/Logging' */\r\n} B_FlightControlSystem_flightControlSystem_T;\r\n\r\n/* Block states (default storage) for system '<Root>/Flight Control System' */\r\ntypedef struct {\r\n  statesEstim_t Memory_PreviousInput;  /* '<S5>/Memory' */\r\n  DW_Logging_flightControlSystem_T Logging;/* '<S1>/Logging' */\r\n} DW_FlightControlSystem_flightControlSystem_T;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  uint8_T Y1UY2VtoYUV_o2[19200];       /* '<S2>/Y1UY2V to YUV' */\r\n  uint8_T Y1UY2VtoYUV_o3[19200];       /* '<S2>/Y1UY2V to YUV' */\r\n  uint8_T Y1UY2VtoYUV_o1[19200];       /* '<S2>/Y1UY2V to YUV' */\r\n  uint8_T ColorSpaceConversion_o3[19200];\r\n  uint8_T ColorSpaceConversion_o2[19200];\r\n  uint8_T ColorSpaceConversion_o1[19200];\r\n  boolean_T RelationalOperator1[19200];/* '<S2>/Relational Operator1' */\r\n  int32_T rtb_BlobAnalysis_o3_m[200];\r\n  real32_T rtb_BlobAnalysis_o2_c[100];\r\n  int32_T rtb_BlobAnalysis_o1_k[50];\r\n  int32_T loop;\r\n  int32_T idx;\r\n  int32_T n;\r\n  uint32_T pos;\r\n  uint32_T neg;\r\n  uint32_T yDiff;\r\n  boolean_T rtb_RateTransition_c;\r\n  B_FlightControlSystem_flightControlSystem_T FlightControlSystem;/* '<Root>/Flight Control System' */\r\n} B_flightControlSystem_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  uint32_T BlobAnalysis_STACK_DW[19200];/* '<S2>/Blob Analysis' */\r\n  int16_T BlobAnalysis_N_PIXLIST_DW[19200];/* '<S2>/Blob Analysis' */\r\n  int16_T BlobAnalysis_M_PIXLIST_DW[19200];/* '<S2>/Blob Analysis' */\r\n  uint8_T BlobAnalysis_PAD_DW[19764];  /* '<S2>/Blob Analysis' */\r\n  uint8_T ColorSpaceConversion_DWORK1[19200];/* '<S2>/Color Space  Conversion' */\r\n  uint32_T BlobAnalysis_NUM_PIX_DW[50];/* '<S2>/Blob Analysis' */\r\n  volatile boolean_T RateTransition_Buffer0;/* '<Root>/Rate Transition' */\r\n  MdlrefDW_conversionYUV_T Y1UY2VtoYUV_InstanceData;/* '<S2>/Y1UY2V to YUV' */\r\n  DW_FlightControlSystem_flightControlSystem_T FlightControlSystem;/* '<Root>/Flight Control System' */\r\n} DW_flightControlSystem_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real32_T Actuators[4];               /* '<Root>/Actuators' */\r\n  uint8_T Flag;                        /* '<Root>/Flag' */\r\n} ExtY_flightControlSystem_T;\r\n\r\n/* Parameters for system: '<S3>/Geofencing error' */\r\nstruct P_Geofencingerror_flightControlSystem_T_ {\r\n  uint8_T Constant_Value;              /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<S13>/Constant'\r\n                                        */\r\n};\r\n\r\n/* Parameters for system: '<Root>/Flight Control System' */\r\nstruct P_FlightControlSystem_flightControlSystem_T_ {\r\n  real32_T CompareToConstant_const;   /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S7>/Constant'\r\n                                       */\r\n  real32_T CompareToConstant1_const; /* Mask Parameter: CompareToConstant1_const\r\n                                      * Referenced by: '<S8>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant2_const; /* Mask Parameter: CompareToConstant2_const\r\n                                      * Referenced by: '<S9>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant6_const; /* Mask Parameter: CompareToConstant6_const\r\n                                      * Referenced by: '<S12>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant3_const; /* Mask Parameter: CompareToConstant3_const\r\n                                      * Referenced by: '<S10>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant5_const; /* Mask Parameter: CompareToConstant5_const\r\n                                      * Referenced by: '<S11>/Constant'\r\n                                      */\r\n  statesEstim_t Memory_InitialCondition;\r\n                                  /* Computed Parameter: Memory_InitialCondition\r\n                                   * Referenced by: '<S5>/Memory'\r\n                                   */\r\n  real32_T Constant3_Value[3];         /* Computed Parameter: Constant3_Value\r\n                                        * Referenced by: '<S5>/Constant3'\r\n                                        */\r\n  real32_T Gain2_Gain;                 /* Computed Parameter: Gain2_Gain\r\n                                        * Referenced by: '<S3>/Gain2'\r\n                                        */\r\n  real32_T Gain1_Gain;                 /* Computed Parameter: Gain1_Gain\r\n                                        * Referenced by: '<S3>/Gain1'\r\n                                        */\r\n  boolean_T Constant1_Value;           /* Expression: true\r\n                                        * Referenced by: '<S5>/Constant1'\r\n                                        */\r\n  uint8_T Merge_InitialOutput;        /* Computed Parameter: Merge_InitialOutput\r\n                                       * Referenced by: '<S3>/Merge'\r\n                                       */\r\n  P_Geofencingerror_flightControlSystem_T Normalcondition;/* '<S3>/Normal condition' */\r\n  P_Geofencingerror_flightControlSystem_T estimatorOpticalflowerror;\r\n                                      /* '<S3>/estimator//Optical flow error' */\r\n  P_Geofencingerror_flightControlSystem_T Geofencingerror;/* '<S3>/Geofencing error' */\r\n};\r\n\r\n/* Parameters (default storage) */\r\nstruct P_flightControlSystem_T_ {\r\n  boolean_T One1_Value;                /* Expression: true\r\n                                        * Referenced by: '<S2>/One1'\r\n                                        */\r\n  boolean_T One2_Value;                /* Expression: false\r\n                                        * Referenced by: '<S2>/One2'\r\n                                        */\r\n  boolean_T RateTransition_InitialCondition;\r\n                          /* Computed Parameter: RateTransition_InitialCondition\r\n                           * Referenced by: '<Root>/Rate Transition'\r\n                           */\r\n  uint8_T Constant_Value;              /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<S2>/Constant'\r\n                                        */\r\n  uint8_T One_Value;                   /* Computed Parameter: One_Value\r\n                                        * Referenced by: '<S2>/One'\r\n                                        */\r\n  P_FlightControlSystem_flightControlSystem_T FlightControlSystem;/* '<Root>/Flight Control System' */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_flightControlSystem_T {\r\n  const char_T *errorStatus;\r\n  RTWLogInfo *rtwLogInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    time_T taskTime0;\r\n    uint32_T clockTick0;\r\n    time_T stepSize0;\r\n    struct {\r\n      uint32_T TID[2];\r\n    } TaskCounters;\r\n\r\n    time_T tFinal;\r\n    boolean_T stopRequestedFlag;\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_flightControlSystem_T flightControlSystem_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_flightControlSystem_T flightControlSystem_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_flightControlSystem_T flightControlSystem_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_flightControlSystem_T flightControlSystem_Y;\r\n\r\n/* Model block global parameters (default storage) */\r\nextern struct_pAcs5k38eV6MpgiqrKAV4 rtP_Sensors;/* Variable: Sensors\r\n                                                 * Referenced by: '<S1>/estimator'\r\n                                                 */\r\nextern real32_T rtP_landingAltitude;   /* Variable: landingAltitude\r\n                                        * Referenced by: '<S5>/Constant2'\r\n                                        */\r\nextern boolean_T rtP_enableLanding;    /* Variable: enableLanding\r\n                                        * Referenced by: '<S5>/Constant'\r\n                                        */\r\n\r\n/*\r\n * Exported Global Signals\r\n *\r\n * Note: Exported global signals are block signals with an exported global\r\n * storage class designation.  Code generation will declare the memory for\r\n * these signals and export their symbols.\r\n *\r\n */\r\nextern CommandBus cmd_inport;          /* '<Root>/AC cmd' */\r\nextern SensorsBus sensor_inport;       /* '<Root>/Sensors' */\r\nextern real32_T motors_outport[4];     /* '<S1>/controller' */\r\nextern uint8_T flag_outport;           /* '<S3>/Merge' */\r\n\r\n/* External function called from main */\r\nextern void flightControlSystem_SetEventsForThisBaseStep(boolean_T *eventFlags);\r\n\r\n/* Model entry point functions */\r\nextern void flightControlSystem_SetEventsForThisBaseStep(boolean_T *eventFlags);\r\nextern void flightControlSystem_initialize(void);\r\nextern void flightControlSystem_step0(void);\r\nextern void flightControlSystem_step1(void);\r\nextern void flightControlSystem_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_flightControlSystem_T *const flightControlSystem_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'flightControlSystem'\r\n * '<S1>'   : 'flightControlSystem/Flight Control System'\r\n * '<S2>'   : 'flightControlSystem/Image Processing System'\r\n * '<S3>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags'\r\n * '<S4>'   : 'flightControlSystem/Flight Control System/Logging'\r\n * '<S5>'   : 'flightControlSystem/Flight Control System/landing logic'\r\n * '<S6>'   : 'flightControlSystem/Flight Control System/sensordata_group'\r\n * '<S7>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant'\r\n * '<S8>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant1'\r\n * '<S9>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant2'\r\n * '<S10>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant3'\r\n * '<S11>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant5'\r\n * '<S12>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant6'\r\n * '<S13>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Geofencing error'\r\n * '<S14>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Normal condition'\r\n * '<S15>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/estimator//Optical flow error'\r\n */\r\n#endif                                 /* RTW_HEADER_flightControlSystem_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_private.h","type":"header","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem_private.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_flightControlSystem_private_h_\r\n#define RTW_HEADER_flightControlSystem_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"flightControlSystem.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\nextern const int32_T rtCP_pooled_C4reIdFimW1I[8];\r\n\r\n#define rtCP_BlobAnalysis_WALKER_RTP   rtCP_pooled_C4reIdFimW1I  /* Computed Parameter: rtCP_BlobAnalysis_WALKER_RTP\r\n                                                                  * Referenced by: '<S2>/Blob Analysis'\r\n                                                                  */\r\n\r\n/* Imported (extern) pointer block signals */\r\nextern uint8_T *imRGB;                 /* '<Root>/Image Data' */\r\nextern void flightControlSystem_Geofencingerror(uint8_T *rty_Out1,\r\n  P_Geofencingerror_flightControlSystem_T *localP);\r\nextern void flightControlSystem_Logging_Init(RT_MODEL_flightControlSystem_T *\r\n  const flightControlSystem_M, DW_Logging_flightControlSystem_T *localDW);\r\nextern void flightControlSystem_Logging(RT_MODEL_flightControlSystem_T * const\r\n  flightControlSystem_M, const real32_T rtu_motorCmds[4], const real32_T\r\n  rtu_posRef[8], const statesEstim_t *rtu_states_estim_Inport_3, const\r\n  CommandBus *rtu_ReferenceValueServerBus_Inport_4, const SensorsBus\r\n  *rtu_Sensors_Inport_5, real32_T rtu_sensordata_datin_Inport_6, uint32_T\r\n  rtu_sensordata_datin_Inport_6_d, real32_T rtu_sensordata_datin_Inport_6_e,\r\n  real32_T rtu_sensordata_datin_Inport_6_c, real32_T\r\n  rtu_sensordata_datin_Inport_6_cg, real32_T rtu_sensordata_datin_Inport_6_i,\r\n  real32_T rtu_sensordata_datin_Inport_6_h, real32_T\r\n  rtu_sensordata_datin_Inport_6_b, real32_T rtu_sensordata_datin_Inport_6_dz,\r\n  real32_T rtu_sensordata_datin_Inport_6_n, B_Logging_flightControlSystem_T\r\n  *localB, DW_Logging_flightControlSystem_T *localDW);\r\nextern void flightControlSystem_FlightControlSystem_Init\r\n  (RT_MODEL_flightControlSystem_T * const flightControlSystem_M, uint8_T\r\n   *rty_Flag, DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n   P_FlightControlSystem_flightControlSystem_T *localP);\r\nextern void flightControlSystem_FlightControlSystem\r\n  (RT_MODEL_flightControlSystem_T * const flightControlSystem_M, const\r\n   CommandBus *rtu_ReferenceValueServerCmds, const SensorsBus\r\n   *rtu_Sensors_Inport_2, boolean_T rtu_VisionbasedData, real32_T rty_motorCmds\r\n   [4], uint8_T *rty_Flag, B_FlightControlSystem_flightControlSystem_T *localB,\r\n   DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n   P_FlightControlSystem_flightControlSystem_T *localP);\r\n\r\n#endif                           /* RTW_HEADER_flightControlSystem_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_types.h","type":"header","group":"model","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem_types.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_flightControlSystem_types_h_\r\n#define RTW_HEADER_flightControlSystem_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"C:\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\include\\HAL.h\"\r\n\r\n/* Model Code Variants */\r\n#ifndef DEFINED_TYPEDEF_FOR_CommandBus_\r\n#define DEFINED_TYPEDEF_FOR_CommandBus_\r\n\r\ntypedef struct {\r\n  boolean_T controlModePosVSOrient;\r\n  real32_T pos_ref[3];\r\n  boolean_T takeoff_flag;\r\n  real32_T orient_ref[3];\r\n  uint32_T live_time_ticks;\r\n} CommandBus;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_extraSensorData_t_\r\n#define DEFINED_TYPEDEF_FOR_extraSensorData_t_\r\n\r\ntypedef struct {\r\n  real32_T opticalFlow_data[3];\r\n  real32_T posVIS_data[4];\r\n  real32_T usePosVIS_flag;\r\n} extraSensorData_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_SensorsBus_\r\n#define DEFINED_TYPEDEF_FOR_SensorsBus_\r\n\r\ntypedef struct {\r\n  extraSensorData_t VisionSensors;\r\n  HAL_acquisition_t HALSensors;\r\n  real32_T SensorCalibration[8];\r\n} SensorsBus;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_statesEstim_t_\r\n#define DEFINED_TYPEDEF_FOR_statesEstim_t_\r\n\r\ntypedef struct {\r\n  real32_T X;\r\n  real32_T Y;\r\n  real32_T Z;\r\n  real32_T yaw;\r\n  real32_T pitch;\r\n  real32_T roll;\r\n  real32_T dx;\r\n  real32_T dy;\r\n  real32_T dz;\r\n  real32_T p;\r\n  real32_T q;\r\n  real32_T r;\r\n} statesEstim_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_sensordata_t_\r\n#define DEFINED_TYPEDEF_FOR_sensordata_t_\r\n\r\ntypedef struct {\r\n  real32_T ddx;\r\n  real32_T ddy;\r\n  real32_T ddz;\r\n  real32_T p;\r\n  real32_T q;\r\n  real32_T r;\r\n  real32_T altitude_sonar;\r\n  real32_T prs;\r\n  real32_T vbat_V;\r\n  uint32_T vbat_percentage;\r\n} sensordata_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eF5OUT33sX0T9pzS8027m_\r\n#define DEFINED_TYPEDEF_FOR_struct_eF5OUT33sX0T9pzS8027m_\r\n\r\ntypedef struct {\r\n  real_T cg[3];\r\n  real_T location[3];\r\n  real_T accNatFreq;\r\n  real_T accDamping;\r\n  real_T accScaleCross[9];\r\n  real_T accBias[3];\r\n  real_T accLimits[6];\r\n  real_T gyroNatFreq;\r\n  real_T gyroDamping;\r\n  real_T gyroScaleCross[9];\r\n  real_T gyroBias[3];\r\n  real_T gyroGBias[3];\r\n  real_T gyroLimits[6];\r\n  real_T noiseSeeds[6];\r\n  real_T noiseWeights[6];\r\n  real_T noisePower[6];\r\n} struct_eF5OUT33sX0T9pzS8027m;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_FIfaVnupBjYAxo1EdNiDlF_\r\n#define DEFINED_TYPEDEF_FOR_struct_FIfaVnupBjYAxo1EdNiDlF_\r\n\r\ntypedef struct {\r\n  real_T noisePower;\r\n  real_T noiseSeeds;\r\n} struct_FIfaVnupBjYAxo1EdNiDlF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eFnp8sKFNJLN84XLbLzaFF_\r\n#define DEFINED_TYPEDEF_FOR_struct_eFnp8sKFNJLN84XLbLzaFF_\r\n\r\ntypedef struct {\r\n  real_T posVISNoVisionAvail[4];\r\n  real_T usePosVISFlag;\r\n  real_T batteryStatus[2];\r\n} struct_eFnp8sKFNJLN84XLbLzaFF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_pAcs5k38eV6MpgiqrKAV4_\r\n#define DEFINED_TYPEDEF_FOR_struct_pAcs5k38eV6MpgiqrKAV4_\r\n\r\ntypedef struct {\r\n  real_T IMUAccelGain[3];\r\n  real_T IMUGyroGain[3];\r\n  struct_eF5OUT33sX0T9pzS8027m IMU;\r\n  struct_FIfaVnupBjYAxo1EdNiDlF Sonar;\r\n  real_T NO_VIS_X;\r\n  real_T NO_VIS_YAW;\r\n  struct_eFnp8sKFNJLN84XLbLzaFF dummy;\r\n  real_T sensorDelay;\r\n  real_T airDensity;\r\n  real_T altToPrsGain;\r\n  real_T altToPrsBias;\r\n  real_T inverseIMUGain[6];\r\n  real_T altSensorMin;\r\n  real_T velocityToOpticalFlowGain;\r\n  real_T cameraResolution[2];\r\n} struct_pAcs5k38eV6MpgiqrKAV4;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eAf0NJvzCY9HYTXF7bLNgB_\r\n#define DEFINED_TYPEDEF_FOR_struct_eAf0NJvzCY9HYTXF7bLNgB_\r\n\r\ntypedef struct {\r\n  real_T Ts2Q[16];\r\n  real_T Q2Ts[16];\r\n  real_T takeoffGain;\r\n  real_T totalThrustMaxRelative;\r\n  real_T motorsThrustPerMotorMax;\r\n} struct_eAf0NJvzCY9HYTXF7bLNgB;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_XRMsui9C07VjBvdq1msujB_\r\n#define DEFINED_TYPEDEF_FOR_struct_XRMsui9C07VjBvdq1msujB_\r\n\r\ntypedef struct {\r\n  real_T initGreenwich;\r\n  real_T quatGain;\r\n} struct_XRMsui9C07VjBvdq1msujB;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_hxsmtt0xTZOLDNa2Rz7GAF_\r\n#define DEFINED_TYPEDEF_FOR_struct_hxsmtt0xTZOLDNa2Rz7GAF_\r\n\r\ntypedef struct {\r\n  real_T xAxis;\r\n} struct_hxsmtt0xTZOLDNa2Rz7GAF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_IZWOW0zYvpphl7qLgSfN7E_\r\n#define DEFINED_TYPEDEF_FOR_struct_IZWOW0zYvpphl7qLgSfN7E_\r\n\r\ntypedef struct {\r\n  real_T href;\r\n  struct_hxsmtt0xTZOLDNa2Rz7GAF FlatEarthToLLA;\r\n} struct_IZWOW0zYvpphl7qLgSfN7E;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_q6UUpnZ4gTjFvULFx6Rxa_\r\n#define DEFINED_TYPEDEF_FOR_struct_q6UUpnZ4gTjFvULFx6Rxa_\r\n\r\ntypedef struct {\r\n  real_T mass;\r\n  real_T inertia[9];\r\n  real_T d;\r\n  real_T xy;\r\n  real_T h;\r\n  real_T Cdx;\r\n  real_T Cdy;\r\n  real_T diameter;\r\n} struct_q6UUpnZ4gTjFvULFx6Rxa;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_OMRgDnJcZuQneKEj9vdTyD_\r\n#define DEFINED_TYPEDEF_FOR_struct_OMRgDnJcZuQneKEj9vdTyD_\r\n\r\ntypedef struct {\r\n  real_T blades;\r\n  real_T radius;\r\n  real_T chord;\r\n  real_T flappingOffset;\r\n  real_T bladeMass;\r\n  real_T bladeInertia;\r\n  real_T hubMass;\r\n  real_T hubInertia;\r\n  real_T inertia;\r\n  real_T Ct;\r\n  real_T Cq;\r\n  real_T solidity;\r\n  real_T theta0;\r\n  real_T thetaTip;\r\n  real_T theta1;\r\n  real_T theta34;\r\n  real_T a;\r\n  real_T area;\r\n  real_T lock;\r\n  real_T b;\r\n  real_T k;\r\n  real_T w2ToThrustGain;\r\n} struct_OMRgDnJcZuQneKEj9vdTyD;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_p3FXZIgqtjF2uqDpmYjb6C_\r\n#define DEFINED_TYPEDEF_FOR_struct_p3FXZIgqtjF2uqDpmYjb6C_\r\n\r\ntypedef struct {\r\n  real_T maxLimit;\r\n  real_T minLimit;\r\n  real_T commandToW2Gain;\r\n  real_T thrustToMotorCommand;\r\n} struct_p3FXZIgqtjF2uqDpmYjb6C;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_OSJpyIZcrpXqReVWwh9iuG_\r\n#define DEFINED_TYPEDEF_FOR_struct_OSJpyIZcrpXqReVWwh9iuG_\r\n\r\ntypedef struct {\r\n  struct_XRMsui9C07VjBvdq1msujB SixDOF;\r\n  struct_IZWOW0zYvpphl7qLgSfN7E PositionOnEarth;\r\n  struct_q6UUpnZ4gTjFvULFx6Rxa Airframe;\r\n  struct_OMRgDnJcZuQneKEj9vdTyD Rotor;\r\n  struct_p3FXZIgqtjF2uqDpmYjb6C Motor;\r\n} struct_OSJpyIZcrpXqReVWwh9iuG;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_hE1099BMemg5OfzqcWAA6G_\r\n#define DEFINED_TYPEDEF_FOR_struct_hE1099BMemg5OfzqcWAA6G_\r\n\r\ntypedef struct {\r\n  real_T date[6];\r\n  real_T posLLA[3];\r\n  real_T posNED[3];\r\n  real_T vb[3];\r\n  real_T euler[3];\r\n  real_T angRates[3];\r\n} struct_hE1099BMemg5OfzqcWAA6G;\r\n\r\n#endif\r\n\r\n/* Parameters for system: '<S3>/Geofencing error' */\r\ntypedef struct P_Geofencingerror_flightControlSystem_T_\r\n  P_Geofencingerror_flightControlSystem_T;\r\n\r\n/* Parameters for system: '<Root>/Flight Control System' */\r\ntypedef struct P_FlightControlSystem_flightControlSystem_T_\r\n  P_FlightControlSystem_flightControlSystem_T;\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_flightControlSystem_T_ P_flightControlSystem_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_flightControlSystem_T RT_MODEL_flightControlSystem_T;\r\n\r\n#endif                             /* RTW_HEADER_flightControlSystem_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_data.c","type":"source","group":"data","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem_data.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flightControlSystem.h\"\r\n#include \"flightControlSystem_private.h\"\r\n\r\n/* Model block global parameters (default storage) */\r\nstruct_pAcs5k38eV6MpgiqrKAV4 rtP_Sensors = {\r\n  { 1.00596, 1.00383, 0.99454 },\r\n\r\n  { 0.99861, 1.00644, 0.99997 },\r\n\r\n  {\r\n    { 0.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 0.0, 0.0 },\r\n    190.0,\r\n    0.707,\r\n\r\n    { 1.00596, 0.0, 0.0, 0.0, 1.00383, 0.0, 0.0, 0.0, 0.99454 },\r\n\r\n    { 0.09, -0.06, 0.33699999999999974 },\r\n\r\n    { -50.0, -50.0, -50.0, 50.0, 50.0, 50.0 },\r\n    190.0,\r\n    0.707,\r\n\r\n    { 0.99861, 0.0, 0.0, 0.0, 1.00644, 0.0, 0.0, 0.0, 0.99997 },\r\n\r\n    { -0.0095, -0.0075, 0.0015 },\r\n\r\n    { 0.0, 0.0, 0.0 },\r\n\r\n    { -10.0, -10.0, -10.0, 10.0, 10.0, 10.0 },\r\n\r\n    { 41.0, 41.0, 41.0, 41.0, 41.0, 41.0 },\r\n\r\n    { 0.8, 0.8, 0.8, 0.025, 0.025, 0.025 },\r\n\r\n    { 0.00021831529882618725, 0.00018641345254680647, 0.00037251068300213613,\r\n      1.0651514622688397e-8, 1.3021327403798377e-8, 1.1929474437781302e-8 }\r\n  },\r\n\r\n  {\r\n    1.0,\r\n    41.0\r\n  },\r\n  -99.0,\r\n  -9.0,\r\n\r\n  {\r\n    { -99.0, 0.0, 0.0, -9.0 },\r\n    0.0,\r\n\r\n    { 3.5, 70.0 }\r\n  },\r\n  1.0,\r\n  1.225,\r\n  12.01725,\r\n  101270.95,\r\n\r\n  { 0.99407531114557246, 0.99618461293246863, 1.0054899752649467,\r\n    1.0013919347893572, 0.99360120821906917, 1.0000300009000269 },\r\n  0.44,\r\n  1.0,\r\n\r\n  { 160.0, 120.0 }\r\n} ;                                    /* Variable: Sensors\r\n                                        * Referenced by: '<S1>/estimator'\r\n                                        */\r\n\r\nreal32_T rtP_landingAltitude = -0.6F;  /* Variable: landingAltitude\r\n                                        * Referenced by: '<S5>/Constant2'\r\n                                        */\r\nboolean_T rtP_enableLanding = true;    /* Variable: enableLanding\r\n                                        * Referenced by: '<S5>/Constant'\r\n                                        */\r\n\r\n/* Block parameters (default storage) */\r\nP_flightControlSystem_T flightControlSystem_P = {\r\n  /* Expression: true\r\n   * Referenced by: '<S2>/One1'\r\n   */\r\n  true,\r\n\r\n  /* Expression: false\r\n   * Referenced by: '<S2>/One2'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: RateTransition_InitialCondition\r\n   * Referenced by: '<Root>/Rate Transition'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: Constant_Value\r\n   * Referenced by: '<S2>/Constant'\r\n   */\r\n  100U,\r\n\r\n  /* Computed Parameter: One_Value\r\n   * Referenced by: '<S2>/One'\r\n   */\r\n  1U,\r\n\r\n  /* Start of '<Root>/Flight Control System' */\r\n  {\r\n    /* Mask Parameter: CompareToConstant_const\r\n     * Referenced by: '<S7>/Constant'\r\n     */\r\n    10.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant1_const\r\n     * Referenced by: '<S8>/Constant'\r\n     */\r\n    10.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant2_const\r\n     * Referenced by: '<S9>/Constant'\r\n     */\r\n    0.01F,\r\n\r\n    /* Mask Parameter: CompareToConstant6_const\r\n     * Referenced by: '<S12>/Constant'\r\n     */\r\n    6.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant3_const\r\n     * Referenced by: '<S10>/Constant'\r\n     */\r\n    6.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant5_const\r\n     * Referenced by: '<S11>/Constant'\r\n     */\r\n    0.01F,\r\n\r\n    /* Computed Parameter: Memory_InitialCondition\r\n     * Referenced by: '<S5>/Memory'\r\n     */\r\n    {\r\n      0.0F,                            /* X */\r\n      0.0F,                            /* Y */\r\n      0.0F,                            /* Z */\r\n      0.0F,                            /* yaw */\r\n      0.0F,                            /* pitch */\r\n      0.0F,                            /* roll */\r\n      0.0F,                            /* dx */\r\n      0.0F,                            /* dy */\r\n      0.0F,                            /* dz */\r\n      0.0F,                            /* p */\r\n      0.0F,                            /* q */\r\n      0.0F                             /* r */\r\n    },\r\n\r\n    /* Computed Parameter: Constant3_Value\r\n     * Referenced by: '<S5>/Constant3'\r\n     */\r\n    { 0.0F, 0.0F, 0.0F },\r\n\r\n    /* Computed Parameter: Gain2_Gain\r\n     * Referenced by: '<S3>/Gain2'\r\n     */\r\n    1.0F,\r\n\r\n    /* Computed Parameter: Gain1_Gain\r\n     * Referenced by: '<S3>/Gain1'\r\n     */\r\n    1.0F,\r\n\r\n    /* Expression: true\r\n     * Referenced by: '<S5>/Constant1'\r\n     */\r\n    true,\r\n\r\n    /* Computed Parameter: Merge_InitialOutput\r\n     * Referenced by: '<S3>/Merge'\r\n     */\r\n    0U,\r\n\r\n    /* Start of '<S3>/Normal condition' */\r\n    {\r\n      /* Computed Parameter: Constant_Value\r\n       * Referenced by: '<S14>/Constant'\r\n       */\r\n      0U\r\n    }\r\n    ,\r\n\r\n    /* End of '<S3>/Normal condition' */\r\n\r\n    /* Start of '<S3>/estimator//Optical flow error' */\r\n    {\r\n      /* Computed Parameter: Constant_Value\r\n       * Referenced by: '<S15>/Constant'\r\n       */\r\n      99U\r\n    }\r\n    ,\r\n\r\n    /* End of '<S3>/estimator//Optical flow error' */\r\n\r\n    /* Start of '<S3>/Geofencing error' */\r\n    {\r\n      /* Computed Parameter: Constant_Value\r\n       * Referenced by: '<S13>/Constant'\r\n       */\r\n      1U\r\n    }\r\n    /* End of '<S3>/Geofencing error' */\r\n  }\r\n  /* End of '<Root>/Flight Control System' */\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: builtin_typeid_types.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:37:05 2021\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#include \"rtwtypes.h\"\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,                       /* real_T    */\r\n  SS_SINGLE = 1,                       /* real32_T  */\r\n  SS_INT8 = 2,                         /* int8_T    */\r\n  SS_UINT8 = 3,                        /* uint8_T   */\r\n  SS_INT16 = 4,                        /* int16_T   */\r\n  SS_UINT16 = 5,                       /* uint16_T  */\r\n  SS_INT32 = 6,                        /* int32_T   */\r\n  SS_UINT32 = 7,                       /* uint32_T  */\r\n  SS_BOOLEAN = 8                       /* boolean_T */\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int_T)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int_T DTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"const_params.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * const_params.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"flightControlSystem\".\r\n *\r\n * Model version              : 5.1\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Nov 30 09:37:05 2021\r\n */\r\n#include \"rtwtypes.h\"\r\n\r\nextern const int32_T rtCP_pooled_C4reIdFimW1I[8];\r\nconst int32_T rtCP_pooled_C4reIdFimW1I[8] = { -1, 121, 122, 123, 1, -121, -122,\r\n  -123 } ;\r\n"},{"name":"multiword_types.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: multiword_types.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:37:05 2021\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:36:39 2021\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'conversionYUV'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:35:41 2021\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM 9\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 5.1\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Tue Nov 30 09:39:25 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"flightControlSystem.h\"\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"HAL.h","type":"header","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\include","tag":"","groupDisplay":"Other files","code":"#ifndef _HAL_H_\n#define _HAL_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdint.h>\n#include <stdio.h>\n\n\n#define NB_TAB_ECHO  4\n#define MAX_ECHO 30\n\ntypedef uint16_t status_t;\n\n\n/**\n * \\struct _HAL_gyro_SI_t\n * \\brief Gyroscope data with SI unit (rad/s)\n */\ntypedef struct _HAL_gyro_SI_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n    float temperature; //celsius\n    int temperature_lsb;\n} HAL_gyro_SI_t;\n\n\n/**\n * \\struct _HAL_fifo_gyro_SI_t\n * \\brief Gyroscope data with SI unit (rad/s)\n */\ntypedef struct _HAL_fifo_gyro_SI_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n} HAL_fifo_gyro_SI_t;\n\n/**\n * \\struct _HAL_acc_SI_t\n * \\brief Accelerometer data with SI unit (m/s2)\n */\ntypedef struct _HAL_acc_SI_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n    float temperature; ///< Unit is Celsius\n} HAL_acc_SI_t;\n\n/**\n * \\struct _HAL_magn_mg_t\n * \\brief Magnetic data with mG unit\n */\ntypedef struct _HAL_magn_mG_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n} HAL_magn_mG_t;\n\n\n/**\n * \\struct _HAL_pressurePS_SI_t\n * \\brief Pressure data of pressure sensor with SI unit\n */\ntypedef struct _HAL_pressure_SI_t\n{\n    double __attribute__((aligned(8))) temperature; ///< Unit is Celsius\n    float pressure;  ///< Unit is Pascal\n} HAL_pressure_SI_t;\n\n\n/**\n * \\struct _HAL_vbat_SI_t\n * \\brief  Voltage of battery powering device\n */\ntypedef struct _HAL_vbat_SI_t\n{\n    float vbat_V; ///< Battery voltage (unit : Volt)\n    uint32_t vbat_percentage; ///< percentage of battery according of min and max of tension permitted\n#ifdef MAMBO\n    float ibat_A; ///< Battery current intensity (unit : Ampere)\n#endif\n} HAL_vbat_SI_t;\n\n#ifdef ROLLINGSPIDER\n/**\n * \\struct _HAL_etron_gpio_t\n * \\brief Etron Chip GPIOs\n */\ntypedef struct _HAL_etron_gpio_t\n{\n    int jump_half_load; ///< Input active high (inverted from HW)\n    int onoff_button; ///< Input active high (inverted from HW)\n    int charging; ///< Input active high\n    int charge_done;\n} HAL_etron_gpio_t;\n#endif\n\n#ifdef MAMBO\ntypedef struct _HAL_temperature_us_SI_t\n{\n    float vtemp_us_V; /**< Temperature US voltage (unit : Volt)\n    \t\t\t (-1: last read failed, NaN: No value yet) */\n    float temp_us; /**< Temperature US in celsius (NaN: No value yet) */\n} HAL_temperature_us_SI_t;\n#endif\n/**\n * Echo information\n * */\n#ifdef ROLLINGSPIDER\ntypedef struct _HAL_echo_t\n{\n    uint16_t begin_echo_index; ///<index of raw data corresponding to the beggining of the echo (begin_echo_index/ultrasound_frequency_acquisition = time)\n    uint16_t end_echo_index; ///<index of raw data corresponding to the end of the echo (end_echo_index/ultrasound_frequency_acquisition = time)\n    int16_t max_value_index; ///<index of max value of the echo\n    int32_t max_value; ///<Max value of the echo\n    uint16_t precedent; ///<Number \"id\" of the echo matched in precedent ADC_acquistion serie\n    int16_t d_echo; ///<Index difference between this echo and the echo matched in precedent ADC_acquisition serie\n    uint16_t pre_max_index; ///<Index of raw data corresponding to maw_value minus noise\n} HAL_echo_t;\n#endif\n\n#ifdef MAMBO\ntypedef struct _HAL_echo_t\n{\n    uint16_t begin_echo_index; ///<index of raw data corresponding to the beggining of the echo (begin_echo_index/ultrasound_frequency_acquisition = time)\n    uint16_t end_echo_index; ///<index of raw data corresponding to the end of the echo (end_echo_index/ultrasound_frequency_acquisition = time)\n    int16_t max_value_index; ///<index of max value of the echo\n    uint16_t precedent; ///<Number \"id\" of the echo matched in precedent ADC_acquistion serie\n    int16_t d_echo; ///<Index difference between this echo and the echo matched in precedent ADC_acquisition serie\n    uint16_t pre_max_index; ///<Index of raw data corresponding to maw_value minus noise\n    int32_t max_value; ///<Max value of the echo\n} HAL_echo_t;\n#endif\n/**\n * Array with echo found and number of echo found\n * */\ntypedef struct _HAL_list_echo_t\n{\n    HAL_echo_t tab_echo[MAX_ECHO]; ///<array with echo found\n    uint8_t number_of_echoes; ///<number of echoes found\n}HAL_list_echo_t;\n\nenum\n{\n    HAL_US_status_No_Measure = 0,   //  1\n    HAL_US_status_Inv_Data_number,  //  2\n    HAL_US_status_No_Echo_Init,     //  4\n    HAL_US_status_No_Echo,          //  8\n    HAL_US_status_No_Matching,      // 16\n};\n\n\ntypedef struct _HAL_ultrasound_SI_t\n{\n    float altitude; ///<Unit is meter\n    float raw_altitude;\n    uint16_t nb_echo;\n    int measure_ref;\n    int measure_status;\n    uint8_t new_data;\n    HAL_list_echo_t HAL_list_echo;\n        HAL_list_echo_t HAL_list_echo_p;\n} HAL_ultrasound_SI_t;\n\n\n/**\n * Information used for processing altitude\n * */\ntypedef struct _HAL_ultrasound_result_t\n{\n\n    HAL_list_echo_t list_echo[NB_TAB_ECHO]; ///<array of last NB_TAB_ECHO succession acquisition process\n    HAL_echo_t echo_altitude; ///<Echo chosen as \"real\" echo\n    uint8_t index_list_echo_used; ///<Index of element of list echo used\n    uint8_t index_last_list_echo_used; ///<Index of element of list used in last succession acquisition process\n    uint8_t nb_echoes; //number of elements of actual list echo\n    uint32_t sum_echo; ///<Value corresponding to area before ultrasound envelope\n    int32_t gradient; ///<Gradient when envelope reaches threshold curve\n}HAL_ultrasound_result_t;\n\n/**\n * USB plugged or not\n * */\ntypedef enum HAL_VBUS_state_t\n{\n    HAL_VBUS_ON = 0,\n    HAL_VBUS_OFF,\n} HAL_VBUS_state_t;\n\n/**\n * \\struct _HAL_acquisition_t\n * \\brief data result of data_format function\n */\n#ifdef ROLLINGSPIDER\ntypedef struct __attribute__((aligned(8))) _HAL_acquisition_t\n{\n    /*HAL_acquisition general information*/\n    int number_HAL_read_call; ///< number of HAL_read() call\n    int64_t timestamp; ///< timestamp corresponding to HAL_acquisition\n    status_t status; ///<bitfield indicating if a sensors have been updated>\n    uint8_t used; ///< indicating if HAL_acquisition is used or not\n    uint8_t count_user; ///< number of threads using this element\n\n    /* IMU data = acc/gyro on NONE-FIFO mode*/\n    HAL_acc_SI_t HAL_acc_SI; ///< accelerometer data    TODO REMOVE this\n    HAL_gyro_SI_t HAL_gyro_SI; ///< gyroscope data      TODO REMOVE this\n\n    /*IMU data = acc + gyro on FIFO mode*/\n    /*FIXME: please make a structure*/\n    uint16_t HAL_fifo_count;        ///< Raw fifo size in the MPU6050 (debug purpose only)\n    int64_t fifo_timestamp; ///< timestamp corresponding to the very last set of data read from fifo\n\n\n    HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_TempCorr[5];  ///< gyroscope temperature corrected data in FIFO\n    HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_TempCorr[5];  ///< accelerometer temperature corrected data in FIFO\n    union\n    {\n        HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_Raw[5];  ///< gyroscope data in FIFO\n        HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI[5]; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n    };\n    union\n    {\n        HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_Raw[5];  ///< accelerometer data in FIFO\n        HAL_fifo_gyro_SI_t HAL_fifo_acce_SI[5]; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n    };\n\n    float HAL_ref_IMU_temp; ///< Desired IMU temperature\n    uint8_t HAL_fifo_fsync[5]; ///< imu fsync signal\n    int HAL_fifo_size;                     ///< Size of each array HAL_fifo_gyro_SI and HAL_fifo_acce_SI\n\n    /*Magnetometer data*/\n    HAL_magn_mG_t HAL_magn_mG; ///< magnetic data\n\n    /*Pressure data*/\n    HAL_pressure_SI_t HAL_pressure_SI; ///< pressure data\n\n    /*Ultrasound data*/\n    HAL_ultrasound_SI_t HAL_ultrasound_SI; ///< ultrasound data\n\n    uint8_t padding[52+144];\n\n    /*Battery data*/\n    HAL_vbat_SI_t HAL_vbat_SI; //Battery voltage value (unit : V)\n\n} HAL_acquisition_t;\n#endif\n\n#ifdef MAMBO\ntypedef struct __attribute__((aligned(8))) _HAL_acquisition_t\n{\n    /*HAL_acquisition general information*/\n    int number_HAL_read_call; ///< number of HAL_read() call\n    int64_t timestamp; ///< timestamp corresponding to HAL_acquisition\n    status_t status; ///<bitfield indicating if a sensors have been updated>\n    uint8_t used; ///< indicating if HAL_acquisition is used or not\n    uint8_t count_user; ///< number of threads using this element\n\n    /* IMU data = acc/gyro on NONE-FIFO mode*/\n    HAL_acc_SI_t HAL_acc_SI; ///< accelerometer data    TODO REMOVE this\n    HAL_gyro_SI_t HAL_gyro_SI; ///< gyroscope data      TODO REMOVE this\n\n    /*IMU data = acc + gyro on FIFO mode*/\n    /*FIXME: please make a structure*/\n    uint16_t HAL_fifo_count;        ///< Raw fifo size in the MPU6050 (debug purpose only)\n    int64_t fifo_timestamp; ///< timestamp corresponding to the very last set of data read from fifo\n    HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_Raw[5];  ///< gyroscope data in FIFO\n    HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_Raw[5];  ///< accelerometer data in FIFO\n\n    HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_TempCorr[5];  ///< gyroscope temperature corrected data in FIFO\n    HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_TempCorr[5];  ///< accelerometer temperature corrected data in FIFO\n\n    HAL_fifo_gyro_SI_t *HAL_fifo_gyro_SI; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n    HAL_fifo_gyro_SI_t *HAL_fifo_acce_SI; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n\n    float HAL_ref_IMU_temp; ///< Desired IMU temperature\n    uint8_t HAL_fifo_fsync[5]; ///< imu fsync signal\n    int HAL_fifo_size;                     ///< Size of each array HAL_fifo_gyro_SI and HAL_fifo_acce_SI\n\n    /*Magnetometer data*/\n    HAL_magn_mG_t HAL_magn_mG; ///< magnetic data\n\n    /*Pressure data*/\n    HAL_pressure_SI_t HAL_pressure_SI; ///< pressure data\n    HAL_pressure_SI_t HAL_pressure_SI_nose; ///< pressure data\n    /*Ultrasound data*/\n    HAL_ultrasound_SI_t HAL_ultrasound_SI; ///< ultrasound data\n\n    /*ADC data (not used on Mambo) */\n    uint8_t HAL_adc_jpsumo_results_padding[144]; ///< Jumping Sumo ADC datas\n\n    /* Not used on Mambo */\n    uint8_t HAL_BLDC_result_padding[64];\n\n    /*Battery data*/\n    HAL_vbat_SI_t HAL_vbat_SI; //Battery voltage value (unit : V)\n\n    /* Not used on Mambo*/\n    uint8_t jpsumo_gpios_padding[12]; /**< Jumping Sumo gpio inputs */\n    uint8_t HAL_gps_data_padding[792];\n\n    /* Remote control (not used on Mambo) */\n    uint8_t rc_padding[7];\n\n    /* Not used on Mambo */\n    uint32_t camif_id_field; ///< indicates if camif data is stocked\n    void* result_camif_tab_padding; ///<result camif\n\n    HAL_VBUS_state_t VBUS_state;\n\n    HAL_temperature_us_SI_t HAL_temperature_us_SI;\n\n} HAL_acquisition_t;\n\n#endif\n\n\n\ntypedef enum _HAL_ultrasound_command_t\n{\n    ULTRASOUND_CMD_NO_CMD=0,\n    ULTRASOUND_CMD_SET_MODE = 1,\n    ULTRASOUND_CMD_SET_NB_PULSES = 2,\n    ULTRASOUND_CMD_SET_VOLTAGE_MODE = 4,\n    ULTRASOUND_CMD_SET_NB_PULSES_AND_TENSION_MODE = 6,\n    ULTRASOUND_CMD_SET_FREQUENCY = 8,\n    ULTRASOUND_CMD_START = 16,\n    ULTRASOUND_CMD_STOP = 32,\n} HAL_ultrasound_command_t;\n\n#ifdef ROLLINGSPIDER\ntypedef enum _HAL_BLDC_motor_command_t\n{\n    BLDC_CMD_NO_CMD=0,\n    BLDC_CMD_START=1,\n    BLDC_CMD_STOP=2,\n    BLDC_CMD_RUN=3,\n    BLDC_CMD_CLEAR=4,\n    BLDC_CMD_REBOOT_BLDC=5,\n    BLDC_CMD_LED=6,\n} HAL_BLDC_motor_command_t;\n#endif\n\n#ifdef MAMBO\ntypedef enum _HAL_BLDC_motor_command_t\n{\n    BLDC_CMD_NO_CMD=0,\n    BLDC_CMD_START=1,\n    BLDC_CMD_STOP=2,\n    BLDC_CMD_RUN=3,\n    BLDC_CMD_REVERSE=4,\n    BLDC_CMD_CLEAR=5,\n    BLDC_CMD_REBOOT_BLDC=6,\n    BLDC_CMD_LED=7,\n} HAL_BLDC_motor_command_t;\n#endif\n\ntypedef struct _HAL_command_t\n{\n    HAL_BLDC_motor_command_t command;\n\n    int16_t* motors_speed;\n    uint8_t  enable_security;\n\n    int HAL_ultrasound_command;\n    uint8_t ultrasound_mode;\n    uint8_t nb_pulses;\n    uint8_t voltage_mode;\n    uint32_t acquisition_frequency_wanted;\n#ifdef ROLLINGSPIDER\n    // LEDs commands :\n    void* LEDs_cmds;\n    int32_t HAL_leds_command;\n#endif\n\n} HAL_command_t;\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // _HAL_H_"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PARROT Mambo\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS 192.168.3.1\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS 192.168.3.1\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION TCP/IP\n#define MW_RTOS Baremetal\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_UI_LAUNCH 1\n#define MW_CONFIG_ENABLEPROFILING 0\n#define MW_CONFIG_ENABLEOPTICALFLOW 1\n#define MW_CONFIG_ENABLEIMAGEVISION 0\n#define MW_CONFIG_USEIMAGEVISIONFORPOSITION 0\n#define MW_CONFIG_USELOOKUP 0\n#define MW_CONFIG_NOSAFETY 1\n#define MW_CONFIG_ABORT 0\n#define MW_CONFIG_MAXACCELERATION 60\n#define MW_CONFIG_IMAGELOGGING 0\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 416\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"controlCommand.c","type":"source","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/*  @file: controlCommand.c\n *\n *  @description: This module responds to the requests received from the host over TCP.\n *\n */\n\n#include \"controlCommand.h\"\n#include <math.h>\n\nlong int sensorData[3] = {0}; // For storing the x,y,z sensor readings of accelerometer/ Gyroscope\nlong int motorSpeed[4] = {0}; // Motor speeds of all the four motors\nlong int batteryData[2] = {0}; // For storing the battery voltage and percentage of charge left\nlong int streamData[5] = {0}; // For storing the data from all drone sensors\nint ack = 1; // Acknowledgment for position and orientation control\n\n/* Variables to control the drone's landing sequence*/\ndouble current_height,step_height;\ndouble land_height = -0.5;\nextern int landDrone;\n\nvoid processRequest(int connfd,char *recvBuff,HAL_acquisition_t* in,HAL_command_t* out, CommandBus* keyboardServerCommands, int *run_flag)\n{\n\n    if ((recvBuff[0]) != '\\0') {\n\n        switch (recvBuff[0]) {\n          case startFlight:\n            /* Take off command */\n            if (1 != isMotorOn) {\n                isMotorOn = 1;\n                printf(\" TakeOff Sequence Initiated !! \\n\");\n                throttle = *((int*)&recvBuff[4]); // Power Gain (1-100)\n                if ((recvBuff[8]) != '\\0') {\n                    flightDuration = *((int*)&recvBuff[8]); // Flight duration in seconds\n                    printf(\"The flight duration is set to = %d seconds and powergain is set to = %d\\n\", flightDuration,throttle);\n                }\n                else\n                {\n                    /* Use Simulation stop time if flight duration is not provided by user. */\n                    flightDuration = STOP_TIME;\n                    printf(\"The flight duration is set to Simulation Stop Time of = %d seconds and powergain is set to = %d\\n\", flightDuration,throttle);\n                }\n                wrStatus = write(connfd,&(ack),sizeof(ack));\n            }\n            break;\n          case stopFlight:\n            /* Soft Land the drone */\n            if (0 != isMotorOn) {\n                printf(\" Landing Sequence Initiated !! \\n\");\n                //isLanding = 1;\n                landDrone = 1; //Set the landing flag.\n                wrStatus = write(connfd,&(ack),sizeof(ack)); //Send ack to the host app\n            }\n            break;\n\n          case emergencyStop:\n            /* Shut down drone motors */\n            printf(\" Emergency Landing Sequence Initiated !! \\n\");\n            isMotorOn = 0;\n            *run_flag = 0 ; \n            break;\n\n          case getAccelData:\n            /* Read acceleration of drone in m/s^2*/\n            printf(\"ACCELEROMETER DATA: X: %5.3f s^2 - Y: %5.3f s^2 - Z: %5.3f s^2 \\n\",in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n            sensorData[0] = in->HAL_acc_SI.x*100;\n            sensorData[1] = in->HAL_acc_SI.y*100;\n            sensorData[2] = in->HAL_acc_SI.z*100;\n            wrStatus = write(connfd,sensorData,sizeof(sensorData));\n            break;\n\n          case getGyroData:\n            /* Read Angular Velocity in rad/s*/\n            printf(\"GYROSCOPE DATA: X: %5.2f rad/s - Y: %5.2f rad/s - Z: %5.2f rad/s \\n\",in->HAL_gyro_SI.x,in->HAL_gyro_SI.y,in->HAL_gyro_SI.z);\n            sensorData[0] = in->HAL_gyro_SI.x*100;\n            sensorData[1] = in->HAL_gyro_SI.y*100;\n            sensorData[2] = in->HAL_gyro_SI.z*100;\n            wrStatus = write(connfd,sensorData,sizeof(sensorData));\n            break;\n\n          case getMagnetoData:\n            /* Read magnetic field in mT*/\n            printf(\"MAGNETOMETER DATA: X: %5.2f mG - Y: %5.2f mG - Z: %5.2f mG \\n\",in->HAL_magn_mG.x,in->HAL_magn_mG.y,in->HAL_magn_mG.z);\n            sensorData[0] = in->HAL_magn_mG.x*100;\n            sensorData[1] = in->HAL_magn_mG.y*100;\n            sensorData[2] = in->HAL_magn_mG.z*100;\n            wrStatus = write(connfd,sensorData,sizeof(sensorData));\n            break;\n\n          case getAltitude:\n            /* Read the altitude seen by the Ultrasound sensor of the drone*/\n            printf(\"ALTITUDE: X: %5.2f m \\n\",in->HAL_ultrasound_SI.altitude);\n            altitude = in->HAL_ultrasound_SI.altitude*100;\n            wrStatus = write(connfd,&(altitude),sizeof(altitude));\n            break;\n\n          case getPressure:\n            /* Read atmospheric pressure in Pascals*/\n            printf(\"PRESSURE: %5.2f pascal \\n\",in->HAL_pressure_SI.pressure);\n            pressure = in->HAL_pressure_SI.pressure*100;\n            wrStatus = write(connfd,&(pressure),sizeof(pressure));\n            break;\n\n          case getBatteryData:\n            /* Read battery Voltage and percentage of charge left in the battery */\n            printf(\"VOLTAGE: %5.2f V - %0d percents\\n\", in->HAL_vbat_SI.vbat_V,(int)in->HAL_vbat_SI.vbat_percentage);\n            batteryData[0] = in->HAL_vbat_SI.vbat_V*100;\n            batteryData[1] = in->HAL_vbat_SI.vbat_percentage*100;\n            wrStatus = write(connfd,batteryData,sizeof(batteryData));\n            break;\n\n          case readSensor:\n            /* Read the sensor readings from Accelerometer, Gyroscope, Pressure and Ultrasound sensor*/\n            streamData[0] = in->HAL_acc_SI.x*100;\n            streamData[1] = in->HAL_acc_SI.y*100;\n            streamData[2] = in->HAL_acc_SI.z*100;\n            streamData[3] = in->HAL_pressure_SI.pressure*100;\n            streamData[4] = in->HAL_ultrasound_SI.altitude*100;\n            wrStatus = write(connfd,streamData,sizeof(streamData));\n            break;\n\n          case setPitch:\n            /*  Set Pitch angle of minidrone in radians */\n            pitch_ref_buff = *((int*)&recvBuff[4]);\n            keyboardServerCommands->orient_ref[1] = (double)((pitch_ref_buff - 10000) / 1000.0);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case setRoll:\n            /*  Set Roll angle of minidrone in radians */\n            roll_ref_buff = *((int*)&recvBuff[4]);\n            keyboardServerCommands->orient_ref[2] = (double)((roll_ref_buff - 10000) / 1000.0);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case setYaw:\n            /*  Set Yaw angle of minidrone in radians*/\n            yaw_ref_buff = *((int*)&recvBuff[4]);\n            keyboardServerCommands->orient_ref[0] = (double)((yaw_ref_buff - 10000) / 1000.0);\n            printf(\"Yaw updated to: %f\\n\",keyboardServerCommands->orient_ref[0]);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case updateZPosition:\n            /*  Set Altitude of minidrone in meters*/\n            z_ref_buff = *((int*)&recvBuff[4]);\n            if (((double)(z_ref_buff / 100.0)) >= -4.0) {\n                keyboardServerCommands->pos_ref[2] = (double)(z_ref_buff / 100.0);\n            }\n            printf(\"Z updated to: %f\\n\",keyboardServerCommands->pos_ref[2]);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case updateXYPosition:\n            /* Move the drone to the desired coordinate position*/\n            x_ref_buff = *((int*)&recvBuff[4]);\n            y_ref_buff = *((int*)&recvBuff[8]);\n            printf(\"X: %f Y: %f \\n\",x_ref_buff/100.0,y_ref_buff/100.0);\n            keyboardServerCommands->pos_ref[0] = (double)(x_ref_buff / 100.0);\n            keyboardServerCommands->pos_ref[1] = (double)(y_ref_buff / 100.0);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case enableImageCapture:\n            /* Set flag to enable image capture in the image processing thread (rsedu_vis.c) */\n            capture = 1;\n            printf(\" Capturing Image \\n\");\n            break;\n\n          default:\n            printf(\" Invalid Request !! \\n\");\n        }\n    }\n\n}\n"},{"name":"mw_extrathreads.c","type":"source","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2021 The MathWorks, Inc. */\n//File: mw_extrathreads.c\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x)  #x\n\n#define MW_StringifyDefineFunction(x,y) MW_StringifyDefineExpandedFunction(x,y)\n#define MW_StringifyDefineExpandedFunction(x,y)  x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x)  x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x)  x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x)  x##_private.h\n\n//#include MW_StringifyDefine(MW_StringifyDefineX(MODEL))\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/fcntl.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdbool.h>\n\n#include \"rtwtypes.h\"\n\n#ifdef EXT_MODE\n#include \"rtwtypes.h\"\n#include <ext_work.h>\n#include <ext_svr.h>\n#include <ext_share.h>\n#include <updown.h>\nvoid create_background_thread(void);\n#endif\n\nextern volatile boolean_T runModel;\nextern int run_flag;\n\npthread_t tid;\n\nint connfd = 0, connfd_GUI;\nstatic int \t  yes = 1;\nint sockfd, sockfd_GUI;\nint buff_size = 38400; // Maximum buffer size of the socket\nstruct sockaddr_in serv_addr;\nint  clientConnect = 0;\n\nvoid* keyboardserver_thread(void* i);\nvoid create_referencevalserver_thread(void);\n\n#ifdef PARROT_XCP_EXT_MODE\n#include \"ext_mode.h\"\n#include \"xcp_ext_classic_trigger.h\"\nuint8_T* baseAddress = 0;\nextern int landDrone;\nchar __executable_start;\n\nuint8_T *xcpAddressGet_parrot(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (baseAddress + address);\n}\n\nvoid initialize_XCP_baseAddress(){\n    FILE* addressFile = fopen(\"/data/edu/address\", \"r\");\n    unsigned int addressOfLandDrone = 0;\n    if(addressFile < 0){\n        printf(\"Address file missing. Exiting process...\\n\");\n        exit(0);\n    }\n    fscanf(addressFile,\"%d\", &addressOfLandDrone);\n    baseAddress = (uint8_T*) &landDrone - addressOfLandDrone;\n}\n#endif\n\nvoid* keyboardserver_thread(void* i)\n{\n    struct sched_param param;\n    param.sched_priority = 9;\n    pthread_setschedparam(pthread_self(), 2, &param);\n    printf(\"keyboardserver_thread(): Entered the Keyboard Server thread... \\n\");\n    \n    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR : Could not create socket \\n\");\n        exit(1);\n    }\n    \n    printf(\"keyboardserver_thread(): Successfully created socket... \\n\");\n    \n    memset(&serv_addr, '0', sizeof(serv_addr));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serv_addr.sin_port = htons(12391);\n    \n    printf(\"keyboardserver_thread(): Bind socket... \\n\");\n    \n    // Fix : We could not run the Spider Flight Continuously. We need to wait for some time before you start the next flight.\n    // To fix the issue we are creating Socket with REUSEADDR.\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0)\n    {\n        printf(\"keyboardserver_thread(): ERROR: Failure in Reusing address.. with error: %d\\n\",errno);\n        exit(1);\n    }\n    \n    \n    if(bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR Connection to reference value server failed %d \\n\", errno);\n        exit(1);\n    }\n    else\n    {\n        printf(\"keyboardserver_thread(): Bind completed .. listening to the socket !\\n\");\n        \n        if (listen(sockfd, 10)<0)\n        {\n            printf(\"keyboardserver_thread(): Socket error (listen) %d\\n\",errno);\n            exit(1);\n        }\n        connfd = accept(sockfd, (struct sockaddr*)NULL, NULL);\n        setsockopt(connfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n        setsockopt(connfd, SOL_SOCKET, SO_SNDBUF, &buff_size, sizeof(buff_size));\n        clientConnect = 1;\n        printf(\"keyboardserver_thread(): Received connection from the host! \\n\");\n    }\n    \n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// \n    \n     if((sockfd_GUI = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR : Could not create GUI socket\\n\");\n        exit(1);\n    }\n    \n    printf(\"keyboardserver_thread(): Successfully created GUI socket... \\n\");\n    \n    memset(&serv_addr, '0', sizeof(serv_addr));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serv_addr.sin_port = htons(24099);\n    \n    printf(\"keyboardserver_thread(): Bind GUI socket...\\n\");\n    \n    // Fix : We could not run the Spider Flight Continuously. We need to wait for some time before you start the next flight.\n    // To fix the issue we are creating Socket with REUSEADDR.\n    if (setsockopt(sockfd_GUI, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0)\n    {\n        printf(\"keyboardserver_thread(): ERROR: Failure in Reusing address in GUI.. with error: %d\\n\",errno);\n        exit(1);\n    }\n    \n    \n    if(bind(sockfd_GUI, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR Connection to GUI server failed %d \\n\", errno);\n        exit(1);\n    }\n    else\n    {\n        printf(\"keyboardserver_thread(): Bind completed .. listening to the GUI socket !\\n\");\n        \n        if (listen(sockfd_GUI, 10)<0)\n        {\n            printf(\"keyboardserver_thread(): GUI Socket error (listen) %d\\n\",errno);\n            exit(1);\n        }\n        connfd_GUI = accept(sockfd_GUI, (struct sockaddr*)NULL, NULL);\n        setsockopt(connfd_GUI, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n        setsockopt(connfd_GUI, SOL_SOCKET, SO_SNDBUF, &buff_size, sizeof(buff_size));\n        printf(\"keyboardserver_thread(): Received connection to GUI from the host! \\n\");\n    }\n    \n   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    return NULL;\n}\n\nvoid create_referencevalserver_thread(void)\n{\n    int err;\n    pthread_t img_tid;\n    int policy;\n    struct sched_param param;\n    pthread_attr_t attr;\n    size_t stacksize;\n    \n    pthread_attr_init(&attr);\n    pthread_attr_getstacksize(&attr,&stacksize);\n    err = pthread_attr_setstacksize(&attr,PTHREAD_STACK_MIN);\n    printf(\"create_referencevalserver_thread(): stack size before reference value thread creation %d err=%d\\n\", stacksize,err);\n    \n    img_tid = pthread_self();\n    printf(\"create_referencevalserver_thread(): reference value server thread id = %d \\n\",(int) img_tid);\n    pthread_getschedparam(img_tid, &policy,&param);\n    printf(\"create_referencevalserver_thread(): reference value server  policy = %d pri=%d\\n\", (int)policy,param.sched_priority);\n    \n    // param1.sched_priority = param.sched_priority - 1;\n    // pthread_setschedparam(tid,policy,&param1);\n    err = pthread_create(&tid, &attr, &keyboardserver_thread, NULL);\n    if (err != 0)\n        printf(\"create_referencevalserver_thread(): ERROR: can't create thread :[%s]\", strerror(err));\n    else\n        printf(\"create_referencevalserver_thread(): Reference Server Thread created successfully\\n\");\n    \n    pthread_attr_getstacksize(&attr,&stacksize);\n    printf(\"create_referencevalserver_thread(): stacksize after reference thread creation %d \\n\", stacksize);\n}\n\n#ifdef EXT_MODE\n\nint background_task_completed = false;\npthread_t ext_tid;\n\nvoid* extmode_thread(void* i);\n\n#ifdef PARROT_XCP_EXT_MODE\n    void* extmode_thread(void* i)\n    {\n        static int counter = 0;\n        counter++;\n        \n        if (counter == 1)\n        {\n            int policy;\n            struct sched_param param ;\n            \n            pthread_getschedparam(pthread_self(), &policy,&param);\n            printf(\"extmode_thread(): External mode thread policy = %d and priority=%d\\n\", (int)policy,param.sched_priority);\n            \n            /* initialize external mode */\n            extmodeParseArgs(0, NULL);\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), 0);\n            MW_StringifyDefineFunction(MODEL,_initialize)();\n            /* External mode */\n            extmodeInit(MW_StringifyDefineFunction(MODEL,_M)->extModeInfo, &rtmGetTFinal(MW_StringifyDefineFunction(MODEL,_M)));\n            \n            { \n                extmodeWaitForHostRequest(EXTMODE_WAIT_FOREVER);\n                if (extmodeStopRequested()) {\n                    rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                }\n            }\n            xcpExtModeClassicTriggerEnabled(0);\n        }\n        while(runModel)\n        {\n            boolean_T rtmStopReq = false;\n            extmodeBackgroundRun(); // This is used when the Image processing is enabled along with multitasking. This will upload the step0() and step1() data.\n\n            if (extmodeStopRequested())\n            {\n                printf(\"extmode_thread(): Thread received STOP command \\n\");\n                rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                // Reason for the following code:\n                // If the user presses stop button before starting the flight code i.e before starting\n                // the execution step code.\n                extmodeReset();\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n            \n            if (run_flag == 0)\n            {\n                extmodeReset();\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n        }\n        \n        if (runModel == 0)\n        {\n            extmodeReset();\n            MW_StringifyDefineFunction(MODEL,_terminate)();\n        }\n        \n        background_task_completed = true;\n        return NULL;\n    }\n\n#else\n    void* extmode_thread(void* i)\n    {\n        static int counter = 0;\n        counter++;\n        \n        if (counter == 1)\n        {\n            int policy;\n            struct sched_param param ;\n            \n            pthread_getschedparam(pthread_self(), &policy,&param);\n            printf(\"extmode_thread(): External mode thread policy = %d and priority=%d\\n\", (int)policy,param.sched_priority);\n            \n            /* initialize external mode */\n            rtParseArgsForExtMode(0, NULL);\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), 0);\n            MW_StringifyDefineFunction(MODEL,_initialize)();\n            /* External mode */\n            rtSetTFinalForExtMode(&rtmGetTFinal(MW_StringifyDefineFunction(MODEL,_M)));\n            rtExtModeCheckInit(1);\n    \n            { \n                boolean_T rtmStopReq = false;\n                rtExtModeWaitForStartPkt(MW_StringifyDefineFunction(MODEL,_M)->extModeInfo, 2,\n                        &rtmStopReq);\n                if (rtmStopReq) {\n                    rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                }\n            }\n            rtERTExtModeStartMsg();\n        }\n        while(runModel)\n        {\n            boolean_T rtmStopReq = false;\n            #ifdef MW_HAS_IMAGE_PROCESSING\n                rtExtModeOneStep(MW_StringifyDefineFunction(MODEL,_M->extModeInfo), 2, &rtmStopReq); // This is used when the Image processing is enabled along with multitasking. This will upload the step0() and step1() data.\n            #else\n                rtExtModeOneStep(MW_StringifyDefineFunction(MODEL,_M->extModeInfo), 1, &rtmStopReq); // This is used when only the control code is running. Multitasking is not enabled in this case and only the step() data is required to be uploaded.\n            #endif \n            if (rtmStopReq)\n            {\n                printf(\"extmode_thread(): Thread received STOP command \\n\");\n                rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                // Reason for the following code:\n                // If the user presses stop button before starting the flight code i.e before starting\n                // the execution step code.\n                rtExtModeShutdown(1);\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n            \n            if (run_flag == 0)\n            {\n                rtExtModeShutdown(1);\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n        }\n        \n        if (runModel == 0)\n        {\n            rtExtModeShutdown(1);\n            MW_StringifyDefineFunction(MODEL,_terminate)();\n        }\n        \n        background_task_completed = true;\n        return NULL;\n    }   \n#endif\n\nvoid create_background_thread(void)\n{\n    int err, status;\n    pthread_attr_t attr;\n    size_t stacksize;\n    struct sched_param param;\n    \n    pthread_attr_init(&attr);\n    err = pthread_attr_setinheritsched(&attr,PTHREAD_EXPLICIT_SCHED);\n    printf(\"create_background_thread(): ext thread inherit scheduler option error=%d\\n\", err);\n    \n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    printf(\"create_background_thread(): value of detach status=%d\\n\", status);\n    \n    err = pthread_attr_setstacksize(&attr,PTHREAD_STACK_MIN);\n    printf(\"create_background_thread(): stacksize before thread creation err=%d\\n\", err);\n    \n    /* In case of Mambo , the policy of rsedu_control.c is set as 2 (SCHED_RR) and priority 32\n     * In case of Rolling Spider , the policy of rsedu_control.c is set as 0 (SCHED_OTHER) and priority 0\n     * Setting the policy and priority of External Mode thread as 0 (SCHED_OTHER) and priority 0 */\n    \n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    printf(\"create_background_thread(): value of scheduler policy status=%d\\n\", status);\n\n    param.sched_priority = 0;\n    status = pthread_attr_setschedparam(&attr, &param);\n    printf(\"create_background_thread(): value of scheduler param status=%d\\n\", status);\n    \n    err = pthread_create(&ext_tid, &attr, &extmode_thread, NULL);\n    if (err != 0)\n        printf(\"create_background_thread(): can't extmode thread :[%s]\", strerror(err));\n    else\n        printf(\"create_background_thread(): External mode Thread created successfully\\n\");\n    \n    pthread_attr_getstacksize(&attr,&stacksize);\n    printf(\"create_background_thread(): stacksize after ext thread creation %d \\n\", stacksize);\n    \n}\n#endif\n"},{"name":"ptimer.c","type":"source","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2018 The MathWorks, Inc. */\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include \"ptimer.h\"\n#include \"MW_target_hardware_resources.h\"\n\nvoid ptimer_init(const char funname[], FILE **ptfilepntr,int *run_flag)\n{\n    char* fullfile = (char*)(malloc(strlen(\"/tmp/edu/ptimes/pt_%s.txt\") + strlen(funname) + 1));\n    \n    mkdir(\"/tmp/edu\", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n    mkdir(\"/tmp/edu/ptimes\", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n    sprintf(fullfile,\"/tmp/edu/ptimes/pt_%s.txt\",funname);\n    printf(\"In %s; Fullpath for ptimes: %s \\n\",__func__,fullfile);\n    *ptfilepntr = fopen(fullfile,\"wb\");\n    \n    if (*ptfilepntr == NULL)\n    {\n        printf(\"Error opening ptimes file! \\n\");\n        if (run_flag!=NULL)\n        {\n            *run_flag=0;\n        }\n        return;\n    }\n    else\n    {\n        fclose(*ptfilepntr);\n        *ptfilepntr = fopen(fullfile,\"a\");\n    }\n    \n    free(fullfile);\n}\n\nvoid ptimer_start(long long *start)\n{\n    struct timeval tvalBefore;\n    /* set up start time data */\n    gettimeofday (&tvalBefore, NULL);\n    /* Start time in nanoseconds */\n    *start = tvalBefore.tv_sec*MICROS + tvalBefore.tv_usec;\n}\n\nlong long ptimer_stopstore(long long start, FILE *ptfilepntr)\n{\n    struct timeval tvalAfter;\n    long long end, elapsed;\n    \n    //-------------\n    /* get elapsed time */\n    gettimeofday (&tvalAfter, NULL);\n    /* Elapsed time in microseconds */\n    end = tvalAfter.tv_sec*MICROS + tvalAfter.tv_usec;\n    elapsed =  end - start;\n    /* Display/print time in microseconds or something */\n    if ((1 == MW_CONFIG_ENABLEPROFILING) && ptfilepntr != NULL)\n    {\n        fprintf(ptfilepntr,\"%lld, %lld, %lld \\n\",start,end,elapsed);\n    }\n    return elapsed;\n}\n\n"},{"name":"rsedu_control.c","type":"source","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2021 The MathWorks, Inc. */\n/*  @file: rsedu_control.c\n *\n * @description: This module takes care of fully controlling the drone: Stabilizing based on sensor measurements, crash handling. For this purpose, it also calls the simulink-model.\n *\n */\n\n#include \"rsedu_control.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/fcntl.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <sched.h>\n#include \"rtwtypes.h\"\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#include \"ptimer.h\"\n#ifdef EXT_MODE\n#include \"rtwtypes.h\"\n#include <ext_work.h>\n#include <ext_svr.h>\n#include <ext_share.h>\n#include <updown.h>\n#include \"MW_target_hardware_resources.h\"\n\n#ifdef PARROT_XCP_EXT_MODE\n#include \"ext_mode.h\"\n#endif\n\nvoid create_background_thread(void);\n#endif\n\n#include \"controlCommand.h\"\n#include <stdbool.h>\n\nvoid create_referencevalserver_thread(void);\nvolatile boolean_T runModel = true;\n\n//! Flight time cycles @note code runs at 200Hz! So 4000-> 20sec\nint onCycles = 4000;\n//! Amount of calibration cycles\nint calibCycles = 400;\n//! Amount of take off cycles.\nint takeoffCycles       = 200;\n\nextern int clientConnect; // 1 indicates TCP connection established between the drone and host\nextern int connfd, connfd_GUI;\nint run_flag = 1;\nextern int background_task_completed;\n\n/* Received from host*/\nint isMotorOn; // 1 indicates that the drone motors are on\nint isLanding; // 1 indicates drone is in the process of soft landing\nint throttle; // PowerGain of motors (1- 100)\nint flightDuration = 20; // Default flight duration of the drone\nextern int ack; // Acknowledgment flag\nint waitForGrabberCannon = 0;\n#ifdef MW_HAS_IMAGE_PROCESSING\nint runVisionCode= 0;\nextern long long avrgIpTime;\n#endif\n\nint grabberCannonBusy = 0;\nint landDrone = 0;\n\nvoid create_referencevalserver_thread(void);\n\n//--------------------\n// RSEDU_control\n//--------------------\n/**\n * @brief The function RSEDU_control is called at 200Hz to generate reference motor commands based on sensor values\n *\n * @param[in] hal_sensors_data Structure containing sensors current values\n * @param[out] hal_sensors_cmd Structure containing commands to send to motors and LEDs\n */\nvoid RSEDU_control(HAL_acquisition_t* hal_sensors_data, HAL_command_t* hal_sensors_cmd)\n{\n    //flight phases\n    \n    //process control\n    static int counter = 0;\n    static int counter_noOF = 0;\n    // counter to wait for TCP connection request from host\n    static int waitForTCPCounter = 0;\n    \n    // counter to wait for start command from host\n    static int waitForStartCounter = 0;\n    \n    static float MIN_BATTTAKEOFF        = 50.0; // Minimum battery level for take-off\n    static float MIN_BATT               = 30.0; // Minimum battery for continuing flight\n    static int MAX_noOF                 = 50;   // Maximum acceptable numbers of cycles without optical flow\n    \n    //power/usr input\n    static double powerGain = 0;\n    \n    //data handling\n    static double battLevelAvg;\n    \n    //float ofDefined;\n    static bool pressureSensorOk = false;\n    static float ofQuality;\n    \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    //ptiming - declare and start\n    //------------\n    long long start = 0;\n    static FILE *ptfile;\n#endif\n    \n    //------------\n    \n    // Create shorter aliases for the function arguments\n    HAL_acquisition_t* in = hal_sensors_data;\n    HAL_command_t    * out = hal_sensors_cmd;\n    \n    // Create the necessary Model Specific Buses (data structures) for model run\n    \n    static real32_T calibrationData[8] = {0.0}; // data to be passed to the Model for calib data\n    static CommandBus *keyboardServerCommands = &cmd_inport; // defined in flightControlSystem_types.h\n    static SensorsBus *SensorData = &sensor_inport; // defined in flightControlSystem_types.h\n        \n    if(waitForGrabberCannon){ // This check is active only after the flight is completed. It checks if the cannon/grabber finished executing the current command. \n                              // If this check is not done, and the 'stop' is pressed, the cannon/grabber goes into a bad state.\n        if(grabberCannonBusy) // Check if either the grabber or the cannon is busy executing a command. If true 'return'\n            return;\n        else\n            exit(0); // Else, just exit the program. \n    }   \n    \n    //ABORT FLIGHT and exit if run_flag 0\n    if (run_flag == 0)\n    {\n        stop_flight(out);\n#ifdef EXT_MODE\n        if (background_task_completed == false)\n        {\n            return;\n        }\n#endif\n        \n        if (counter > calibCycles)\n        {\n#ifdef MATFILE_LOGGING\n            printf(\"rsedu_control():Saving logged data after %i cycles... \\n\", counter);\n            rt_StopDataLogging(MATFILE, MW_StringifyDefineFunction(MODEL,_M)->rtwLogInfo);\n            printf(\"rsedu_control(): Saving logged data... DONE \\n\");\n#endif\n        }\n        \n        // Close the optical flow FIFO\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            close(of_fifo);\n        }\n        \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n        fclose(ptfile);\n#endif\n  \n        printf(\"rsedu_control(): Flight Completed after %i cycles ... DONE \\n\", counter);\n        \n#ifdef MW_HAS_IMAGE_PROCESSING\n        printf(\"RSEDU_image_processing: Average image processing time is %lldms \\n\", avrgIpTime);\n#endif\n        MW_StringifyDefineFunction(MODEL,_terminate)();\n        write(connfd_GUI, \"De\", 2);\n        usleep(1000);\n        printf(\"rsedu_control(): Good night! \\n\");\n        \n        waitForGrabberCannon = 1; // This flag is used to check if a fire command or a grab command is active. Only if it is inactive, exit the program.\n        return;\n        //exit(0);\n    }\n    \n    //Process Control\n    counter++;\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_start(&start);\n#endif\n    //==================\n    //Flight Stages s0-4\n    //==================\n    \n    //s0: Initialize (server connection, get user settings)\n    // ----------------------------------------------------\n    if (counter == 1)\n    {\n        pthread_t img_tid;\n        int policy;\n        struct sched_param param;\n        \n#ifdef PARROT_XCP_EXT_MODE\n        initialize_XCP_baseAddress();\n#endif\n        \n        img_tid = pthread_self();\n        printf(\"rsedu_control(): Control processing thread id = %d \\n\",(int) img_tid);\n        pthread_getschedparam(img_tid, &policy,&param);\n        printf(\"rsedu_control(): Control thread policy = %d pri=%d\\n\", (int)policy,param.sched_priority);\n        \n        printf(\"rsedu_control(): Battery output voltage Integrated: %5.2f V - %0d percents\\n\", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);\n        printf(\"rsedu_control(): used: %d, users: %d, gyrotemp %f, acctemp %f, presstmp %f \\n\", (int)in->used, (int)in->count_user, in->HAL_gyro_SI.temperature, in->HAL_acc_SI.temperature, in->HAL_pressure_SI.temperature);\n        // Initialize the timer for communicating with the drone\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n        ptimer_init(__func__, &(ptfile), &run_flag);\n#endif\n    }\n    \n    //s0: Comms and Model (Initialize inter-thread communication, model and calibration data)\n    // ----------------------------------------------------\n    else if (counter == 2)\n    {\n#ifdef MAMBO\n        out->HAL_ultrasound_command = ULTRASOUND_CMD_START;\n#endif\n        // Connect to Optical Flow\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            if (open_optical_flow_comm() == RETURN_FAIL)\n            {\n                printf(\"rsedu_control(): WARNING optical flow might not be running, %d!\\n\\n\", of_fifo);\n            }\n            else\n            {\n                printf(\"rsedu_control(): Got optical flow connection, %d!\\n\", of_fifo);\n            }\n        }\n        else\n        {\n            printf(\"rsedu_control(): Optical Flow deactivated! \\n\");\n        }\n    }\n    //s0: Wait for the reference value server connection and also wait for the takeoff command\n    else if (counter == 3)\n    {\n        //keep both fifos empty (Optical Flow and Vision)\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            read(of_fifo, (float*)(&of_data), sizeof(of_data));\n        }\n        \n        if (clientConnect == 0)\n        {\n            if (waitForTCPCounter == 0)\n            {\n                create_referencevalserver_thread();\n            }\n#ifdef EXT_MODE\n            if (waitForTCPCounter == 1)\n            {\n                // Create background thread only when external mode is enabled\n                create_background_thread();\n            }\n#endif\n            /*Print on droneFlightlog every 1 second*/\n            if (waitForTCPCounter % 200 == 0)\n            {\n                printf(\"rsedu_control(): Waiting for connection request from host! \\n\");\n                printf(\"\\n\\n **** Sensor Values **** \\n\");\n                printf(\"rsedu_control(): sonar altitude: %fmeters, pressure: %fpascal, gyrotemp: %fcelsius\\n\", in->HAL_ultrasound_SI.altitude, in->HAL_pressure_SI.pressure,in->HAL_gyro_SI.temperature);\n                printf(\"rsedu_control(): gyro x: %frad/s, y: %frad/s, z: %frad/s\\n\", in->HAL_gyro_SI.x,in->HAL_gyro_SI.y,in->HAL_gyro_SI.z);\n                printf(\"rsedu_control(): accel x: %fm/s2, y: %fm/s2, z: %fm/s2\\n\", in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n                printf(\"rsedu_control(): Battery output voltage Integrated: %5.2fV - %0d percents\\n\", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);\n            }\n            waitForTCPCounter ++;\n            counter = 2;\n            return;\n        }\n        else if (isMotorOn == 0)\n        {\n            /*Print on droneFlightlog every 1 second*/\n            if (waitForStartCounter % 200 == 0)\n            {\n                printf(\"rsedu_control(): Waiting for takeoff command from host! \\n\");\n            }\n            waitForStartCounter++;\n            /* Wait till start command is received. Do not start counter*/\n            counter = 2;\n            \n            /*Read if start command has been received*/\n            fcntl(connfd, F_SETFL, O_NONBLOCK);\n            memset(recvBuff, '\\0', sizeof(recvBuff));\n            recv(connfd, recvBuff, sizeof(recvBuff), O_NONBLOCK);\n            processRequest(connfd,recvBuff, in, out, keyboardServerCommands, &run_flag); //  function call to process data sent from MATLAB APIs\n            return;\n        }\n        \n        /* Set powerGain and flight duration values received from host */\n        onCycles = flightDuration * 200;\n        powerGain = throttle/100.0;\n        \n        /* Initialize model */\n        printf(\"rsedu_control(): Simulink model init started! \\n\");\n        \n        rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), 0);\n        MW_StringifyDefineFunction(MODEL,_initialize)();\n        printf(\"rsedu_control(): Simulink model init completed! \\n\");\n        \n        /*Hardcoding MAT-File logging time to Flight time*/\n#ifdef MATFILE_LOGGING\n        rtmSetTFinal(MW_StringifyDefineFunction(MODEL,_M), flightDuration);\n#endif\n        \n        //init sensor calibration measurements\n        printf(\"rsedu_control(): Initializing Calibration Data! \\n\");\n        initialize_calibration_data(calibrationData, &battLevelAvg, in);\n        \n        //Activate motors\n        out->command = BLDC_CMD_START;\n        printf(\"rsedu_control(): Drone Motors Activated! \\n\");\n        \n        //s1: Record calibration data\n        // --------------------------\n    }\n    else if (counter < calibCycles)\n    {\n        \n        if (counter%200 == 0)\n        {\n            printf(\"rsedu_control(): Calibrating Data . . . \\n\");\n        }\n        perform_calibration(counter, calibrationData,&battLevelAvg, in);\n        \n        if (in->HAL_pressure_SI.pressure != 0)\n        {\n            pressureSensorOk = true;\n        }\n        \n        //keep both fifos empty (Optical Flow and Vision)\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            read(of_fifo, (float*)(&of_data), sizeof(of_data));\n        }\n        \n        //Power motors with 0 velocity\n        stop_flight(out);\n        \n        return;\n        \n        //s2: Initialize dynamic model for control\n        // --------------------------------------\n    }\n    else if (counter == calibCycles)\n    {\n        printf(\"rsedu_control(): Batterylevel: %f\\n\", battLevelAvg);\n        \n        // Passing calibration data to Simulink\n        SensorData->SensorCalibration[0] = calibrationData[0];\n        SensorData->SensorCalibration[1] = calibrationData[1];\n        SensorData->SensorCalibration[2] = calibrationData[2];\n        SensorData->SensorCalibration[3] = calibrationData[3];\n        SensorData->SensorCalibration[4] = calibrationData[4];\n        SensorData->SensorCalibration[5] = calibrationData[5];\n        SensorData->SensorCalibration[6] = calibrationData[6];\n        SensorData->SensorCalibration[7] = calibrationData[7];\n        \n        printf(\"rsedu_control(): Sensorcal: %f :: %f :: %f :: %f :: %f :: %f :: %f :: %f \\n\",\n                calibrationData[0],\n                calibrationData[1],\n                calibrationData[2],\n                calibrationData[3],\n                calibrationData[4],\n                calibrationData[5],\n                calibrationData[6],\n                calibrationData[7]);\n        \n        //Stop if angled take-off\n        if ((!MW_CONFIG_NOSAFETY) && fabs(9.81 + calibrationData[2]) > 0.7)\n        {\n            run_flag = 0;\n            printf(\"rsedu_control(): ERROR: Please take off from a level surface! \\n\");\n            return;\n        }\n        \n        if (!pressureSensorOk)\n        {\n            run_flag = 0;\n            printf(\"rsedu_control(): ERROR: Pressure sensor appears damaged! \\n\");\n            return;\n        }\n        \n        //check if optical flow up and running\n        if ((1 == MW_CONFIG_ENABLEOPTICALFLOW) && (of_fifo < 0))\n        {\n            of_fifo = open(\"/tmp/of_fifo\", O_RDONLY); //O_NONBLOCK O_RDONLY\n            fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);\n            if (of_fifo < 0)\n            {\n                printf(\"rsedu_control(): ERROR optical flow not running!\\n\");\n                run_flag = 0;\n            }\n        }\n        \n        //Display beginning of relevant data output on screen\n        printf(\" *************************************** Data_block_start *************************************************** \\n\");\n        \n        //Power motors\n        out->command = BLDC_CMD_RUN;\n        printf(\"rsedu_control(): Motors Powered. Ready for Take-Off ! \\n\");\n        \n        //s3: Fly\n        // ------\n    }\n    else if (counter <= onCycles)\n    {\n        if ( counter % 200 == 0)\n        {\n            uint8_t bat;\n            printf(\"\\n **** Sensor Values when counter = %d **** \\n\", counter);\n            printf(\"rsedu_control(): sonar altitude: %fmeters, pressure: %fpascal, gyrotemp: %fcelsius\\n\", in->HAL_ultrasound_SI.altitude, in->HAL_pressure_SI.pressure,in->HAL_gyro_SI.temperature);\n            printf(\"rsedu_control(): gyro x: %frad/s, y: %frad/s, z: %frad/s\\n\", in->HAL_gyro_SI.x,in->HAL_gyro_SI.y,in->HAL_gyro_SI.z);\n            printf(\"rsedu_control(): accel x: %fm/s2, y: %fm/s2, z: %fm/s2\\n\", in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n            printf(\"rsedu_control(): Battery output voltage Integrated: %5.2fV - %0d percents\\n\", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);\n            bat = (uint8_t) in->HAL_vbat_SI.vbat_percentage;\n            write(connfd_GUI, \"B\", 1);\n            write(connfd_GUI, &bat, 1);\n        }\n        \n        //3.1 take off-setting\n        // +++++++++++++++++++\n        if (counter < calibCycles + takeoffCycles)\n        {\n            keyboardServerCommands->takeoff_flag = 1;  //enables take-off procedure, disables altitude-control\n            keyboardServerCommands->pos_ref[2] = -1.1;\n            \n            //React to possible low battery\n            if (in->HAL_vbat_SI.vbat_percentage < MIN_BATTTAKEOFF)\n            {\n                run_flag = 0;\n                write(connfd_GUI, \"Db\", 2);\n                printf(\"rsedu_control(): Flight aborted due to low voltage (%d %%): shutting down motors now, charge battery!\\n\", in->HAL_vbat_SI.vbat_percentage);\n                return;\n            }\n            \n            //3.2 transition to actual flight: enable altitude-control setting\n            // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n        }\n        else if (counter == calibCycles + takeoffCycles)\n        {\n            keyboardServerCommands->takeoff_flag = 0;  //disable take-off procedure, enables altitude-control\n            keyboardServerCommands->pos_ref[2] = -1.1;\n            \n            //3.3 actual flight setting\n            // ++++++++++++++++++++++++\n        }\n        else if (counter < onCycles)\n        {\n            \n            //Respond to requests from client\n            fcntl(connfd, F_SETFL, O_NONBLOCK);\n            memset(recvBuff, '\\0', sizeof(recvBuff));\n            recv(connfd, recvBuff, sizeof(recvBuff), O_NONBLOCK);\n            processRequest(connfd,recvBuff,in,out,keyboardServerCommands, &run_flag); //  function call to process data sent from MATLAB APIs\n            \n            if (isLanding == 1)\n            {\n                // Soft land the drone upon receiving a take-off command\n                soft_land_minidrone(keyboardServerCommands, out , &run_flag);\n            }\n            \n            if ((keyboardServerCommands->orient_ref[1] == 0.0) && (keyboardServerCommands->orient_ref[2] == 0.0))\n            {\n                //control position + velocity if no specific reference attitude given (yaw angle ok)\n                keyboardServerCommands->controlModePosVSOrient = 1; //1 ; 1 position reference, 0 angle reference\n            }\n            else\n            {\n                //angle control\n                keyboardServerCommands->controlModePosVSOrient = 0; //0 ; 0 position reference, 1 angle reference\n            }\n            \n            //use of position estimate from vision\n            SensorData->VisionSensors.usePosVIS_flag = MW_CONFIG_USEIMAGEVISIONFORPOSITION;\n            \n            //React to possible Flight abort request\n            if (run_flag == 0)\n            {\n                printf(\"rsedu_control(): Flight abort request: shutting down motors now\\n\");\n                return;\n            }\n            \n            //3.4 init to stop flight (because of end of flight duration)\n            // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n        }\n        else\n        {\n            powerGain = 0;\n        }\n        \n        //Actual flight control\n        //---------------------\n        //safety abort for high accelerations or position\n        bool crash_detected;\n        crash_detected = (fabs(in->HAL_acc_SI.x) > MAX_ACCELERATION) || (fabs(in->HAL_acc_SI.y) > MAX_ACCELERATION);\n        \n        bool battery_low = (in->HAL_vbat_SI.vbat_percentage < MIN_BATT) && (in->HAL_vbat_SI.vbat_percentage > 1.0);\n        \n        // log any exit reasons\n        if (crash_detected)\n        {\n            printf(\"rsedu_control(): Flight crash detected (accelerometer): shutting down motors now. accel x: %fm/s2, y: %fm/s2, z: %fm/s2\\n\", in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n        }\n        if (battery_low)\n        {\n            printf(\"rsedu_control(): Flight aborted due to low voltage (%d %%): shutting down motors now, charge battery!\\n\", in->HAL_vbat_SI.vbat_percentage);\n        }\n        \n        // and stop the drone\n        if (crash_detected)\n        {\n            run_flag = 0;\n            write(connfd_GUI, \"Dc\", 2);\n            return;\n        }\n        if (battery_low)\n        {\n            run_flag = 0;\n            write(connfd_GUI, \"Db\", 2);\n            return;\n        }\n        \n        //Input to Model: optical flow computations (setup as zero-order hold: no updates on static var when nothing new in fifo)\n        SensorData->VisionSensors.opticalFlow_data[2] = 1; // Set the OF status to true. In case the below line fails (i.e when there is no data),\n                                                           // the OF error in the model increases faster. Hence, set the flag to true and the \n                                                           // model takes the previous value. Only when data is read and the optical flow is error \n                                                           // occurs, set the status to 'error'(-1)\n        if ((1 == MW_CONFIG_ENABLEOPTICALFLOW) && (of_fifo > 0))\n        {\n            if ((read(of_fifo, (float*)(&of_data), sizeof(of_data)) > 0) && ((of_data[0] != 0.0) || (of_data[1] != 0.0)))\n            {\n                ofQuality = of_data[3];\n                //ofDefined = of_data[4];\n                if (ofQuality > 0)\n                {\n                    counter_noOF = 0;\n                    SensorData->VisionSensors.opticalFlow_data[0] = of_data[0];\n                    SensorData->VisionSensors.opticalFlow_data[1] = of_data[1];\n                    if (counter % 200 == 0)\n                    {\n                        printf(\"rsedu_control(): of: %f %f %f \\n\",of_data[0],of_data[1],of_data[2]);\n                    }\n                }\n            }\n            else\n            {\n                 SensorData->VisionSensors.opticalFlow_data[2] = -1;  // Set the OF status to false.\n#ifndef MW_HAS_OPTICAL_FLOW_LOGIC\n                if (counter > (calibCycles + takeoffCycles + 200 * 2)) // This logic is applicable only for 18b and below models. \n                                                                       // Wait for (calibCycles + takeoffCycles) + additional 2 seconds.\n                {\n                    counter_noOF += 1;\n                    if (counter_noOF >= MAX_noOF)\n                    {\n                        run_flag = 0;\n                        printf(\"rsedu_control(): Problem with optical flow, there has been no flow for %d cycles in cycle %d: shutting down motors now\\n\", counter_noOF, counter);\n                        return;\n                    }\n                }\n#endif\n            }\n        }\n        \n        keyboardServerCommands->live_time_ticks = counter;\n        \n#ifdef EXT_MODE\n        runModel = ((rtmGetErrorStatus(MW_StringifyDefineFunction(MODEL,_M))== (NULL)) &&\n                (!rtmGetStopRequested(MW_StringifyDefineFunction(MODEL,_M))));\n#else\n        runModel = rtmGetErrorStatus(MW_StringifyDefineFunction(MODEL,_M))== (NULL);\n#endif\n        if (runModel)\n        {\n            SensorData->HALSensors = *in;\n#ifdef MW_HAS_LAND_DRONE\n            keyboardServerCommands->land_drone = landDrone;\n            keyboardServerCommands->time_remaining = (onCycles - counter) * 0.005; \n#endif\n            \n           \n#ifdef PARROT_XCP_EXT_MODE\n            extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) 0;\n            currentTime = (extmodeSimulationTime_T) MW_StringifyDefineFunction(MODEL,_M)->Timing.taskTime0;\n#endif\n\n#ifdef MW_HAS_IMAGE_PROCESSING\n            MW_StringifyDefineFunction(MODEL,_step0)(); /*If the Image Processing blocks are present,\n             * the step0() has the Flight Control code. */\n                \n                runVisionCode = 1; /* This flag is polled in the Vision Thread \n                                    * to start the image processing code. \n                                    * This flag is initially set to '0'. */\n            #else\n                MW_StringifyDefineFunction(MODEL,_step)();/*If the Image Processing blocks are not present, \n                                                           * the step() has the Flight Control code.*/\n            #endif\n#ifdef EXT_MODE\n            #ifdef PARROT_XCP_EXT_MODE \n                extmodeEvent(0, currentTime);\n            #else\n                rtExtModeCheckEndTrigger();\n            #endif\n#endif\n        }\n        else\n        {\n            runModel = 0;\n            run_flag = 0;\n#ifdef EXT_MODE\n            if (rtmGetStopRequested(MW_StringifyDefineFunction(MODEL,_M)) == true)\n            {\n                rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), \"Simulation finished\");\n                return;\n            }\n#endif\n            write(connfd_GUI, \"Dm\", 2);\n            printf(\"rsedu_control(): ERROR: Error from simulink model @ counter=%i !\\n\\t%s\", counter,  rtmGetErrorStatus(MW_StringifyDefineFunction(MODEL,_M)));\n            return;\n        }\n        \n        //Currently using the 'flag_outport==99' condition along with #def 'stateEstimator_MDLREF_HIDE_CHILD_' to\n        //ensure this condition is evaluated only for the demo asbQuadcopter model.\n#ifdef stateEstimator_MDLREF_HIDE_CHILD_\n        //safety abort for high mismatch OF vs state velocities\n        if (99 == flag_outport)\n        {\n            if (ofQuality > 0 &&\n                    (counter > (calibCycles + takeoffCycles)) &&\n                    (flag_outport)\n                    )\n            {\n                run_flag = 0;\n                printf(\"rsedu_control(): Flight crash about to happen, mismatch optical flow (%f, %f) and state estimate (%f, %f): shutting down motors now\\n\",\n                        20 * of_data[0],\n                        20 * of_data[1],\n                        100.0,\n                        100.1);\n                return;\n            }\n        }\n#endif\n        \n        if (flag_outport) {\n            run_flag = 0;\n            write(connfd_GUI, \"F\", 1);\n            write(connfd_GUI, &flag_outport, 1);\n            printf(\"rsedu_control(): Flight aborted due to error condition %d !\\n\\t\",flag_outport);\n            return;\n        }\n        \n        \n        //power engines\n        if (counter < onCycles)\n        {\n            out->command = BLDC_CMD_RUN;\n        }\n        else\n        {\n            out->command = BLDC_CMD_STOP;\n            return;\n        }\n        \n        if ( counter % 200 == 0)\n        {\n            printf(\"rsedu_control(): motor values : %f %f %f %f\\n\",motors_outport[0],motors_outport[1],motors_outport[2],motors_outport[3]);\n        }\n        \n        // update motor commands with control commands\n        out->motors_speed[0] = (int)(powerGain * (fabs(motors_outport[0])));\n        out->motors_speed[1] = (int)(powerGain * (fabs(motors_outport[1])));\n        out->motors_speed[2] = (int)(powerGain * (fabs(motors_outport[2])));\n        out->motors_speed[3] = (int)(powerGain * (fabs(motors_outport[3])));\n        usleep(100);\n        \n        //s4.0 End flight: log data and close program\n        //-------------------------------------------\n    }\n    else\n    {\n        run_flag = 0;\n        stop_flight(out);\n#ifdef EXT_MODE\n        if (background_task_completed == false)\n        {\n            return;\n        }\n#endif\n#ifdef MATFILE_LOGGING\n        /* Matfile logging save*/\n        printf(\"rsedu_control(): Saving logged data at end of flight... \\n\");\n        rt_StopDataLogging(MATFILE, MW_StringifyDefineFunction(MODEL,_M)->rtwLogInfo);\n        printf(\"rsedu_control(): Saving logged data... DONE \\n\");\n#endif\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            close(of_fifo);\n        }\n        \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n            fclose(ptfile);\n#endif\n        printf(\"rsedu_control(): Flight Completed after %i cycles ... DONE \\n\", counter - 1); /*Counter value is currently onCycles + 1*/\n\n#ifdef MW_HAS_IMAGE_PROCESSING\n        printf(\"RSEDU_image_processing: Average image processing time is %lldms \\n\", avrgIpTime);\n#endif\n        printf(\"rsedu_control(): Good night! \\n\");\n        write(connfd_GUI, \"De\", 2);\n        MW_StringifyDefineFunction(MODEL,_terminate)();\n        \n        waitForGrabberCannon = 1;// This flag is used to check if a fire command or a grab command is active. Only if it is inactive, exit the program.\n        return;\n        //exit(0);\n    }\n    \n    usleep(200);\n    \n    //ptiming - store\n    //----------\n#if(1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_stopstore(start, ptfile);\n#endif\n    //----------\n}\n\n/**\n * @brief This function stops all motors and sets to command to stop\n *\n * @param[out] out Motor commands to be set\n *\n * @see HAL.h\n */\nvoid stop_flight(HAL_command_t *out)\n{\n    out->motors_speed[0] = 0;\n    out->motors_speed[1] = 0;\n    out->motors_speed[2] = 0;\n    out->motors_speed[3] = 0;\n    out->command = BLDC_CMD_STOP;\n}\n\n/**\n * @brief This function soft lands the minidrone by reducing height slowly. It is dependent on controller logic to work fully.\n *\n * @param[out] void\n *\n */\nvoid soft_land_minidrone(CommandBus *keyboardServerCommands , HAL_command_t *out, int *run_flag)\n{\n    keyboardServerCommands->orient_ref[1] = 0.0 ;\n    keyboardServerCommands->orient_ref[2] = 0.0 ;\n    keyboardServerCommands->pos_ref[2] += 0.002;\n    if (keyboardServerCommands->pos_ref[2]  > -0.2) {\n        printf(\"rsedu_control(): Stopping Motors after Land Command\\n\");\n        stop_flight(out);\n        // Resetting counter to wait for next take-off command\n        //counter = 2;\n        isLanding = 0;\n        isMotorOn = 0;\n        wrStatus = write(connfd,&(ack),sizeof(ack));\n        *run_flag = 0 ;\n    }\n}\n\n/** @brief Performs a running average on the sensor readings.\n *\n * @param[in]   ctr       The current tick counter\n * @param[out]  calibData The calibration data to be updated\n * @param[out]  battLevelAvg The battery level average to be updated\n * @param[in]   in        Current sensor reading to be used to update the running average\n */\nvoid perform_calibration(int ctr, real32_T* calibData, double* battLevelAvg, HAL_acquisition_t* in)\n{\n    \n    int counterCalib = ctr - 3;\n    \n    calibData[0] = calibData[0] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.x / counterCalib;\n    calibData[1] = calibData[1] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.y / counterCalib;\n    calibData[2] = calibData[2] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.z / counterCalib;\n    calibData[3] = calibData[3] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.x / counterCalib;\n    calibData[4] = calibData[4] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.y / counterCalib;\n    calibData[5] = calibData[5] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.z / counterCalib;\n    calibData[6] = calibData[6] * (counterCalib - 1) / counterCalib + in->HAL_pressure_SI.pressure / counterCalib;\n    calibData[7] = calibData[7] * (counterCalib - 1) / counterCalib + in->HAL_ultrasound_SI.altitude / counterCalib;\n    \n    *battLevelAvg = *battLevelAvg * (counterCalib - 1) / counterCalib + (double)(in->HAL_vbat_SI.vbat_percentage) / counterCalib;\n}\n\n/**\n * @brief Initialization of the sensor/battery calibration data\n *\n * @param[out]  calibData The calibration data to be initialized\n * @param[out]  battLevelAvg The battery level average to be initialized\n * @param[in]   in        Current sensor reading to be used to seed the running average\n */\nvoid initialize_calibration_data(real32_T* calibData, double* battLevelAvg, HAL_acquisition_t* in)\n{\n    //init sensor calibration measurements\n    calibData[0] = in->HAL_acc_SI.x;\n    calibData[1] = in->HAL_acc_SI.y;\n    calibData[2] = in->HAL_acc_SI.z;\n    calibData[3] = in->HAL_gyro_SI.x;\n    calibData[4] = in->HAL_gyro_SI.y;\n    calibData[5] = in->HAL_gyro_SI.z;\n    calibData[6] = in->HAL_pressure_SI.pressure;\n    calibData[7] = in->HAL_ultrasound_SI.altitude;\n    \n    *battLevelAvg = (double)((int)in->HAL_vbat_SI.vbat_percentage);\n}\n\n/**\n * @brief Opens the optical flow FIFO\n *\n * @return RETURN_SUCCESS indicating the process was successful, RETURN_FAIL otherwise\n */\nReturn_flag_t open_optical_flow_comm(void)\n{\n    \n    int file_access_flags;\n    \n    // Initialize communication with optical flow thread\n    printf(\"rsedu_control(): Waiting for optical flow connection...\\n\");\n    usleep(100);\n    \n    of_fifo = open(\"/tmp/of_fifo\", O_RDONLY | O_NONBLOCK);  //O_NONBLOCK O_RDONLY\n    if (of_fifo == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    file_access_flags = fcntl(of_fifo, F_GETFL);\n    if (file_access_flags == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    if (fcntl(of_fifo, F_SETFL, file_access_flags | O_NONBLOCK) == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    if (read(of_fifo, (float*)(&of_data), sizeof(of_data)) == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    return RETURN_SUCCESS;\n}\n"},{"name":"rsedu_of.c","type":"source","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"//File: rsedu_of.c\n\n#include \"rsedu_of.h\"\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include \"MW_target_hardware_resources.h\"\n#include \"ptimer.h\"\n//----------------------------------\n// OPTICAL FLOW\n//----------------------------------\n\n/*\n * @input is the result of optical flow computations, this functions then dumps these into a fifo to make them available to the control code\n *\n * Called 60 times per second.\n */\nvoid RSEDU_optical_flow(float vx, float vy, float vz, int defined, float qualityIndicator)\n{\n    \n#if defined(MW_CONFIG_ENABLEOPTICALFLOW) && (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n    \n    //process control\n    static int counter = 0;\n    \n    //communication\n    static float of_data[5];\n    static int of_fifo;\n    \n    /*\n     * PROGRAM\n     */\n    \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    //ptiming - declare and start\n    //------------\n    long long start;\n    static FILE *ptfile;\n    //------------\n#endif\n    \n    //process control\n    counter++;\n    \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_start(&start);\n#endif\n    \n    //Compile data\n    of_data[0] = vx;\n    of_data[1] = vy;\n    of_data[2] = vz;\n    of_data[3] = (float)(defined * 1.0);\n    of_data[4] = qualityIndicator;\n    \n    \n    if (counter % 60 == 0)\n    {\n        printf(\"rsedu_of(): flow: (%f, %f, %f, %f, %f)\\n\",of_data[0],of_data[1],of_data[2],of_data[3],of_data[4]);\n    }\n    \n    //Setup thread communication\n    if (counter == 1)\n    {\n        \n        \n        if (access(\"/tmp/of_fifo\", F_OK) != -1)\n        {\n            printf(\"rsedu_of(): SUCCESS optical flow FIFO exists! \\n\");\n        } else\n        {\n            printf(\"rsedu_of(): ERROR opening optical flow-fifo!\\n\");\n        }\n        \n        //ptiming - init file\n        //------------\n#if(1 == MW_CONFIG_ENABLEPROFILING)\n        ptimer_init(__func__, &(ptfile), NULL);\n#endif\n        //------------\n        \n        //usleep(10000);\n        \n    }\n    \n    //FIFO handling and writing\n    of_fifo = open(\"/tmp/of_fifo\", O_WRONLY);\n    if (of_fifo)\n    {\n        int ok = write(of_fifo, (float*)(&of_data), sizeof(of_data));\n        if (ok == -1)\n        {\n            printf(\"rsedu_of(): ERROR writing to optical flow-fifo: %s!\\n\", strerror(errno));\n        }\n        close(of_fifo);\n    }\n    else\n    {\n        printf(\"rsedu_of(): ERROR  opening optical flow-fifo: %s!\\n\", strerror(errno));\n    }\n    \n    usleep(4000);\n    \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n    //ptiming - store\n    //----------\n    ptimer_stopstore(start, ptfile);\n    //----------\n#endif\n    \n#endif\n    \n}\n"},{"name":"rsedu_vis.c","type":"source","group":"legacy","path":"C:\\Users\\navin\\MATLAB\\Projects\\examples\\asbQuadcopter\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"//File: rsedu_vis.c\n\n#include \"rsedu_vis.h\"\n#include <stdbool.h>\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/fcntl.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include \"rsedu_control.h\"\n#include <pthread.h>\n#include <semaphore.h>\n#include \"MW_target_hardware_resources.h\"\n\n#ifdef MW_HAS_IMAGE_PROCESSING\n#include \"ptimer.h\"\n#include <string.h>\n#endif\n\n#ifdef PARROT_XCP_EXT_MODE\n#include \"ext_mode.h\"\n#endif\n\n\nextern int capture;\nextern int connfd;\n\n//----------------------------------\n// Image processing / Vision-based pose estimation\n//----------------------------------\n\n/*\n * @input buffer Pointer to the current picture seen by the vertical camera\n * Picture is 160x120(width x height) pixels in YUYV format, ie 80x120 elements\n * of type 'pixel2_t'\n *\n * Called 60 times per second.\n */\n\n#ifdef MW_HAS_IMAGE_PROCESSING\nextern int runVisionCode;\n/* This is flag to start the Vision code once the\n * Control code has started. This variable is\n * updated in the Control Thread once the \"Start\"\n * button is clicked on the Flight Control UI. */\n\nuint8_T *imRGB;\n/* This is the pointer used by step code for vision. This\n * is created in Simulink by declaring the signal.*/\n\nextern int run_flag;\n/* This flag is used in the control thread to indicate\n *the \"Stop\" button is pressed on the Flight Control UI.\n * Here, it is used to stop the generated Image Processing code.*/\n\nsem_t imageCopied;\n/*Semaphore to signal when the image is obtained in the\n * RSEDU_image_processing function. Once the image is obtained,\n * the imRGB buffer is filled with the pointer to the image.\n * Then a sem_post is called, which releases the semaphore.*/\n\nint imageProcFinish = 1;\n/*This is a flag to indicate the image processing was finished.\n * This is used in the RSEDU_image_processing function to copy the image,\n * if the current image processing was complete*/\n\nlong long avrgIpTime = 0;\n/*This variable contains the average time taken for the image processing to\n * run*/\n\n/* Simple function to get the time elapsed. The start time is passed, and\n * the same variable is updated in the function. After the function returns,\n * the time gap is recorded in the start variable passed.\n */\n\nvoid* MW_image_processing(void* a)\n{\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    long long start = 0 ; // variable to store the start and stop times for profiling.\n    static FILE *ptfile; // File to which the profiling data is written to.\n#endif\n    static int counter = 2; //set the counter to get the timing data.\n    long long ipTime = 0;\n    static long long ipTimeSum = 0;\n    \n    //ptiming - init file\n    //------------\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_init(__func__, &(ptfile), NULL);\n#endif\n        while(1){\n        sem_wait(&imageCopied); //wait until the image is obtained.\n        printf(\"rsedu_vision(): Entered... \\n\");\n        \n        ptimer_start(&ipTime);\n        /* This line is added to get the image processing time for each\n         * cycle, regardless of whether the MW_CONFIG_ENABLEPROFILING is defined\n         * or not.\n         */\n        \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n        \n            //Start the profiling (Basically takes a note of the time stamp)\n            ptimer_start(&start);\n#endif\n            \n#ifdef PARROT_XCP_EXT_MODE\n            extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) 0;\n            currentTime = (extmodeSimulationTime_T) ((MW_StringifyDefineFunction(MODEL,_M)->Timing.clockTick0) *\n                                                     0.005);\n#endif\n        /* This is the step function for the Image Processing Subsystem.\n         * When the image processing is enabled,\n         * step1() contains the image processing code*/\n        MW_StringifyDefineFunction(MODEL,_step1)();\n        \n#ifdef PARROT_XCP_EXT_MODE\n            extmodeEvent(1, currentTime);\n#endif\n            \n        ipTime = ptimer_stopstore(ipTime, NULL)/1000; \n        /*Get the time consumed by the image processing and convert it to milliseconds.*/\n        ipTimeSum = ipTimeSum + ipTime;\n        /*accumulate the values, which will be used to get the average time of\n         *image processing.\n         */\n        \n        avrgIpTime = ipTimeSum / (counter - 1);\n        /*get the average Image processing time*/\n        \n        printf(\"rsedu_vision(): Exited. Time taken to process the image = %lldms\\n\", ipTime);\n        \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n        //Stop the profiling (Basically takes a note of the time stamp and writes it to a file)\n        ptimer_stopstore(start, ptfile);\n#endif\n        imageProcFinish = 1;\n        \n        if (run_flag == 0)\n        {              \n            break;  //break the loop once the flight is over.\n        }\n        counter++;\n    }\n    return NULL;\n}\n\nvoid create_image_thread(void)\n{\n    int err, status;\n    pthread_attr_t attr;\n    struct sched_param param;\n    pthread_t imageThreadHandle;\n    \n    int policy;\n    pthread_getschedparam(pthread_self(), &policy,&param);\n    printf(\"create_image_thread(): Image thread policy = %d and priority=%d\\n\", (int)policy,param.sched_priority);\n    \n    pthread_attr_init(&attr);\n    \n    err = pthread_attr_setinheritsched(&attr,PTHREAD_EXPLICIT_SCHED);\n    printf(\"create_image_thread(): Image thread inherit scheduler option error=%d\\n\", err);\n    \n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    printf(\"create_image_thread(): value of detach status=%d\\n\", status);\n    \n    err = pthread_attr_setstacksize(&attr,PTHREAD_STACK_MIN);\n    printf(\"create_image_thread(): stacksize before thread creation err=%d\\n\", err);\n    \n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    printf(\"create_image_thread(): value of scheduler policy status=%d\\n\", status);\n    \n    param.sched_priority = 0;\n    status = pthread_attr_setschedparam(&attr, &param);\n    printf(\"create_image_thread(): value of scheduler param status=%d\\n\", status);\n    \n    err = pthread_create(&imageThreadHandle, &attr, &MW_image_processing, NULL);\n    if (err != 0)\n        printf(\"create_image_thread(): can't create Image thread :[%s]\", strerror(err));\n    else\n        printf(\"create_image_thread(): Image Thread created successfully\\n\");\n}\n\n#endif\n\nvoid RSEDU_image_processing(void * buffer)\n{\n#ifdef MW_HAS_IMAGE_PROCESSING\n    static int counter = 0;\n    counter++;\n    \n    if(counter == 1)\n    {\n        sem_init(&imageCopied, 0, 0);\n        create_image_thread();\n    }\n    \n    if (runVisionCode == 1 && run_flag == 1 && imageProcFinish == 1)\n    {\n        imRGB = buffer;\n        /* Fill the pointer of the image used by Simulink,\n         * with the address of the image exposed by Parrot.*/\n        sem_post(&imageCopied); //Post the semaphore to start the image processing.\n        \n        imageProcFinish = 0;\n        /*clear the flag, which will be updated from the\n         * image processing thread.*/\n    }\n    usleep(50000);\n    /*This sleep is required to make the Vision thread sleep so that the\n     * newly created image processing thread and the external mode thread\n     * gets time to run. Without this sleep, new images are captured and\n     * dropped and consumes CPU without any purpose. Since a new image is \n     * obtained only after this sleep, this can be considered to be the \n     * sample time of the image processing. The sample time is 50ms.\n     */\n#endif\n    \n    /*  Image capture logic */\n    if (1 == capture) {\n        write(connfd,buffer,sizeof(pixel2_t)*80*120);   // Write YUV422 pixel values into socket\n        printf(\"rsedu_vis(): Image capture successful. \\n\");\n        capture  = 0; //Reset the image capture flag\n    }\n    \n}"},{"name":"rt_logging.c","type":"source","group":"other","path":"C:\\Program Files\\MATLAB\\R2021b\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2020 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       (void) memcpy(currRealRow, &rtNaN, elSize);\n                    } else if (dTypeID == SS_SINGLE){\n                        (void) memcpy(currRealRow, &rtNaNF, elSize);\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};